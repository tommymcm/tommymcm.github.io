<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::MemoryDependenceResults Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="classllvm_1_1MemoryDependenceResults.html">MemoryDependenceResults</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classllvm_1_1MemoryDependenceResults-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">llvm::MemoryDependenceResults Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides a lazy, caching interface for making common memory aliasing information queries, backed by LLVM's alias analysis passes.  
 <a href="classllvm_1_1MemoryDependenceResults.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="MemoryDependenceAnalysis_8h_source.html">llvm/Analysis/MemoryDependenceAnalysis.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1fb5d4e618ecf28ecd42ab6fab5a4245"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a1fb5d4e618ecf28ecd42ab6fab5a4245">NonLocalDepInfo</a> = std::vector&lt; <a class="el" href="classllvm_1_1NonLocalDepEntry.html">NonLocalDepEntry</a> &gt;</td></tr>
<tr class="separator:a1fb5d4e618ecf28ecd42ab6fab5a4245"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea84868ea8f52d6f6040a515a35adc30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#aea84868ea8f52d6f6040a515a35adc30">MemoryDependenceResults</a> (<a class="el" href="namespacellvm.html#ac90ac8b51451918499fc89d1d7add259">AliasAnalysis</a> &amp;AA, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> &amp;AC, const <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> &amp;TLI, <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> &amp;DT, <a class="el" href="classllvm_1_1PhiValues.html">PhiValues</a> &amp;PV)</td></tr>
<tr class="separator:aea84868ea8f52d6f6040a515a35adc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb9a6afa20a9c40940f135b6a1cf59b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#afdb9a6afa20a9c40940f135b6a1cf59b">invalidate</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, const <a class="el" href="classllvm_1_1PreservedAnalyses.html">PreservedAnalyses</a> &amp;PA, <a class="el" href="classllvm_1_1AnalysisManager_1_1Invalidator.html">FunctionAnalysisManager::Invalidator</a> &amp;Inv)</td></tr>
<tr class="memdesc:afdb9a6afa20a9c40940f135b6a1cf59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle invalidation in the new PM.  <a href="classllvm_1_1MemoryDependenceResults.html#afdb9a6afa20a9c40940f135b6a1cf59b">More...</a><br /></td></tr>
<tr class="separator:afdb9a6afa20a9c40940f135b6a1cf59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2685b1764b0730fb0ff4379700b9aba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#aa2685b1764b0730fb0ff4379700b9aba">getDefaultBlockScanLimit</a> () const</td></tr>
<tr class="memdesc:aa2685b1764b0730fb0ff4379700b9aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some methods limit the number of instructions they will examine.  <a href="classllvm_1_1MemoryDependenceResults.html#aa2685b1764b0730fb0ff4379700b9aba">More...</a><br /></td></tr>
<tr class="separator:aa2685b1764b0730fb0ff4379700b9aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3b0ec38a8ae9f8691afab6a1376336"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MemDepResult.html">MemDepResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a1d3b0ec38a8ae9f8691afab6a1376336">getDependency</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *QueryInst, <a class="el" href="classllvm_1_1OrderedBasicBlock.html">OrderedBasicBlock</a> *OBB=nullptr)</td></tr>
<tr class="memdesc:a1d3b0ec38a8ae9f8691afab6a1376336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instruction on which a memory operation depends.  <a href="classllvm_1_1MemoryDependenceResults.html#a1d3b0ec38a8ae9f8691afab6a1376336">More...</a><br /></td></tr>
<tr class="separator:a1d3b0ec38a8ae9f8691afab6a1376336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7240503037f0c0499222a41a5f22d06"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classllvm_1_1MemoryDependenceResults.html#a1fb5d4e618ecf28ecd42ab6fab5a4245">NonLocalDepInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#aa7240503037f0c0499222a41a5f22d06">getNonLocalCallDependency</a> (<a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *QueryCall)</td></tr>
<tr class="memdesc:aa7240503037f0c0499222a41a5f22d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a full dependency query for the specified call, returning the set of blocks that the value is potentially live across.  <a href="classllvm_1_1MemoryDependenceResults.html#aa7240503037f0c0499222a41a5f22d06">More...</a><br /></td></tr>
<tr class="separator:aa7240503037f0c0499222a41a5f22d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46fb372d99dc0562d09cfdcd041d5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#ab46fb372d99dc0562d09cfdcd041d5ab">getNonLocalPointerDependency</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *QueryInst, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1NonLocalDepResult.html">NonLocalDepResult</a> &gt; &amp;Result)</td></tr>
<tr class="memdesc:ab46fb372d99dc0562d09cfdcd041d5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a full dependency query for an access to the QueryInst's specified memory location, returning the set of instructions that either define or clobber the value.  <a href="classllvm_1_1MemoryDependenceResults.html#ab46fb372d99dc0562d09cfdcd041d5ab">More...</a><br /></td></tr>
<tr class="separator:ab46fb372d99dc0562d09cfdcd041d5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4082748189dc3460ea7130cd8d7790b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a4082748189dc3460ea7130cd8d7790b5">removeInstruction</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *InstToRemove)</td></tr>
<tr class="memdesc:a4082748189dc3460ea7130cd8d7790b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an instruction from the dependence analysis, updating the dependence of instructions that previously depended on it.  <a href="classllvm_1_1MemoryDependenceResults.html#a4082748189dc3460ea7130cd8d7790b5">More...</a><br /></td></tr>
<tr class="separator:a4082748189dc3460ea7130cd8d7790b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5826c1be70ba257e98f90ed73a6b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a2a5826c1be70ba257e98f90ed73a6b7c">invalidateCachedPointerInfo</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr)</td></tr>
<tr class="memdesc:a2a5826c1be70ba257e98f90ed73a6b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates cached information about the specified pointer, because it may be too conservative in memdep.  <a href="classllvm_1_1MemoryDependenceResults.html#a2a5826c1be70ba257e98f90ed73a6b7c">More...</a><br /></td></tr>
<tr class="separator:a2a5826c1be70ba257e98f90ed73a6b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278345b63e562031b41d6900c3e3bfb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a278345b63e562031b41d6900c3e3bfb3">invalidateCachedPredecessors</a> ()</td></tr>
<tr class="memdesc:a278345b63e562031b41d6900c3e3bfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the <a class="el" href="classllvm_1_1PredIteratorCache.html" title="PredIteratorCache - This class is an extremely trivial cache for predecessor iterator queries.">PredIteratorCache</a> info.  <a href="classllvm_1_1MemoryDependenceResults.html#a278345b63e562031b41d6900c3e3bfb3">More...</a><br /></td></tr>
<tr class="separator:a278345b63e562031b41d6900c3e3bfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3618632e2e7a198df9983ffd34246462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MemDepResult.html">MemDepResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a3618632e2e7a198df9983ffd34246462">getPointerDependencyFrom</a> (const <a class="el" href="classllvm_1_1MemoryLocation.html">MemoryLocation</a> &amp;Loc, <a class="el" href="classbool.html">bool</a> isLoad, <a class="el" href="classllvm_1_1BasicBlock.html#a98c0a84a5dfa8bce341c829709f171e5">BasicBlock::iterator</a> ScanIt, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *BB, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *QueryInst=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *Limit=nullptr, <a class="el" href="classllvm_1_1OrderedBasicBlock.html">OrderedBasicBlock</a> *OBB=nullptr)</td></tr>
<tr class="memdesc:a3618632e2e7a198df9983ffd34246462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instruction on which a memory location depends.  <a href="classllvm_1_1MemoryDependenceResults.html#a3618632e2e7a198df9983ffd34246462">More...</a><br /></td></tr>
<tr class="separator:a3618632e2e7a198df9983ffd34246462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373395a35eb3163a30b11bfb3f09fabf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MemDepResult.html">MemDepResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a373395a35eb3163a30b11bfb3f09fabf">getSimplePointerDependencyFrom</a> (const <a class="el" href="classllvm_1_1MemoryLocation.html">MemoryLocation</a> &amp;MemLoc, <a class="el" href="classbool.html">bool</a> isLoad, <a class="el" href="classllvm_1_1BasicBlock.html#a98c0a84a5dfa8bce341c829709f171e5">BasicBlock::iterator</a> ScanIt, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *BB, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *QueryInst, <a class="el" href="classunsigned.html">unsigned</a> *Limit, <a class="el" href="classllvm_1_1OrderedBasicBlock.html">OrderedBasicBlock</a> *OBB)</td></tr>
<tr class="separator:a373395a35eb3163a30b11bfb3f09fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ed5939e93e21552b452f5f82a73a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MemDepResult.html">MemDepResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a81ed5939e93e21552b452f5f82a73a38">getInvariantGroupPointerDependency</a> (<a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *BB)</td></tr>
<tr class="memdesc:a81ed5939e93e21552b452f5f82a73a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This analysis looks for other loads and stores with invariant.group metadata and the same pointer operand.  <a href="classllvm_1_1MemoryDependenceResults.html#a81ed5939e93e21552b452f5f82a73a38">More...</a><br /></td></tr>
<tr class="separator:a81ed5939e93e21552b452f5f82a73a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81aabf5a99fd1f67c2619a1386731d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#ae81aabf5a99fd1f67c2619a1386731d6">releaseMemory</a> ()</td></tr>
<tr class="memdesc:ae81aabf5a99fd1f67c2619a1386731d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release memory in caches.  <a href="classllvm_1_1MemoryDependenceResults.html#ae81aabf5a99fd1f67c2619a1386731d6">More...</a><br /></td></tr>
<tr class="separator:ae81aabf5a99fd1f67c2619a1386731d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3ebea96689f2d2d9ee4bcc2e78a7938b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryDependenceResults.html#a3ebea96689f2d2d9ee4bcc2e78a7938b">getLoadLoadClobberFullWidthSize</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *MemLocBase, int64_t MemLocOffs, <a class="el" href="classunsigned.html">unsigned</a> MemLocSize, const <a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI)</td></tr>
<tr class="memdesc:a3ebea96689f2d2d9ee4bcc2e78a7938b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks at a memory location for a load (specified by MemLocBase, Offs, and Size) and compares it against a load.  <a href="classllvm_1_1MemoryDependenceResults.html#a3ebea96689f2d2d9ee4bcc2e78a7938b">More...</a><br /></td></tr>
<tr class="separator:a3ebea96689f2d2d9ee4bcc2e78a7938b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Provides a lazy, caching interface for making common memory aliasing information queries, backed by LLVM's alias analysis passes. </p>
<p >The dependency information returned is somewhat unusual, but is pragmatic. If queried about a store or call that might modify memory, the analysis will return the instruction[s] that may either load from that memory or store to it. If queried with a load or call that can never modify memory, the analysis will return calls and stores that might modify the pointer, but generally does not return loads unless a) they are volatile, or b) they load from <em>must-aliased</em> pointers. Returning a dependence on must-alias'd pointers instead of all pointers interacts well with the internal caching mechanism. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00276">276</a> of file <a class="el" href="MemoryDependenceAnalysis_8h_source.html">MemoryDependenceAnalysis.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1fb5d4e618ecf28ecd42ab6fab5a4245" name="a1fb5d4e618ecf28ecd42ab6fab5a4245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb5d4e618ecf28ecd42ab6fab5a4245">&#9670;&nbsp;</a></span>NonLocalDepInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classllvm_1_1MemoryDependenceResults.html#a1fb5d4e618ecf28ecd42ab6fab5a4245">llvm::MemoryDependenceResults::NonLocalDepInfo</a> =  std::vector&lt;<a class="el" href="classllvm_1_1NonLocalDepEntry.html">NonLocalDepEntry</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00282">282</a> of file <a class="el" href="MemoryDependenceAnalysis_8h_source.html">MemoryDependenceAnalysis.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea84868ea8f52d6f6040a515a35adc30" name="aea84868ea8f52d6f6040a515a35adc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea84868ea8f52d6f6040a515a35adc30">&#9670;&nbsp;</a></span>MemoryDependenceResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MemoryDependenceResults.html">llvm::MemoryDependenceResults::MemoryDependenceResults</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#ac90ac8b51451918499fc89d1d7add259">AliasAnalysis</a> &amp;&#160;</td>
          <td class="paramname"><em>AA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> &amp;&#160;</td>
          <td class="paramname"><em>AC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>TLI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> &amp;&#160;</td>
          <td class="paramname"><em>DT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PhiValues.html">PhiValues</a> &amp;&#160;</td>
          <td class="paramname"><em>PV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00366">366</a> of file <a class="el" href="MemoryDependenceAnalysis_8h_source.html">MemoryDependenceAnalysis.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2685b1764b0730fb0ff4379700b9aba" name="aa2685b1764b0730fb0ff4379700b9aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2685b1764b0730fb0ff4379700b9aba">&#9670;&nbsp;</a></span>getDefaultBlockScanLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> MemoryDependenceResults::getDefaultBlockScanLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some methods limit the number of instructions they will examine. </p>
<p >The return value of this method is the default limit that will be used if no limit is explicitly passed in. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l01809">1809</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemoryDependenceAnalysis_8cpp.html#afe8b73d52b1eb3bf70a363b023e89b76">BlockScanLimit</a>.</p>

<p class="reference">Referenced by <a class="el" href="DeadStoreElimination_8cpp_source.html#l01073">eliminateDeadStores()</a>.</p>

</div>
</div>
<a id="a1d3b0ec38a8ae9f8691afab6a1376336" name="a1d3b0ec38a8ae9f8691afab6a1376336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3b0ec38a8ae9f8691afab6a1376336">&#9670;&nbsp;</a></span>getDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MemDepResult.html">MemDepResult</a> MemoryDependenceResults::getDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>QueryInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1OrderedBasicBlock.html">OrderedBasicBlock</a> *&#160;</td>
          <td class="paramname"><em>OBB</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the instruction on which a memory operation depends. </p>
<p >See the class comment for more details. It is illegal to call this on non-memory instructions. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00714">714</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="BasicBlock_8h_source.html#l00268">llvm::BasicBlock::begin()</a>, <a class="el" href="Function_8h_source.html#l00664">llvm::Function::getEntryBlock()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00177">llvm::MemDepResult::getInst()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00116">GetLocation()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00142">llvm::MemDepResult::getNonFuncLocal()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00139">llvm::MemDepResult::getNonLocal()</a>, <a class="el" href="BasicBlock_8h_source.html#l00106">llvm::BasicBlock::getParent()</a>, <a class="el" href="Instruction_8h_source.html#l00066">llvm::Instruction::getParent()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00327">getPointerDependencyFrom()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00145">llvm::MemDepResult::getUnknown()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00150">llvm::isModSet()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00458">llvm::AAResults::onlyReadsMemory()</a>, <a class="el" href="MemoryLocation_8h_source.html#l00182">llvm::MemoryLocation::Ptr</a>, and <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00099">RemoveFromReverseMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DeadStoreElimination_8cpp_source.html#l01073">eliminateDeadStores()</a>, and <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00785">getNonLocalCallDependency()</a>.</p>

</div>
</div>
<a id="a81ed5939e93e21552b452f5f82a73a38" name="a81ed5939e93e21552b452f5f82a73a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ed5939e93e21552b452f5f82a73a38">&#9670;&nbsp;</a></span>getInvariantGroupPointerDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MemDepResult.html">MemDepResult</a> MemoryDependenceResults::getInvariantGroupPointerDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *&#160;</td>
          <td class="paramname"><em>LI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>BB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This analysis looks for other loads and stores with invariant.group metadata and the same pointer operand. </p>
<p >Returns Unknown if it does not find anything, and Def if it can be assumed that 2 instructions load or store the same value and NonLocal which indicate that non-local Def was found, which can be retrieved by calling getNonLocalPointerDependency with the same queried instruction. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00356">356</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="Dominators_8cpp_source.html#l00248">llvm::DominatorTree::dominates()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00131">llvm::MemDepResult::getDef()</a>, <a class="el" href="Instruction_8h_source.html#l00234">llvm::Instruction::getMetadata()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00139">llvm::MemDepResult::getNonLocal()</a>, <a class="el" href="Instruction_8h_source.html#l00066">llvm::Instruction::getParent()</a>, <a class="el" href="Instructions_8h_source.html#l00284">llvm::LoadInst::getPointerOperand()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00145">llvm::MemDepResult::getUnknown()</a>, <a class="el" href="LLVMContext_8h_source.html#l00091">llvm::LLVMContext::MD_invariant_group</a>, <a class="el" href="Value_8cpp_source.html#l00535">llvm::Value::stripPointerCasts()</a>, and <a class="el" href="Value_8h_source.html#l00354">llvm::Value::uses()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00327">getPointerDependencyFrom()</a>.</p>

</div>
</div>
<a id="a3ebea96689f2d2d9ee4bcc2e78a7938b" name="a3ebea96689f2d2d9ee4bcc2e78a7938b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebea96689f2d2d9ee4bcc2e78a7938b">&#9670;&nbsp;</a></span>getLoadLoadClobberFullWidthSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> MemoryDependenceResults::getLoadLoadClobberFullWidthSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>MemLocBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>MemLocOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>MemLocSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *&#160;</td>
          <td class="paramname"><em>LI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Looks at a memory location for a load (specified by MemLocBase, Offs, and Size) and compares it against a load. </p>
<p >If the specified load could be safely widened to a larger integer load that is 1) still efficient, 2) safe for the target, and 3) would provide the specified memory location value, then this function returns the size in bytes of the load width to use. If not, this returns zero. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00240">240</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayout_8h_source.html#l00339">llvm::DataLayout::fitsInLegalInteger()</a>, <a class="el" href="Instructions_8h_source.html#l00240">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Module_8cpp_source.html#l00369">llvm::Module::getDataLayout()</a>, <a class="el" href="Instruction_8cpp_source.html#l00055">llvm::Instruction::getModule()</a>, <a class="el" href="BasicBlock_8h_source.html#l00106">llvm::BasicBlock::getParent()</a>, <a class="el" href="Instruction_8h_source.html#l00066">llvm::Instruction::getParent()</a>, <a class="el" href="ValueTracking_8h_source.html#l00244">llvm::GetPointerBaseWithConstantOffset()</a>, <a class="el" href="Instructions_8h_source.html#l00284">llvm::LoadInst::getPointerOperand()</a>, <a class="el" href="Type_8cpp_source.html#l00114">llvm::Type::getPrimitiveSizeInBits()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="Function_8h_source.html#l00323">llvm::Function::hasFnAttribute()</a>, <a class="el" href="Instructions_8h_source.html#l00276">llvm::LoadInst::isSimple()</a>, and <a class="el" href="MathExtras_8h_source.html#l00644">llvm::NextPowerOf2()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VNCoercion_8cpp_source.html#l00246">llvm::VNCoercion::analyzeLoadFromClobberingLoad()</a>.</p>

</div>
</div>
<a id="aa7240503037f0c0499222a41a5f22d06" name="aa7240503037f0c0499222a41a5f22d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7240503037f0c0499222a41a5f22d06">&#9670;&nbsp;</a></span>getNonLocalCallDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classllvm_1_1MemoryDependenceResults.html#a1fb5d4e618ecf28ecd42ab6fab5a4245">MemoryDependenceResults::NonLocalDepInfo</a> &amp; MemoryDependenceResults::getNonLocalCallDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *&#160;</td>
          <td class="paramname"><em>QueryCall</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a full dependency query for the specified call, returning the set of blocks that the value is potentially live across. </p>
<p >The returned set of results will include a "NonLocal" result for all blocks where the value is live across.</p>
<p >This method assumes the instruction returns a "NonLocal" dependency within its own block.</p>
<p >This returns a reference to an internal data structure that may be invalidated on the next non-local query or when an instruction is removed. Clients must copy this data if they want it around longer than that. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00785">785</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00775">AssertSorted()</a>, <a class="el" href="BasicBlock_8h_source.html#l00268">llvm::BasicBlock::begin()</a>, <a class="el" href="BasicBlock_8h_source.html#l00270">llvm::BasicBlock::end()</a>, <a class="el" href="PredIteratorCache_8h_source.html#l00066">llvm::PredIteratorCache::get()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00714">getDependency()</a>, <a class="el" href="Function_8h_source.html#l00664">llvm::Function::getEntryBlock()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00177">llvm::MemDepResult::getInst()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00142">llvm::MemDepResult::getNonFuncLocal()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00139">llvm::MemDepResult::getNonLocal()</a>, <a class="el" href="BasicBlock_8h_source.html#l00106">llvm::BasicBlock::getParent()</a>, <a class="el" href="Instruction_8h_source.html#l00066">llvm::Instruction::getParent()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00226">llvm::NonLocalDepEntry::getResult()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00159">llvm::MemDepResult::isNonLocal()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00458">llvm::AAResults::onlyReadsMemory()</a>, and <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00224">llvm::NonLocalDepEntry::setResult()</a>.</p>

</div>
</div>
<a id="ab46fb372d99dc0562d09cfdcd041d5ab" name="ab46fb372d99dc0562d09cfdcd041d5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46fb372d99dc0562d09cfdcd041d5ab">&#9670;&nbsp;</a></span>getNonLocalPointerDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryDependenceResults::getNonLocalPointerDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>QueryInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1NonLocalDepResult.html">NonLocalDepResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a full dependency query for an access to the QueryInst's specified memory location, returning the set of instructions that either define or clobber the value. </p>
<p >Warning: For a volatile query instruction, the dependencies will be accurate, and thus usable for reordering, but it is never legal to remove the query instruction.</p>
<p >This method assumes the pointer has a "NonLocal" dependency within QueryInst's parent basic block. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00914">914</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#ac226f3d2b9ca090171a8e0a8cb92c343add7bf230fde8d4836917806aff6a6b27">llvm::Address</a>, <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="DebugInfoMetadata_8h_source.html#l00073">llvm::DITypeRefArray::get()</a>, <a class="el" href="Module_8cpp_source.html#l00369">llvm::Module::getDataLayout()</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00133">llvm::BasicBlock::getModule()</a>, <a class="el" href="Instruction_8h_source.html#l00066">llvm::Instruction::getParent()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00145">llvm::MemDepResult::getUnknown()</a>, <a class="el" href="MemorySSA_8cpp_source.html#l01703">isOrdered()</a>, <a class="el" href="Type_8h_source.html#l00223">llvm::Type::isPointerTy()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00317">isVolatile()</a>, and <a class="el" href="MemoryLocation_8h_source.html#l00182">llvm::MemoryLocation::Ptr</a>.</p>

</div>
</div>
<a id="a3618632e2e7a198df9983ffd34246462" name="a3618632e2e7a198df9983ffd34246462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3618632e2e7a198df9983ffd34246462">&#9670;&nbsp;</a></span>getPointerDependencyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MemDepResult.html">MemDepResult</a> MemoryDependenceResults::getPointerDependencyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1MemoryLocation.html">MemoryLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isLoad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html#a98c0a84a5dfa8bce341c829709f171e5">BasicBlock::iterator</a>&#160;</td>
          <td class="paramname"><em>ScanIt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>BB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>QueryInst</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>Limit</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1OrderedBasicBlock.html">OrderedBasicBlock</a> *&#160;</td>
          <td class="paramname"><em>OBB</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the instruction on which a memory location depends. </p>
<p >If isLoad is true, this routine ignores may-aliases with read-only operations. If isLoad is false, this routine ignores may-aliases with reads from read-only locations. If possible, pass the query instruction as well; this function may take advantage of the metadata annotated to the query instruction to refine the result. <code>Limit</code> can be used to set the maximum number of instructions that will be examined to find the pointer dependency. On return, it will be set to the number of instructions left to examine. If a null pointer is passed in, the limit will default to the value of -memdep-block-scan-limit.</p>
<p >Note that this is an uncached query, and thus may be inefficient. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00327">327</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00356">getInvariantGroupPointerDependency()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00440">getSimplePointerDependencyFrom()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00145">llvm::MemDepResult::getUnknown()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00155">llvm::MemDepResult::isDef()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00159">llvm::MemDepResult::isNonLocal()</a>, and <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00171">llvm::MemDepResult::isUnknown()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DeadStoreElimination_8cpp_source.html#l01073">eliminateDeadStores()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00714">getDependency()</a>, and <a class="el" href="DeadStoreElimination_8cpp_source.html#l00656">handleFree()</a>.</p>

</div>
</div>
<a id="a373395a35eb3163a30b11bfb3f09fabf" name="a373395a35eb3163a30b11bfb3f09fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373395a35eb3163a30b11bfb3f09fabf">&#9670;&nbsp;</a></span>getSimplePointerDependencyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MemDepResult.html">MemDepResult</a> MemoryDependenceResults::getSimplePointerDependencyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1MemoryLocation.html">MemoryLocation</a> &amp;&#160;</td>
          <td class="paramname"><em>MemLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isLoad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html#a98c0a84a5dfa8bce341c829709f171e5">BasicBlock::iterator</a>&#160;</td>
          <td class="paramname"><em>ScanIt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>BB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>QueryInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>Limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1OrderedBasicBlock.html">OrderedBasicBlock</a> *&#160;</td>
          <td class="paramname"><em>OBB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00440">440</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AliasAnalysis_8cpp_source.html#l00104">llvm::AAResults::alias()</a>, <a class="el" href="BasicBlock_8h_source.html#l00268">llvm::BasicBlock::begin()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp.html#afe8b73d52b1eb3bf70a363b023e89b76">BlockScanLimit</a>, <a class="el" href="AliasAnalysis_8cpp_source.html#l00639">llvm::AAResults::callCapturesBefore()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00182">llvm::clearMust()</a>, <a class="el" href="DebugInfoMetadata_8h_source.html#l00073">llvm::DITypeRefArray::get()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00135">llvm::MemDepResult::getClobber()</a>, <a class="el" href="Module_8cpp_source.html#l00369">llvm::Module::getDataLayout()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00131">llvm::MemDepResult::getDef()</a>, <a class="el" href="Function_8h_source.html#l00664">llvm::Function::getEntryBlock()</a>, <a class="el" href="Instruction_8h_source.html#l00234">llvm::Instruction::getMetadata()</a>, <a class="el" href="AliasAnalysis_8cpp_source.html#l00176">llvm::AAResults::getModRefInfo()</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00133">llvm::BasicBlock::getModule()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00142">llvm::MemDepResult::getNonFuncLocal()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00139">llvm::MemDepResult::getNonLocal()</a>, <a class="el" href="BasicBlock_8h_source.html#l00106">llvm::BasicBlock::getParent()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l03700">llvm::GetUnderlyingObject()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00145">llvm::MemDepResult::getUnknown()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00146">llvm::isModAndRefSet()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00143">llvm::isModOrRefSet()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00381">llvm::AAResults::isMustAlias()</a>, <a class="el" href="MemoryBuiltins_8cpp_source.html#l00229">llvm::isNoAliasFn()</a>, <a class="el" href="AtomicOrdering_8h_source.html#l00119">llvm::isStrongerThanUnordered()</a>, <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00317">isVolatile()</a>, <a class="el" href="Compiler_8h_source.html#l00250">LLVM_FALLTHROUGH</a>, <a class="el" href="LLVMContext_8h_source.html#l00081">llvm::LLVMContext::MD_invariant_load</a>, <a class="el" href="namespacellvm.html#a9db8c44b250b90e3ab7e4d144e7c9c2ea7aeb0277500c86e4aa6bd23f9a737942">llvm::Mod</a>, <a class="el" href="namespacellvm.html#abf74b2f0dbae96f4708d3e407b36df02a14194d0b2e6c6680067975517cd58eac">llvm::Monotonic</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00090">llvm::MustAlias</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00084">llvm::NoAlias</a>, <a class="el" href="namespacellvm.html#a9db8c44b250b90e3ab7e4d144e7c9c2ead974636fce6d12e72054e61fb3c1e9a8">llvm::NoModRef</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00088">llvm::PartialAlias</a>, <a class="el" href="AliasAnalysis_8cpp_source.html#l00120">llvm::AAResults::pointsToConstantMemory()</a>, <a class="el" href="MemoryLocation_8h_source.html#l00182">llvm::MemoryLocation::Ptr</a>, <a class="el" href="namespacellvm.html#a9db8c44b250b90e3ab7e4d144e7c9c2ea60baadb22e80b147e4885ad16760e569">llvm::Ref</a>, and <a class="el" href="namespacellvm.html#abf74b2f0dbae96f4708d3e407b36df02ab8e7b465df7c5979dc731d06e84ce2cf">llvm::Release</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00327">getPointerDependencyFrom()</a>.</p>

</div>
</div>
<a id="afdb9a6afa20a9c40940f135b6a1cf59b" name="afdb9a6afa20a9c40940f135b6a1cf59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb9a6afa20a9c40940f135b6a1cf59b">&#9670;&nbsp;</a></span>invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> MemoryDependenceResults::invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1PreservedAnalyses.html">PreservedAnalyses</a> &amp;&#160;</td>
          <td class="paramname"><em>PA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AnalysisManager_1_1Invalidator.html">FunctionAnalysisManager::Invalidator</a> &amp;&#160;</td>
          <td class="paramname"><em>Inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle invalidation in the new PM. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l01790">1790</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="PassManager_8h_source.html#l00311">llvm::PreservedAnalyses::getChecker()</a>, and <a class="el" href="PassManager_8h_source.html#l00666">llvm::AnalysisManager&lt; IRUnitT, ExtraArgTs &gt;::Invalidator::invalidate()</a>.</p>

</div>
</div>
<a id="a2a5826c1be70ba257e98f90ed73a6b7c" name="a2a5826c1be70ba257e98f90ed73a6b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5826c1be70ba257e98f90ed73a6b7c">&#9670;&nbsp;</a></span>invalidateCachedPointerInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryDependenceResults::invalidateCachedPointerInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates cached information about the specified pointer, because it may be too conservative in memdep. </p>
<p >This is an optional call that can be used when the client detects an equivalence between the pointer and some other value and replaces the other value with ptr. This can make Ptr available in more places that cached info does not necessarily keep. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l01525">1525</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="PhiValues_8cpp_source.html#l00123">llvm::PhiValues::invalidateValue()</a>, and <a class="el" href="Type_8h_source.html#l00223">llvm::Type::isPointerTy()</a>.</p>

</div>
</div>
<a id="a278345b63e562031b41d6900c3e3bfb3" name="a278345b63e562031b41d6900c3e3bfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278345b63e562031b41d6900c3e3bfb3">&#9670;&nbsp;</a></span>invalidateCachedPredecessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryDependenceResults::invalidateCachedPredecessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the <a class="el" href="classllvm_1_1PredIteratorCache.html" title="PredIteratorCache - This class is an extremely trivial cache for predecessor iterator queries.">PredIteratorCache</a> info. </p>
<p >This needs to be done when the CFG changes, e.g., due to splitting critical edges. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l01537">1537</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="PredIteratorCache_8h_source.html#l00071">llvm::PredIteratorCache::clear()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BasicBlockUtils_8cpp_source.html#l00171">llvm::MergeBlockIntoPredecessor()</a>.</p>

</div>
</div>
<a id="ae81aabf5a99fd1f67c2619a1386731d6" name="ae81aabf5a99fd1f67c2619a1386731d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81aabf5a99fd1f67c2619a1386731d6">&#9670;&nbsp;</a></span>releaseMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void llvm::MemoryDependenceResults::releaseMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release memory in caches. </p>

</div>
</div>
<a id="a4082748189dc3460ea7130cd8d7790b5" name="a4082748189dc3460ea7130cd8d7790b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4082748189dc3460ea7130cd8d7790b5">&#9670;&nbsp;</a></span>removeInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryDependenceResults::removeInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>InstToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an instruction from the dependence analysis, updating the dependence of instructions that previously depended on it. </p>

<p class="definition">Definition at line <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l01541">1541</a> of file <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="MemoryDependenceAnalysis_8h_source.html#l00177">llvm::MemDepResult::getInst()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PhiValues_8cpp_source.html#l00123">llvm::PhiValues::invalidateValue()</a>, <a class="el" href="Type_8h_source.html#l00223">llvm::Type::isPointerTy()</a>, <a class="el" href="Instruction_8h_source.html#l00128">llvm::Instruction::isTerminator()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, and <a class="el" href="MemoryDependenceAnalysis_8cpp_source.html#l00099">RemoveFromReverseMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DeadStoreElimination_8cpp_source.html#l00099">deleteDeadInstruction()</a>, <a class="el" href="BasicBlockUtils_8cpp_source.html#l00139">llvm::FoldSingleEntryPHINodes()</a>, and <a class="el" href="GVN_8cpp_source.html#l00767">llvm::gvn::AvailableValue::MaterializeAdjustedValue()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/llvm/Analysis/<a class="el" href="MemoryDependenceAnalysis_8h_source.html">MemoryDependenceAnalysis.h</a></li>
<li>lib/Analysis/<a class="el" href="MemoryDependenceAnalysis_8cpp_source.html">MemoryDependenceAnalysis.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:56:51 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
