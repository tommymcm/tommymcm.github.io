<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_99567d9c0c7f3685f25b19ecc341a865.html">InstCombine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">InstCombineLoadStoreAlloca.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="InstCombineInternal_8h_source.html">InstCombineInternal.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/MapVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallString.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Statistic.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/Loads.h&quot;</code><br />
<code>#include &quot;llvm/Transforms/Utils/Local.h&quot;</code><br />
<code>#include &quot;llvm/IR/ConstantRange.h&quot;</code><br />
<code>#include &quot;llvm/IR/DataLayout.h&quot;</code><br />
<code>#include &quot;llvm/IR/DebugInfoMetadata.h&quot;</code><br />
<code>#include &quot;llvm/IR/IntrinsicInst.h&quot;</code><br />
<code>#include &quot;llvm/IR/LLVMContext.h&quot;</code><br />
<code>#include &quot;llvm/IR/MDBuilder.h&quot;</code><br />
<code>#include &quot;llvm/IR/PatternMatch.h&quot;</code><br />
<code>#include &quot;llvm/Transforms/Utils/BasicBlockUtils.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for InstCombineLoadStoreAlloca.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="InstCombineLoadStoreAlloca_8cpp__incl.png" border="0" usemap="#alib_2Transforms_2InstCombine_2InstCombineLoadStoreAlloca_8cpp" alt=""/></div>
<map name="alib_2Transforms_2InstCombine_2InstCombineLoadStoreAlloca_8cpp" id="alib_2Transforms_2InstCombine_2InstCombineLoadStoreAlloca_8cpp">
<area shape="rect" title=" " alt="" coords="5337,5,5577,45"/>
<area shape="rect" href="InstCombineInternal_8h.html" title="This file provides internal interfaces used to implement the InstCombine." alt="" coords="2559,101,2725,126"/>
<area shape="rect" title=" " alt="" coords="4578,189,4738,214"/>
<area shape="rect" title=" " alt="" coords="4762,189,4933,214"/>
<area shape="rect" title=" " alt="" coords="4957,181,5119,221"/>
<area shape="rect" title=" " alt="" coords="4901,101,5068,126"/>
<area shape="rect" title=" " alt="" coords="5093,101,5266,126"/>
<area shape="rect" title=" " alt="" coords="5291,101,5441,126"/>
<area shape="rect" title=" " alt="" coords="5465,101,5629,126"/>
<area shape="rect" title=" " alt="" coords="5653,101,5836,126"/>
<area shape="rect" title=" " alt="" coords="5860,101,6019,126"/>
<area shape="rect" title=" " alt="" coords="6043,101,6257,126"/>
<area shape="rect" title=" " alt="" coords="6281,101,6451,126"/>
<area shape="rect" title=" " alt="" coords="6475,101,6625,126"/>
<area shape="rect" title=" " alt="" coords="6649,93,6811,133"/>
<area shape="rect" title=" " alt="" coords="2791,189,2946,214"/>
<area shape="rect" title=" " alt="" coords="2970,189,3183,214"/>
<area shape="rect" title=" " alt="" coords="3208,181,3391,221"/>
<area shape="rect" title=" " alt="" coords="3415,189,3621,214"/>
<area shape="rect" title=" " alt="" coords="3645,189,3861,214"/>
<area shape="rect" title=" " alt="" coords="3885,189,4033,214"/>
<area shape="rect" title=" " alt="" coords="4058,189,4213,214"/>
<area shape="rect" title=" " alt="" coords="4237,189,4380,214"/>
<area shape="rect" title=" " alt="" coords="4405,189,4554,214"/>
<area shape="rect" title=" " alt="" coords="5,189,177,214"/>
<area shape="rect" title=" " alt="" coords="201,189,344,214"/>
<area shape="rect" title=" " alt="" coords="369,189,518,214"/>
<area shape="rect" title=" " alt="" coords="543,189,693,214"/>
<area shape="rect" title=" " alt="" coords="717,189,871,214"/>
<area shape="rect" title=" " alt="" coords="895,189,1037,214"/>
<area shape="rect" title=" " alt="" coords="1062,189,1171,214"/>
<area shape="rect" title=" " alt="" coords="1195,189,1315,214"/>
<area shape="rect" title=" " alt="" coords="1339,189,1510,214"/>
<area shape="rect" title=" " alt="" coords="1534,189,1713,214"/>
<area shape="rect" title=" " alt="" coords="1737,189,1899,214"/>
<area shape="rect" title=" " alt="" coords="1924,189,2115,214"/>
<area shape="rect" title=" " alt="" coords="2139,189,2345,214"/>
<area shape="rect" title=" " alt="" coords="2370,181,2583,221"/>
<area shape="rect" title=" " alt="" coords="2607,189,2677,214"/>
<area shape="rect" title=" " alt="" coords="2701,189,2767,214"/>
</map>
</div>
</div>
<p><a href="InstCombineLoadStoreAlloca_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;instcombine&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af924769343f5f9f9cfe1949795625208"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#af924769343f5f9f9cfe1949795625208">STATISTIC</a> (NumDeadStore, &quot;Number of dead stores eliminated&quot;)</td></tr>
<tr class="separator:af924769343f5f9f9cfe1949795625208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df6e182827b64d74ef5134005896ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a06df6e182827b64d74ef5134005896ac">STATISTIC</a> (NumGlobalCopies, &quot;Number of allocas copied from constant global&quot;)</td></tr>
<tr class="separator:a06df6e182827b64d74ef5134005896ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6752ff1d6270eefda9482e7694527c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a4d6752ff1d6270eefda9482e7694527c">pointsToConstantGlobal</a> (Value *V)</td></tr>
<tr class="memdesc:a4d6752ff1d6270eefda9482e7694527c"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointsToConstantGlobal - Return true if V (possibly indirectly) points to some part of a constant global variable.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a4d6752ff1d6270eefda9482e7694527c">More...</a><br /></td></tr>
<tr class="separator:a4d6752ff1d6270eefda9482e7694527c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3395c705cfba0619ab922fe3f6c316e8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a3395c705cfba0619ab922fe3f6c316e8">isOnlyCopiedFromConstantGlobal</a> (Value *V, MemTransferInst *&amp;TheCopy, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Instruction * &gt; &amp;ToDelete)</td></tr>
<tr class="memdesc:a3395c705cfba0619ab922fe3f6c316e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">isOnlyCopiedFromConstantGlobal - Recursively walk the uses of a (derived) pointer to an alloca.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a3395c705cfba0619ab922fe3f6c316e8">More...</a><br /></td></tr>
<tr class="separator:a3395c705cfba0619ab922fe3f6c316e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a112a584e0481cc0b7d1921b076d647"><td class="memItemLeft" align="right" valign="top">static MemTransferInst *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a3a112a584e0481cc0b7d1921b076d647">isOnlyCopiedFromConstantGlobal</a> (AllocaInst *AI, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Instruction * &gt; &amp;ToDelete)</td></tr>
<tr class="memdesc:a3a112a584e0481cc0b7d1921b076d647"><td class="mdescLeft">&#160;</td><td class="mdescRight">isOnlyCopiedFromConstantGlobal - Return true if the specified alloca is only modified by a copy from a constant global.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a3a112a584e0481cc0b7d1921b076d647">More...</a><br /></td></tr>
<tr class="separator:a3a112a584e0481cc0b7d1921b076d647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9981d75cde69ea5ca9706536fa4bbab5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a9981d75cde69ea5ca9706536fa4bbab5">isDereferenceableForAllocaSize</a> (const Value *V, const AllocaInst *AI, const DataLayout &amp;DL)</td></tr>
<tr class="memdesc:a9981d75cde69ea5ca9706536fa4bbab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if V is dereferenceable for size of alloca.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a9981d75cde69ea5ca9706536fa4bbab5">More...</a><br /></td></tr>
<tr class="separator:a9981d75cde69ea5ca9706536fa4bbab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79722962e1aaeaccb46a144a367c993e"><td class="memItemLeft" align="right" valign="top">static Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a79722962e1aaeaccb46a144a367c993e">simplifyAllocaArraySize</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, AllocaInst &amp;AI)</td></tr>
<tr class="separator:a79722962e1aaeaccb46a144a367c993e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8120208e16158e30ea3d285a1fa83f52"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a8120208e16158e30ea3d285a1fa83f52">isSupportedAtomicType</a> (Type *Ty)</td></tr>
<tr class="separator:a8120208e16158e30ea3d285a1fa83f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a3a9656ff7215276df5969d2d839bc"><td class="memItemLeft" align="right" valign="top">static LoadInst *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a06a3a9656ff7215276df5969d2d839bc">combineLoadToNewType</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, LoadInst &amp;LI, Type *NewTy, const Twine &amp;Suffix=&quot;&quot;)</td></tr>
<tr class="memdesc:a06a3a9656ff7215276df5969d2d839bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to combine a load to a new type.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a06a3a9656ff7215276df5969d2d839bc">More...</a><br /></td></tr>
<tr class="separator:a06a3a9656ff7215276df5969d2d839bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027e1850307eba172debbae55faf6955"><td class="memItemLeft" align="right" valign="top">static StoreInst *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a027e1850307eba172debbae55faf6955">combineStoreToNewValue</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, StoreInst &amp;SI, Value *V)</td></tr>
<tr class="memdesc:a027e1850307eba172debbae55faf6955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine a store to a new type.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a027e1850307eba172debbae55faf6955">More...</a><br /></td></tr>
<tr class="separator:a027e1850307eba172debbae55faf6955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36fdcae201465a089053a538586280f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#ab36fdcae201465a089053a538586280f">isMinMaxWithLoads</a> (Value *V)</td></tr>
<tr class="memdesc:ab36fdcae201465a089053a538586280f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if instruction represent minmax pattern like: select ((cmp load V1, load V2), V1, V2).  <a href="InstCombineLoadStoreAlloca_8cpp.html#ab36fdcae201465a089053a538586280f">More...</a><br /></td></tr>
<tr class="separator:ab36fdcae201465a089053a538586280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498b2af14b6ea749ba80165ff032aaf9"><td class="memItemLeft" align="right" valign="top">static Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a498b2af14b6ea749ba80165ff032aaf9">combineLoadToOperationType</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, LoadInst &amp;LI)</td></tr>
<tr class="memdesc:a498b2af14b6ea749ba80165ff032aaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine loads to match the type of their uses' value after looking through intervening bitcasts.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a498b2af14b6ea749ba80165ff032aaf9">More...</a><br /></td></tr>
<tr class="separator:a498b2af14b6ea749ba80165ff032aaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d54c1535d3574c70df2245ecf13071e"><td class="memItemLeft" align="right" valign="top">static Instruction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a9d54c1535d3574c70df2245ecf13071e">unpackLoadToAggregate</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, LoadInst &amp;LI)</td></tr>
<tr class="separator:a9d54c1535d3574c70df2245ecf13071e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af278f33f3e54a61566b7fdff3835e980"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#af278f33f3e54a61566b7fdff3835e980">isObjectSizeLessThanOrEq</a> (Value *V, uint64_t MaxSize, const DataLayout &amp;DL)</td></tr>
<tr class="separator:af278f33f3e54a61566b7fdff3835e980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d911f06844e0d4af5ff3e9d5ee8665"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a40d911f06844e0d4af5ff3e9d5ee8665">canReplaceGEPIdxWithZero</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, GetElementPtrInst *GEPI, Instruction *MemI, unsigned &amp;<a class="el" href="DeadArgumentElimination_8cpp.html#a39a491a969849f634027f20be70a5c57">Idx</a>)</td></tr>
<tr class="separator:a40d911f06844e0d4af5ff3e9d5ee8665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0d607d1b39131cfcd29388fdf92a1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b0d607d1b39131cfcd29388fdf92a1f"><td class="memTemplItemLeft" align="right" valign="top">static Instruction *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a2b0d607d1b39131cfcd29388fdf92a1f">replaceGEPIdxWithZero</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, Value *Ptr, T &amp;MemI)</td></tr>
<tr class="separator:a2b0d607d1b39131cfcd29388fdf92a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7ec4252834b9593345e41e55dbb53c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a2d7ec4252834b9593345e41e55dbb53c">canSimplifyNullStoreOrGEP</a> (StoreInst &amp;SI)</td></tr>
<tr class="separator:a2d7ec4252834b9593345e41e55dbb53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495e0c2946cb54155fefdf25d2cf8454"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a495e0c2946cb54155fefdf25d2cf8454">canSimplifyNullLoadOrGEP</a> (LoadInst &amp;LI, Value *Op)</td></tr>
<tr class="separator:a495e0c2946cb54155fefdf25d2cf8454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c481c7c79f9499e7e5bf69735a681d"><td class="memItemLeft" align="right" valign="top">static Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a82c481c7c79f9499e7e5bf69735a681d">likeBitCastFromVector</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, Value *V)</td></tr>
<tr class="memdesc:a82c481c7c79f9499e7e5bf69735a681d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for extractelement/insertvalue sequence that acts like a bitcast.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a82c481c7c79f9499e7e5bf69735a681d">More...</a><br /></td></tr>
<tr class="separator:a82c481c7c79f9499e7e5bf69735a681d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62939c73ba10f8a07bc139f53756f5a4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a62939c73ba10f8a07bc139f53756f5a4">combineStoreToValueType</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, StoreInst &amp;SI)</td></tr>
<tr class="memdesc:a62939c73ba10f8a07bc139f53756f5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine stores to match the type of value being stored.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a62939c73ba10f8a07bc139f53756f5a4">More...</a><br /></td></tr>
<tr class="separator:a62939c73ba10f8a07bc139f53756f5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91341a334b947da063324f445c796c4c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a91341a334b947da063324f445c796c4c">unpackStoreToAggregate</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, StoreInst &amp;SI)</td></tr>
<tr class="separator:a91341a334b947da063324f445c796c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3265ae31efc424def9bd2a560a8a4c5a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a3265ae31efc424def9bd2a560a8a4c5a">equivalentAddressValues</a> (Value *A, Value *B)</td></tr>
<tr class="memdesc:a3265ae31efc424def9bd2a560a8a4c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalentAddressValues - Test if A and B will obviously have the same value.  <a href="InstCombineLoadStoreAlloca_8cpp.html#a3265ae31efc424def9bd2a560a8a4c5a">More...</a><br /></td></tr>
<tr class="separator:a3265ae31efc424def9bd2a560a8a4c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08d9d86a35f29cae84f3e20eb7f1075"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#ae08d9d86a35f29cae84f3e20eb7f1075">removeBitcastsFromLoadStoreOnMinMax</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, StoreInst &amp;SI)</td></tr>
<tr class="memdesc:ae08d9d86a35f29cae84f3e20eb7f1075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts store (bitcast (load (bitcast (select ...)))) to store (load (select ...)), where select is minmax: select ((cmp load V1, load V2), V1, V2).  <a href="InstCombineLoadStoreAlloca_8cpp.html#ae08d9d86a35f29cae84f3e20eb7f1075">More...</a><br /></td></tr>
<tr class="separator:ae08d9d86a35f29cae84f3e20eb7f1075"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;instcombine&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00030">30</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a40d911f06844e0d4af5ff3e9d5ee8665" name="a40d911f06844e0d4af5ff3e9d5ee8665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d911f06844e0d4af5ff3e9d5ee8665">&#9670;&nbsp;</a></span>canReplaceGEPIdxWithZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool canReplaceGEPIdxWithZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GetElementPtrInst *&#160;</td>
          <td class="paramname"><em>GEPI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>MemI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>Idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00880">880</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineInternal_8h_source.html#l00662">llvm::InstCombiner::computeKnownBits()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00301">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00342">Idx</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00800">isObjectSizeLessThanOrEq()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00950">replaceGEPIdxWithZero()</a>.</p>

</div>
</div>
<a id="a495e0c2946cb54155fefdf25d2cf8454" name="a495e0c2946cb54155fefdf25d2cf8454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495e0c2946cb54155fefdf25d2cf8454">&#9670;&nbsp;</a></span>canSimplifyNullLoadOrGEP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool canSimplifyNullLoadOrGEP </td>
          <td>(</td>
          <td class="paramtype">LoadInst &amp;&#160;</td>
          <td class="paramname"><em>LI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>Op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00978">978</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00992">llvm::InstCombiner::visitLoadInst()</a>.</p>

</div>
</div>
<a id="a2d7ec4252834b9593345e41e55dbb53c" name="a2d7ec4252834b9593345e41e55dbb53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7ec4252834b9593345e41e55dbb53c">&#9670;&nbsp;</a></span>canSimplifyNullStoreOrGEP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool canSimplifyNullStoreOrGEP </td>
          <td>(</td>
          <td class="paramtype">StoreInst &amp;&#160;</td>
          <td class="paramname"><em>SI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00967">967</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01393">llvm::InstCombiner::visitStoreInst()</a>.</p>

</div>
</div>
<a id="a06a3a9656ff7215276df5969d2d839bc" name="a06a3a9656ff7215276df5969d2d839bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a3a9656ff7215276df5969d2d839bc">&#9670;&nbsp;</a></span>combineLoadToNewType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LoadInst * combineLoadToNewType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoadInst &amp;&#160;</td>
          <td class="paramname"><em>LI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>NewTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>Suffix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to combine a load to a new type. </p>
<p >This just does the work of combining a load to a new type. It handles metadata, etc., and returns the new instruction. The <code>NewTy</code> should be the loaded <em>value</em> type. This will convert it to a pointer, cast the operand to that pointer type, load it, etc.</p>
<p >Note that this will create all of the instructions with whatever insert point the <code>InstCombiner</code> currently is using. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00451">451</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00257">llvm::InstCombiner::Builder</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00301">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00438">isSupportedAtomicType()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00609">combineLoadToOperationType()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01356">removeBitcastsFromLoadStoreOnMinMax()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00677">unpackLoadToAggregate()</a>.</p>

</div>
</div>
<a id="a498b2af14b6ea749ba80165ff032aaf9" name="a498b2af14b6ea749ba80165ff032aaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498b2af14b6ea749ba80165ff032aaf9">&#9670;&nbsp;</a></span>combineLoadToOperationType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Instruction * combineLoadToOperationType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoadInst &amp;&#160;</td>
          <td class="paramname"><em>LI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine loads to match the type of their uses' value after looking through intervening bitcasts. </p>
<p >The core idea here is that if the result of a load is used in an operation, we should load the type most conducive to that operation. For example, when loading an integer and converting that immediately to a pointer, we should instead directly load a pointer.</p>
<p >However, this routine must never change the width of a load or the number of loads as that would introduce a semantic change. This combine is expected to be a semantic no-op which just allows loads to more closely model the types of their consuming operations.</p>
<p >Currently, we also refuse to change the precise type used for an atomic load or a volatile load. This is debatable, and might be reasonable to change later. However, it is risky in case some backend or other part of LLVM is relying on the exact type loaded to select appropriate atomic operations. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00609">609</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00257">llvm::InstCombiner::Builder</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00451">combineLoadToNewType()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00518">combineStoreToNewValue()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00644">llvm::InstCombiner::eraseInstFromFunction()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00301">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00572">isMinMaxWithLoads()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00438">isSupportedAtomicType()</a>, and <a class="el" href="InstCombineInternal_8h_source.html#l00119">llvm::peekThroughBitcast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00992">llvm::InstCombiner::visitLoadInst()</a>.</p>

</div>
</div>
<a id="a027e1850307eba172debbae55faf6955" name="a027e1850307eba172debbae55faf6955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027e1850307eba172debbae55faf6955">&#9670;&nbsp;</a></span>combineStoreToNewValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StoreInst * combineStoreToNewValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoreInst &amp;&#160;</td>
          <td class="paramname"><em>SI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine a store to a new type. </p>
<p >Returns the newly created store instruction. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00518">518</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00257">llvm::InstCombiner::Builder</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00438">isSupportedAtomicType()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00609">combineLoadToOperationType()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01180">combineStoreToValueType()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01356">removeBitcastsFromLoadStoreOnMinMax()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01212">unpackStoreToAggregate()</a>.</p>

</div>
</div>
<a id="a62939c73ba10f8a07bc139f53756f5a4" name="a62939c73ba10f8a07bc139f53756f5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62939c73ba10f8a07bc139f53756f5a4">&#9670;&nbsp;</a></span>combineStoreToValueType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool combineStoreToValueType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoreInst &amp;&#160;</td>
          <td class="paramname"><em>SI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine stores to match the type of value being stored. </p>
<p >The core idea here is that the memory does not have any intrinsic type and where we can we should match the type of a store to the type of value being stored.</p>
<p >However, this routine must never change the width of a store or the number of stores as that would introduce a semantic change. This combine is expected to be a semantic no-op which just allows stores to more closely model the types of their incoming values.</p>
<p >Currently, we also refuse to change the precise type used for an atomic or volatile store. This is debatable, and might be reasonable to change later. However, it is risky in case some backend or other part of LLVM is relying on the exact type stored to select appropriate atomic operations.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the store was successfully combined away. This indicates the caller must erase the store instruction. We have to let the caller erase the store instruction as otherwise there is no way to signal whether it was combined or not: IC.EraseInstFromFunction returns a null pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01180">1180</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00518">combineStoreToNewValue()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00438">isSupportedAtomicType()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01119">likeBitCastFromVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01393">llvm::InstCombiner::visitStoreInst()</a>.</p>

</div>
</div>
<a id="a3265ae31efc424def9bd2a560a8a4c5a" name="a3265ae31efc424def9bd2a560a8a4c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3265ae31efc424def9bd2a560a8a4c5a">&#9670;&nbsp;</a></span>equivalentAddressValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool equivalentAddressValues </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equivalentAddressValues - Test if A and B will obviously have the same value. </p>
<p >This includes recognizing that t0 and t1 will have the same value in code like this: t0 = getelementptr @a, 0, 3 store i32 0, i32* t0 t1 = getelementptr @a, 0, 3 t2 = load i32* t1 </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01332">1332</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01393">llvm::InstCombiner::visitStoreInst()</a>.</p>

</div>
</div>
<a id="a9981d75cde69ea5ca9706536fa4bbab5" name="a9981d75cde69ea5ca9706536fa4bbab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9981d75cde69ea5ca9706536fa4bbab5">&#9670;&nbsp;</a></span>isDereferenceableForAllocaSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isDereferenceableForAllocaSize </td>
          <td>(</td>
          <td class="paramtype">const Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AllocaInst *&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataLayout &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if V is dereferenceable for size of alloca. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00171">171</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="Loads_8cpp_source.html#l00053">isDereferenceableAndAlignedPointer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00341">llvm::InstCombiner::visitAllocaInst()</a>.</p>

</div>
</div>
<a id="ab36fdcae201465a089053a538586280f" name="ab36fdcae201465a089053a538586280f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36fdcae201465a089053a538586280f">&#9670;&nbsp;</a></span>isMinMaxWithLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isMinMaxWithLoads </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if instruction represent minmax pattern like: select ((cmp load V1, load V2), V1, V2). </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00572">572</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="InstCombineInternal_8h_source.html#l00119">llvm::peekThroughBitcast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00609">combineLoadToOperationType()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01356">removeBitcastsFromLoadStoreOnMinMax()</a>.</p>

</div>
</div>
<a id="af278f33f3e54a61566b7fdff3835e980" name="af278f33f3e54a61566b7fdff3835e980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af278f33f3e54a61566b7fdff3835e980">&#9670;&nbsp;</a></span>isObjectSizeLessThanOrEq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isObjectSizeLessThanOrEq </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>MaxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataLayout &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00800">800</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00880">canReplaceGEPIdxWithZero()</a>.</p>

</div>
</div>
<a id="a3a112a584e0481cc0b7d1921b076d647" name="a3a112a584e0481cc0b7d1921b076d647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a112a584e0481cc0b7d1921b076d647">&#9670;&nbsp;</a></span>isOnlyCopiedFromConstantGlobal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemTransferInst * isOnlyCopiedFromConstantGlobal </td>
          <td>(</td>
          <td class="paramtype">AllocaInst *&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Instruction * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ToDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isOnlyCopiedFromConstantGlobal - Return true if the specified alloca is only modified by a copy from a constant global. </p>
<p >If we can prove this, we can replace any uses of the alloca with uses of the global directly. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00162">162</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00059">isOnlyCopiedFromConstantGlobal()</a>.</p>

</div>
</div>
<a id="a3395c705cfba0619ab922fe3f6c316e8" name="a3395c705cfba0619ab922fe3f6c316e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3395c705cfba0619ab922fe3f6c316e8">&#9670;&nbsp;</a></span>isOnlyCopiedFromConstantGlobal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isOnlyCopiedFromConstantGlobal </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemTransferInst *&amp;&#160;</td>
          <td class="paramname"><em>TheCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Instruction * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ToDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isOnlyCopiedFromConstantGlobal - Recursively walk the uses of a (derived) pointer to an alloca. </p>
<p >Ignore any reads of the pointer, return false if we see any stores or other unknown uses. If we see pointer arithmetic, keep track of whether it moves the pointer (with IsOffset) but otherwise traverse the uses. If we see a memcpy/memmove that targets an unoffseted pointer to the alloca, and if the source pointer is a pointer to a constant global, we can optimize this. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00059">59</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00038">pointsToConstantGlobal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00162">isOnlyCopiedFromConstantGlobal()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00341">llvm::InstCombiner::visitAllocaInst()</a>.</p>

</div>
</div>
<a id="a8120208e16158e30ea3d285a1fa83f52" name="a8120208e16158e30ea3d285a1fa83f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8120208e16158e30ea3d285a1fa83f52">&#9670;&nbsp;</a></span>isSupportedAtomicType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isSupportedAtomicType </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>Ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00438">438</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00451">combineLoadToNewType()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00609">combineLoadToOperationType()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00518">combineStoreToNewValue()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01180">combineStoreToValueType()</a>.</p>

</div>
</div>
<a id="a82c481c7c79f9499e7e5bf69735a681d" name="a82c481c7c79f9499e7e5bf69735a681d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c481c7c79f9499e7e5bf69735a681d">&#9670;&nbsp;</a></span>likeBitCastFromVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value * likeBitCastFromVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look for extractelement/insertvalue sequence that acts like a bitcast. </p>
<dl class="section return"><dt>Returns</dt><dd>underlying value that was "cast", or nullptr otherwise.</dd></dl>
<p>For example, if we have: </p><pre class="fragment">%E0 = extractelement &lt;2 x double&gt; %U, i32 0
%V0 = insertvalue [2 x double] undef, double %E0, 0
%E1 = extractelement &lt;2 x double&gt; %U, i32 1
%V1 = insertvalue [2 x double] %V0, double %E1, 1
</pre><p> and the layout of a &lt;2 x double&gt; is isomorphic to a [2 x double], then V1 can be safely approximated by a conceptual "bitcast" of U. Note that U may contain non-undef values where V1 has undef. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01119">1119</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineInternal_8h_source.html#l00301">llvm::InstCombiner::getDataLayout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01180">combineStoreToValueType()</a>.</p>

</div>
</div>
<a id="a4d6752ff1d6270eefda9482e7694527c" name="a4d6752ff1d6270eefda9482e7694527c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6752ff1d6270eefda9482e7694527c">&#9670;&nbsp;</a></span>pointsToConstantGlobal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool pointsToConstantGlobal </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointsToConstantGlobal - Return true if V (possibly indirectly) points to some part of a constant global variable. </p>
<p >This intentionally only accepts constant expressions because we can't rewrite arbitrary instructions. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00038">38</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00038">pointsToConstantGlobal()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00059">isOnlyCopiedFromConstantGlobal()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00038">pointsToConstantGlobal()</a>.</p>

</div>
</div>
<a id="ae08d9d86a35f29cae84f3e20eb7f1075" name="ae08d9d86a35f29cae84f3e20eb7f1075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08d9d86a35f29cae84f3e20eb7f1075">&#9670;&nbsp;</a></span>removeBitcastsFromLoadStoreOnMinMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool removeBitcastsFromLoadStoreOnMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoreInst &amp;&#160;</td>
          <td class="paramname"><em>SI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts store (bitcast (load (bitcast (select ...)))) to store (load (select ...)), where select is minmax: select ((cmp load V1, load V2), V1, V2). </p>

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01356">1356</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineInternal_8h_source.html#l00257">llvm::InstCombiner::Builder</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00451">combineLoadToNewType()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00518">combineStoreToNewValue()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00644">llvm::InstCombiner::eraseInstFromFunction()</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00572">isMinMaxWithLoads()</a>, and <a class="el" href="InstCombineInternal_8h_source.html#l00600">llvm::InstCombiner::replaceInstUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01393">llvm::InstCombiner::visitStoreInst()</a>.</p>

</div>
</div>
<a id="a2b0d607d1b39131cfcd29388fdf92a1f" name="a2b0d607d1b39131cfcd29388fdf92a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0d607d1b39131cfcd29388fdf92a1f">&#9670;&nbsp;</a></span>replaceGEPIdxWithZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Instruction * replaceGEPIdxWithZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>MemI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00950">950</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00880">canReplaceGEPIdxWithZero()</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00342">Idx</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00992">llvm::InstCombiner::visitLoadInst()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01393">llvm::InstCombiner::visitStoreInst()</a>.</p>

</div>
</div>
<a id="a79722962e1aaeaccb46a144a367c993e" name="a79722962e1aaeaccb46a144a367c993e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79722962e1aaeaccb46a144a367c993e">&#9670;&nbsp;</a></span>simplifyAllocaArraySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Instruction * simplifyAllocaArraySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocaInst &amp;&#160;</td>
          <td class="paramname"><em>AI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00182">182</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineInternal_8h_source.html#l00257">llvm::InstCombiner::Builder</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00301">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00342">Idx</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00579">llvm::InstCombiner::InsertNewInstBefore()</a>, and <a class="el" href="InstCombineInternal_8h_source.html#l00600">llvm::InstCombiner::replaceInstUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00341">llvm::InstCombiner::visitAllocaInst()</a>.</p>

</div>
</div>
<a id="af924769343f5f9f9cfe1949795625208" name="af924769343f5f9f9cfe1949795625208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af924769343f5f9f9cfe1949795625208">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumDeadStore&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of dead stores eliminated&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06df6e182827b64d74ef5134005896ac" name="a06df6e182827b64d74ef5134005896ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df6e182827b64d74ef5134005896ac">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumGlobalCopies&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of allocas copied from constant global&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d54c1535d3574c70df2245ecf13071e" name="a9d54c1535d3574c70df2245ecf13071e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d54c1535d3574c70df2245ecf13071e">&#9670;&nbsp;</a></span>unpackLoadToAggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Instruction * unpackLoadToAggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoadInst &amp;&#160;</td>
          <td class="paramname"><em>LI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00677">677</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00257">llvm::InstCombiner::Builder</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00451">combineLoadToNewType()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00301">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00728">llvm::InstCombiner::MaxArraySizeForCombine</a>, and <a class="el" href="InstCombineInternal_8h_source.html#l00600">llvm::InstCombiner::replaceInstUsesWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00992">llvm::InstCombiner::visitLoadInst()</a>.</p>

</div>
</div>
<a id="a91341a334b947da063324f445c796c4c" name="a91341a334b947da063324f445c796c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91341a334b947da063324f445c796c4c">&#9670;&nbsp;</a></span>unpackStoreToAggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool unpackStoreToAggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoreInst &amp;&#160;</td>
          <td class="paramname"><em>SI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01212">1212</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineInternal_8h_source.html#l00257">llvm::InstCombiner::Builder</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00518">combineStoreToNewValue()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00301">llvm::InstCombiner::getDataLayout()</a>, and <a class="el" href="InstCombineInternal_8h_source.html#l00728">llvm::InstCombiner::MaxArraySizeForCombine</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l01393">llvm::InstCombiner::visitStoreInst()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:44:44 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
