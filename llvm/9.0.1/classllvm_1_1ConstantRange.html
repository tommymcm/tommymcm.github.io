<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::ConstantRange Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classllvm_1_1ConstantRange-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">llvm::ConstantRange Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class represents a range of values.  
 <a href="classllvm_1_1ConstantRange.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="ConstantRange_8h_source.html">llvm/IR/ConstantRange.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0e6f2069000829208cbac185a07d8082"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082">PreferredRangeType</a> { <a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082a25a373cd66e09df5cb7b8cf3f443ea2b">Smallest</a>
, <a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082ade1662f5186fd8852b4dcce8eb6563bc">Unsigned</a>
, <a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082a8260f3d302e2463fd93753dfd0de6ec1">Signed</a>
 }</td></tr>
<tr class="memdesc:a0e6f2069000829208cbac185a07d8082"><td class="mdescLeft">&#160;</td><td class="mdescRight">If represented precisely, the result of some range operations may consist of multiple disjoint ranges.  <a href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082">More...</a><br /></td></tr>
<tr class="separator:a0e6f2069000829208cbac185a07d8082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a96896a96f880fbd295aec85a81a87"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">OverflowResult</a> { <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ac8cc76d76703c81c16e939be370683c1">AlwaysOverflowsLow</a>
, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a9ac50ff0c308dad407db9f09e418363e">AlwaysOverflowsHigh</a>
, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ad4d9862eafa015a05101d9f662bb153a">MayOverflow</a>
, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a56624a95592b438e05ab500a6a200a03">NeverOverflows</a>
 }</td></tr>
<tr class="memdesc:ac5a96896a96f880fbd295aec85a81a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents whether an operation on the given constant range is known to always or never overflow.  <a href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">More...</a><br /></td></tr>
<tr class="separator:ac5a96896a96f880fbd295aec85a81a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8cbe37c4ba99ff3bc99338fcc618c618"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a8cbe37c4ba99ff3bc99338fcc618c618">ConstantRange</a> (<a class="el" href="classuint32__t.html">uint32_t</a> BitWidth, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ConstantRange.html#a4f6242fab5145c424cee29230fefe746">isFullSet</a>)</td></tr>
<tr class="memdesc:a8cbe37c4ba99ff3bc99338fcc618c618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a full or empty set for the specified bit width.  <a href="classllvm_1_1ConstantRange.html#a8cbe37c4ba99ff3bc99338fcc618c618">More...</a><br /></td></tr>
<tr class="separator:a8cbe37c4ba99ff3bc99338fcc618c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8863b38c3cf398d6e49eb2ddf4d794a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a8863b38c3cf398d6e49eb2ddf4d794a0">ConstantRange</a> (APInt <a class="el" href="classllvm_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:a8863b38c3cf398d6e49eb2ddf4d794a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a range to hold the single specified value.  <a href="classllvm_1_1ConstantRange.html#a8863b38c3cf398d6e49eb2ddf4d794a0">More...</a><br /></td></tr>
<tr class="separator:a8863b38c3cf398d6e49eb2ddf4d794a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4542296a6b1d3954afa57fd256948"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a61d4542296a6b1d3954afa57fd256948">ConstantRange</a> (APInt Lower, APInt Upper)</td></tr>
<tr class="memdesc:a61d4542296a6b1d3954afa57fd256948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a range of values explicitly.  <a href="classllvm_1_1ConstantRange.html#a61d4542296a6b1d3954afa57fd256948">More...</a><br /></td></tr>
<tr class="separator:a61d4542296a6b1d3954afa57fd256948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1616515fc811646b8cc5e6625e36b954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a1616515fc811646b8cc5e6625e36b954">getEquivalentICmp</a> (<a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a> &amp;Pred, APInt &amp;RHS) const</td></tr>
<tr class="memdesc:a1616515fc811646b8cc5e6625e36b954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up <code>Pred</code> and <code>RHS</code> such that ConstantRange::makeExactICmpRegion(Pred, RHS) == *this.  <a href="classllvm_1_1ConstantRange.html#a1616515fc811646b8cc5e6625e36b954">More...</a><br /></td></tr>
<tr class="separator:a1616515fc811646b8cc5e6625e36b954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f4339e49343721146062b10c144052"><td class="memItemLeft" align="right" valign="top">const APInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a23f4339e49343721146062b10c144052">getLower</a> () const</td></tr>
<tr class="memdesc:a23f4339e49343721146062b10c144052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower value for this range.  <a href="classllvm_1_1ConstantRange.html#a23f4339e49343721146062b10c144052">More...</a><br /></td></tr>
<tr class="separator:a23f4339e49343721146062b10c144052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1955c426e1ff66455b4bb6657ee995d"><td class="memItemLeft" align="right" valign="top">const APInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aa1955c426e1ff66455b4bb6657ee995d">getUpper</a> () const</td></tr>
<tr class="memdesc:aa1955c426e1ff66455b4bb6657ee995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper value for this range.  <a href="classllvm_1_1ConstantRange.html#aa1955c426e1ff66455b4bb6657ee995d">More...</a><br /></td></tr>
<tr class="separator:aa1955c426e1ff66455b4bb6657ee995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f81241f958a1f5917a3410942d3199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ad7f81241f958a1f5917a3410942d3199">getBitWidth</a> () const</td></tr>
<tr class="memdesc:ad7f81241f958a1f5917a3410942d3199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bit width of this <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>.  <a href="classllvm_1_1ConstantRange.html#ad7f81241f958a1f5917a3410942d3199">More...</a><br /></td></tr>
<tr class="separator:ad7f81241f958a1f5917a3410942d3199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6242fab5145c424cee29230fefe746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a4f6242fab5145c424cee29230fefe746">isFullSet</a> () const</td></tr>
<tr class="memdesc:a4f6242fab5145c424cee29230fefe746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set contains all of the elements possible for this data-type.  <a href="classllvm_1_1ConstantRange.html#a4f6242fab5145c424cee29230fefe746">More...</a><br /></td></tr>
<tr class="separator:a4f6242fab5145c424cee29230fefe746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd6d98b4a7ecc1dcdc571e4352fcc52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a5bd6d98b4a7ecc1dcdc571e4352fcc52">isEmptySet</a> () const</td></tr>
<tr class="memdesc:a5bd6d98b4a7ecc1dcdc571e4352fcc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set contains no members.  <a href="classllvm_1_1ConstantRange.html#a5bd6d98b4a7ecc1dcdc571e4352fcc52">More...</a><br /></td></tr>
<tr class="separator:a5bd6d98b4a7ecc1dcdc571e4352fcc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bca22a9253d0962fd07031c89b98e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a76bca22a9253d0962fd07031c89b98e7">isWrappedSet</a> () const</td></tr>
<tr class="memdesc:a76bca22a9253d0962fd07031c89b98e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set wraps around the unsigned domain.  <a href="classllvm_1_1ConstantRange.html#a76bca22a9253d0962fd07031c89b98e7">More...</a><br /></td></tr>
<tr class="separator:a76bca22a9253d0962fd07031c89b98e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a0c35225268e93dc3afd67e079f826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aa1a0c35225268e93dc3afd67e079f826">isUpperWrapped</a> () const</td></tr>
<tr class="memdesc:aa1a0c35225268e93dc3afd67e079f826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the exclusive upper bound wraps around the unsigned domain.  <a href="classllvm_1_1ConstantRange.html#aa1a0c35225268e93dc3afd67e079f826">More...</a><br /></td></tr>
<tr class="separator:aa1a0c35225268e93dc3afd67e079f826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4b4c9a335549fc329921f27ac67fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a66d4b4c9a335549fc329921f27ac67fc">isSignWrappedSet</a> () const</td></tr>
<tr class="memdesc:a66d4b4c9a335549fc329921f27ac67fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set wraps around the signed domain.  <a href="classllvm_1_1ConstantRange.html#a66d4b4c9a335549fc329921f27ac67fc">More...</a><br /></td></tr>
<tr class="separator:a66d4b4c9a335549fc329921f27ac67fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055ace4be97619b5dae7d6b3c4dbb4aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a055ace4be97619b5dae7d6b3c4dbb4aa">isUpperSignWrapped</a> () const</td></tr>
<tr class="memdesc:a055ace4be97619b5dae7d6b3c4dbb4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the (exclusive) upper bound wraps around the signed domain.  <a href="classllvm_1_1ConstantRange.html#a055ace4be97619b5dae7d6b3c4dbb4aa">More...</a><br /></td></tr>
<tr class="separator:a055ace4be97619b5dae7d6b3c4dbb4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca3a4d2b25c24b11179cbd01079b73c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aaca3a4d2b25c24b11179cbd01079b73c">contains</a> (const APInt &amp;Val) const</td></tr>
<tr class="memdesc:aaca3a4d2b25c24b11179cbd01079b73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified value is in the set.  <a href="classllvm_1_1ConstantRange.html#aaca3a4d2b25c24b11179cbd01079b73c">More...</a><br /></td></tr>
<tr class="separator:aaca3a4d2b25c24b11179cbd01079b73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbc1c19b39eab8b8473d97df0470855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a2dbc1c19b39eab8b8473d97df0470855">contains</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;CR) const</td></tr>
<tr class="memdesc:a2dbc1c19b39eab8b8473d97df0470855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the other range is a subset of this one.  <a href="classllvm_1_1ConstantRange.html#a2dbc1c19b39eab8b8473d97df0470855">More...</a><br /></td></tr>
<tr class="separator:a2dbc1c19b39eab8b8473d97df0470855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d705f2b7894d43bae1ff46eaf600181"><td class="memItemLeft" align="right" valign="top">const APInt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a1d705f2b7894d43bae1ff46eaf600181">getSingleElement</a> () const</td></tr>
<tr class="memdesc:a1d705f2b7894d43bae1ff46eaf600181"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this set contains a single element, return it, otherwise return null.  <a href="classllvm_1_1ConstantRange.html#a1d705f2b7894d43bae1ff46eaf600181">More...</a><br /></td></tr>
<tr class="separator:a1d705f2b7894d43bae1ff46eaf600181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21152e890e7ed361d9ec662af218c4c8"><td class="memItemLeft" align="right" valign="top">const APInt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a21152e890e7ed361d9ec662af218c4c8">getSingleMissingElement</a> () const</td></tr>
<tr class="memdesc:a21152e890e7ed361d9ec662af218c4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this set contains all but a single element, return it, otherwise return null.  <a href="classllvm_1_1ConstantRange.html#a21152e890e7ed361d9ec662af218c4c8">More...</a><br /></td></tr>
<tr class="separator:a21152e890e7ed361d9ec662af218c4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cf2c952ea87d701fe608fe4aaabfe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a91cf2c952ea87d701fe608fe4aaabfe4">isSingleElement</a> () const</td></tr>
<tr class="memdesc:a91cf2c952ea87d701fe608fe4aaabfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this set contains exactly one member.  <a href="classllvm_1_1ConstantRange.html#a91cf2c952ea87d701fe608fe4aaabfe4">More...</a><br /></td></tr>
<tr class="separator:a91cf2c952ea87d701fe608fe4aaabfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af656a14964b9cf9e049c1064b5f30c2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#af656a14964b9cf9e049c1064b5f30c2b">isSizeStrictlySmallerThan</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;CR) const</td></tr>
<tr class="memdesc:af656a14964b9cf9e049c1064b5f30c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare set size of this range with the range CR.  <a href="classllvm_1_1ConstantRange.html#af656a14964b9cf9e049c1064b5f30c2b">More...</a><br /></td></tr>
<tr class="separator:af656a14964b9cf9e049c1064b5f30c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688f2c4ca99eb7f935cab42c4f6398e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a688f2c4ca99eb7f935cab42c4f6398e7">isSizeLargerThan</a> (uint64_t MaxSize) const</td></tr>
<tr class="memdesc:a688f2c4ca99eb7f935cab42c4f6398e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare set size of this range with <a class="el" href="classllvm_1_1Value.html" title="LLVM Value Representation.">Value</a>.  <a href="classllvm_1_1ConstantRange.html#a688f2c4ca99eb7f935cab42c4f6398e7">More...</a><br /></td></tr>
<tr class="separator:a688f2c4ca99eb7f935cab42c4f6398e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256a302a20f8f9c2c02c9ca2d41ea78e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a256a302a20f8f9c2c02c9ca2d41ea78e">isAllNegative</a> () const</td></tr>
<tr class="memdesc:a256a302a20f8f9c2c02c9ca2d41ea78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all values in this range are negative.  <a href="classllvm_1_1ConstantRange.html#a256a302a20f8f9c2c02c9ca2d41ea78e">More...</a><br /></td></tr>
<tr class="separator:a256a302a20f8f9c2c02c9ca2d41ea78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a9706be916441a29cd5b93b64f033b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a99a9706be916441a29cd5b93b64f033b">isAllNonNegative</a> () const</td></tr>
<tr class="memdesc:a99a9706be916441a29cd5b93b64f033b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all values in this range are non-negative.  <a href="classllvm_1_1ConstantRange.html#a99a9706be916441a29cd5b93b64f033b">More...</a><br /></td></tr>
<tr class="separator:a99a9706be916441a29cd5b93b64f033b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f67c2ed8b2799c64ec64ca31d75c60"><td class="memItemLeft" align="right" valign="top">APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ab7f67c2ed8b2799c64ec64ca31d75c60">getUnsignedMax</a> () const</td></tr>
<tr class="memdesc:ab7f67c2ed8b2799c64ec64ca31d75c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest unsigned value contained in the <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>.  <a href="classllvm_1_1ConstantRange.html#ab7f67c2ed8b2799c64ec64ca31d75c60">More...</a><br /></td></tr>
<tr class="separator:ab7f67c2ed8b2799c64ec64ca31d75c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d69e164b5fb0f73a15a07119c4302f7"><td class="memItemLeft" align="right" valign="top">APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a4d69e164b5fb0f73a15a07119c4302f7">getUnsignedMin</a> () const</td></tr>
<tr class="memdesc:a4d69e164b5fb0f73a15a07119c4302f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest unsigned value contained in the <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>.  <a href="classllvm_1_1ConstantRange.html#a4d69e164b5fb0f73a15a07119c4302f7">More...</a><br /></td></tr>
<tr class="separator:a4d69e164b5fb0f73a15a07119c4302f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45b1557ea43684a07058cb74396c435"><td class="memItemLeft" align="right" valign="top">APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ac45b1557ea43684a07058cb74396c435">getSignedMax</a> () const</td></tr>
<tr class="memdesc:ac45b1557ea43684a07058cb74396c435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest signed value contained in the <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>.  <a href="classllvm_1_1ConstantRange.html#ac45b1557ea43684a07058cb74396c435">More...</a><br /></td></tr>
<tr class="separator:ac45b1557ea43684a07058cb74396c435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c03477d3ea04e382431f02a0f21aa41"><td class="memItemLeft" align="right" valign="top">APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a6c03477d3ea04e382431f02a0f21aa41">getSignedMin</a> () const</td></tr>
<tr class="memdesc:a6c03477d3ea04e382431f02a0f21aa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest signed value contained in the <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>.  <a href="classllvm_1_1ConstantRange.html#a6c03477d3ea04e382431f02a0f21aa41">More...</a><br /></td></tr>
<tr class="separator:a6c03477d3ea04e382431f02a0f21aa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8748bc223c6110faf90246950c579112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a8748bc223c6110faf90246950c579112">operator==</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;CR) const</td></tr>
<tr class="memdesc:a8748bc223c6110faf90246950c579112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this range is equal to another range.  <a href="classllvm_1_1ConstantRange.html#a8748bc223c6110faf90246950c579112">More...</a><br /></td></tr>
<tr class="separator:a8748bc223c6110faf90246950c579112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f0de2ee6d1ca4bb53bba22b237dee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ac9f0de2ee6d1ca4bb53bba22b237dee9">operator!=</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;CR) const</td></tr>
<tr class="separator:ac9f0de2ee6d1ca4bb53bba22b237dee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d29074c7a610816d4f328b7cd9b783d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a1d29074c7a610816d4f328b7cd9b783d">subtract</a> (const APInt &amp;CI) const</td></tr>
<tr class="memdesc:a1d29074c7a610816d4f328b7cd9b783d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the specified constant from the endpoints of this constant range.  <a href="classllvm_1_1ConstantRange.html#a1d29074c7a610816d4f328b7cd9b783d">More...</a><br /></td></tr>
<tr class="separator:a1d29074c7a610816d4f328b7cd9b783d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4790febf2bf7aa44f5283a74ddf744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a4f4790febf2bf7aa44f5283a74ddf744">difference</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;CR) const</td></tr>
<tr class="memdesc:a4f4790febf2bf7aa44f5283a74ddf744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the specified range from this range (aka relative complement of the sets).  <a href="classllvm_1_1ConstantRange.html#a4f4790febf2bf7aa44f5283a74ddf744">More...</a><br /></td></tr>
<tr class="separator:a4f4790febf2bf7aa44f5283a74ddf744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac098fe4f07549fb029fbf950dbe78fd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ac098fe4f07549fb029fbf950dbe78fd3">intersectWith</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;CR, <a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082">PreferredRangeType</a> <a class="el" href="classllvm_1_1Type.html">Type</a>=<a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082a25a373cd66e09df5cb7b8cf3f443ea2b">Smallest</a>) const</td></tr>
<tr class="memdesc:ac098fe4f07549fb029fbf950dbe78fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the range that results from the intersection of this range with another range.  <a href="classllvm_1_1ConstantRange.html#ac098fe4f07549fb029fbf950dbe78fd3">More...</a><br /></td></tr>
<tr class="separator:ac098fe4f07549fb029fbf950dbe78fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81521f99442a5c30f9061b8c6ce795e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aa81521f99442a5c30f9061b8c6ce795e">unionWith</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;CR, <a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082">PreferredRangeType</a> <a class="el" href="classllvm_1_1Type.html">Type</a>=<a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082a25a373cd66e09df5cb7b8cf3f443ea2b">Smallest</a>) const</td></tr>
<tr class="memdesc:aa81521f99442a5c30f9061b8c6ce795e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the range that results from the union of this range with another range.  <a href="classllvm_1_1ConstantRange.html#aa81521f99442a5c30f9061b8c6ce795e">More...</a><br /></td></tr>
<tr class="separator:aa81521f99442a5c30f9061b8c6ce795e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3a3d6e30e1512fd3b160cae4025f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a4c3a3d6e30e1512fd3b160cae4025f26">castOp</a> (<a class="el" href="classllvm_1_1Instruction.html#afa0b2fa29ba074f2b6ec9ac11163f2d9">Instruction::CastOps</a> CastOp, <a class="el" href="classuint32__t.html">uint32_t</a> BitWidth) const</td></tr>
<tr class="memdesc:a4c3a3d6e30e1512fd3b160cae4025f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from an application of the specified cast operator to this range.  <a href="classllvm_1_1ConstantRange.html#a4c3a3d6e30e1512fd3b160cae4025f26">More...</a><br /></td></tr>
<tr class="separator:a4c3a3d6e30e1512fd3b160cae4025f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ddf018d314a1d73f98e2fa4efbafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a636ddf018d314a1d73f98e2fa4efbafb">zeroExtend</a> (<a class="el" href="classuint32__t.html">uint32_t</a> BitWidth) const</td></tr>
<tr class="memdesc:a636ddf018d314a1d73f98e2fa4efbafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range in the specified integer type, which must be strictly larger than the current type.  <a href="classllvm_1_1ConstantRange.html#a636ddf018d314a1d73f98e2fa4efbafb">More...</a><br /></td></tr>
<tr class="separator:a636ddf018d314a1d73f98e2fa4efbafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8872e25eeddcc398a41e003e7c3f55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a9c8872e25eeddcc398a41e003e7c3f55">signExtend</a> (<a class="el" href="classuint32__t.html">uint32_t</a> BitWidth) const</td></tr>
<tr class="memdesc:a9c8872e25eeddcc398a41e003e7c3f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range in the specified integer type, which must be strictly larger than the current type.  <a href="classllvm_1_1ConstantRange.html#a9c8872e25eeddcc398a41e003e7c3f55">More...</a><br /></td></tr>
<tr class="separator:a9c8872e25eeddcc398a41e003e7c3f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc441c8fe8dfeea5471f11d2d823ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a2bc441c8fe8dfeea5471f11d2d823ec1">truncate</a> (<a class="el" href="classuint32__t.html">uint32_t</a> BitWidth) const</td></tr>
<tr class="memdesc:a2bc441c8fe8dfeea5471f11d2d823ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range in the specified integer type, which must be strictly smaller than the current type.  <a href="classllvm_1_1ConstantRange.html#a2bc441c8fe8dfeea5471f11d2d823ec1">More...</a><br /></td></tr>
<tr class="separator:a2bc441c8fe8dfeea5471f11d2d823ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ef50c1573b919a575fccb31cc523b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a05ef50c1573b919a575fccb31cc523b4">zextOrTrunc</a> (<a class="el" href="classuint32__t.html">uint32_t</a> BitWidth) const</td></tr>
<tr class="memdesc:a05ef50c1573b919a575fccb31cc523b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this range have the bit width given by <code>BitWidth</code>.  <a href="classllvm_1_1ConstantRange.html#a05ef50c1573b919a575fccb31cc523b4">More...</a><br /></td></tr>
<tr class="separator:a05ef50c1573b919a575fccb31cc523b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc1456c2e4f9d6d95aa0b089b3df535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aebc1456c2e4f9d6d95aa0b089b3df535">sextOrTrunc</a> (<a class="el" href="classuint32__t.html">uint32_t</a> BitWidth) const</td></tr>
<tr class="memdesc:aebc1456c2e4f9d6d95aa0b089b3df535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this range have the bit width given by <code>BitWidth</code>.  <a href="classllvm_1_1ConstantRange.html#aebc1456c2e4f9d6d95aa0b089b3df535">More...</a><br /></td></tr>
<tr class="separator:aebc1456c2e4f9d6d95aa0b089b3df535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23c0a0a029dcfece9ccade74a1e1536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ae23c0a0a029dcfece9ccade74a1e1536">binaryOp</a> (<a class="el" href="classllvm_1_1Instruction.html#ac26154a24f393f523c87cc5f8239f36c">Instruction::BinaryOps</a> BinOp, const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:ae23c0a0a029dcfece9ccade74a1e1536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from an application of the specified binary operator to an left hand side of this range and a right hand side of <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#ae23c0a0a029dcfece9ccade74a1e1536">More...</a><br /></td></tr>
<tr class="separator:ae23c0a0a029dcfece9ccade74a1e1536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b4ad79ea8ce56e62e0e0323d302eec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a04b4ad79ea8ce56e62e0e0323d302eec">add</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a04b4ad79ea8ce56e62e0e0323d302eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from an addition of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#a04b4ad79ea8ce56e62e0e0323d302eec">More...</a><br /></td></tr>
<tr class="separator:a04b4ad79ea8ce56e62e0e0323d302eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748a1f04465da9ee57a89403c56a6eca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a748a1f04465da9ee57a89403c56a6eca">addWithNoSignedWrap</a> (const APInt &amp;Other) const</td></tr>
<tr class="memdesc:a748a1f04465da9ee57a89403c56a6eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a known NSW addition of a value in this range and <code>Other</code> constant.  <a href="classllvm_1_1ConstantRange.html#a748a1f04465da9ee57a89403c56a6eca">More...</a><br /></td></tr>
<tr class="separator:a748a1f04465da9ee57a89403c56a6eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb57116b101c8d1263ff5ffdaccdcad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aeb57116b101c8d1263ff5ffdaccdcad0">sub</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:aeb57116b101c8d1263ff5ffdaccdcad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a subtraction of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#aeb57116b101c8d1263ff5ffdaccdcad0">More...</a><br /></td></tr>
<tr class="separator:aeb57116b101c8d1263ff5ffdaccdcad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0309899567234d74bf87a3899207bc15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a0309899567234d74bf87a3899207bc15">multiply</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a0309899567234d74bf87a3899207bc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a multiplication of a value in this range and a value in <code>Other</code>, treating both this and <code>Other</code> as unsigned ranges.  <a href="classllvm_1_1ConstantRange.html#a0309899567234d74bf87a3899207bc15">More...</a><br /></td></tr>
<tr class="separator:a0309899567234d74bf87a3899207bc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d25c37392410b0b31e43feae19489c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ae0d25c37392410b0b31e43feae19489c">smax</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:ae0d25c37392410b0b31e43feae19489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a signed maximum of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#ae0d25c37392410b0b31e43feae19489c">More...</a><br /></td></tr>
<tr class="separator:ae0d25c37392410b0b31e43feae19489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d98815d214fb4c80537873777e91fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a99d98815d214fb4c80537873777e91fb">umax</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a99d98815d214fb4c80537873777e91fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from an unsigned maximum of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#a99d98815d214fb4c80537873777e91fb">More...</a><br /></td></tr>
<tr class="separator:a99d98815d214fb4c80537873777e91fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14e808f6eb7296b587b22cc49919da7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ad14e808f6eb7296b587b22cc49919da7">smin</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:ad14e808f6eb7296b587b22cc49919da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a signed minimum of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#ad14e808f6eb7296b587b22cc49919da7">More...</a><br /></td></tr>
<tr class="separator:ad14e808f6eb7296b587b22cc49919da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cabbd29371bbe4737500f0bf60774fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a4cabbd29371bbe4737500f0bf60774fd">umin</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a4cabbd29371bbe4737500f0bf60774fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from an unsigned minimum of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#a4cabbd29371bbe4737500f0bf60774fd">More...</a><br /></td></tr>
<tr class="separator:a4cabbd29371bbe4737500f0bf60774fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41d307fed42f6776d36397336e81985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ad41d307fed42f6776d36397336e81985">udiv</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:ad41d307fed42f6776d36397336e81985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from an unsigned division of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#ad41d307fed42f6776d36397336e81985">More...</a><br /></td></tr>
<tr class="separator:ad41d307fed42f6776d36397336e81985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa160a2ac0c31b48c41da949e53cc21b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aa160a2ac0c31b48c41da949e53cc21b7">sdiv</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:aa160a2ac0c31b48c41da949e53cc21b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a signed division of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#aa160a2ac0c31b48c41da949e53cc21b7">More...</a><br /></td></tr>
<tr class="separator:aa160a2ac0c31b48c41da949e53cc21b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336e2050c47c9d72b2cb4b13726fbba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a336e2050c47c9d72b2cb4b13726fbba3">urem</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a336e2050c47c9d72b2cb4b13726fbba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from an unsigned remainder operation of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#a336e2050c47c9d72b2cb4b13726fbba3">More...</a><br /></td></tr>
<tr class="separator:a336e2050c47c9d72b2cb4b13726fbba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ae77be815f3771d7e0e1837204af01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a51ae77be815f3771d7e0e1837204af01">srem</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a51ae77be815f3771d7e0e1837204af01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a signed remainder operation of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#a51ae77be815f3771d7e0e1837204af01">More...</a><br /></td></tr>
<tr class="separator:a51ae77be815f3771d7e0e1837204af01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5f27f8d0ff473183fff55780e5796c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aac5f27f8d0ff473183fff55780e5796c">binaryAnd</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:aac5f27f8d0ff473183fff55780e5796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a binary-and of a value in this range by a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#aac5f27f8d0ff473183fff55780e5796c">More...</a><br /></td></tr>
<tr class="separator:aac5f27f8d0ff473183fff55780e5796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a906a72244158de8ae4a764e861d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ae3a906a72244158de8ae4a764e861d79">binaryOr</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:ae3a906a72244158de8ae4a764e861d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a binary-or of a value in this range by a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#ae3a906a72244158de8ae4a764e861d79">More...</a><br /></td></tr>
<tr class="separator:ae3a906a72244158de8ae4a764e861d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62222502f5be2dd8e300b48469aeab4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a62222502f5be2dd8e300b48469aeab4f">shl</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a62222502f5be2dd8e300b48469aeab4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a left shift of a value in this range by a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#a62222502f5be2dd8e300b48469aeab4f">More...</a><br /></td></tr>
<tr class="separator:a62222502f5be2dd8e300b48469aeab4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452f6ecfc69e273b9005e5bac75583a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a452f6ecfc69e273b9005e5bac75583a3">lshr</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a452f6ecfc69e273b9005e5bac75583a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a logical right shift of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#a452f6ecfc69e273b9005e5bac75583a3">More...</a><br /></td></tr>
<tr class="separator:a452f6ecfc69e273b9005e5bac75583a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcad8746eb26dcbb5831974e39a3d34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aabcad8746eb26dcbb5831974e39a3d34">ashr</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:aabcad8746eb26dcbb5831974e39a3d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range representing the possible values resulting from a arithmetic right shift of a value in this range and a value in <code>Other</code>.  <a href="classllvm_1_1ConstantRange.html#aabcad8746eb26dcbb5831974e39a3d34">More...</a><br /></td></tr>
<tr class="separator:aabcad8746eb26dcbb5831974e39a3d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81da9170db4b7b8f89c9d196c07a6efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a81da9170db4b7b8f89c9d196c07a6efb">uadd_sat</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a81da9170db4b7b8f89c9d196c07a6efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an unsigned saturating addition of two constant ranges.  <a href="classllvm_1_1ConstantRange.html#a81da9170db4b7b8f89c9d196c07a6efb">More...</a><br /></td></tr>
<tr class="separator:a81da9170db4b7b8f89c9d196c07a6efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54097522b509c08dd84e5ce59437c8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a54097522b509c08dd84e5ce59437c8b9">sadd_sat</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a54097522b509c08dd84e5ce59437c8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a signed saturating addition of two constant ranges.  <a href="classllvm_1_1ConstantRange.html#a54097522b509c08dd84e5ce59437c8b9">More...</a><br /></td></tr>
<tr class="separator:a54097522b509c08dd84e5ce59437c8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a13c7e552038eb1d567e1572d91c411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a7a13c7e552038eb1d567e1572d91c411">usub_sat</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a7a13c7e552038eb1d567e1572d91c411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an unsigned saturating subtraction of two constant ranges.  <a href="classllvm_1_1ConstantRange.html#a7a13c7e552038eb1d567e1572d91c411">More...</a><br /></td></tr>
<tr class="separator:a7a13c7e552038eb1d567e1572d91c411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993a75b630274a45cb0c20938962796f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a993a75b630274a45cb0c20938962796f">ssub_sat</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a993a75b630274a45cb0c20938962796f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a signed saturating subtraction of two constant ranges.  <a href="classllvm_1_1ConstantRange.html#a993a75b630274a45cb0c20938962796f">More...</a><br /></td></tr>
<tr class="separator:a993a75b630274a45cb0c20938962796f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa2f5e2c6c3122d2b484f9e50950e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aaaa2f5e2c6c3122d2b484f9e50950e18">inverse</a> () const</td></tr>
<tr class="memdesc:aaaa2f5e2c6c3122d2b484f9e50950e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new range that is the logical not of the current set.  <a href="classllvm_1_1ConstantRange.html#aaaa2f5e2c6c3122d2b484f9e50950e18">More...</a><br /></td></tr>
<tr class="separator:aaaa2f5e2c6c3122d2b484f9e50950e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab870636af87066c51e4b383d34a2649b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ab870636af87066c51e4b383d34a2649b">abs</a> () const</td></tr>
<tr class="memdesc:ab870636af87066c51e4b383d34a2649b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate absolute value range.  <a href="classllvm_1_1ConstantRange.html#ab870636af87066c51e4b383d34a2649b">More...</a><br /></td></tr>
<tr class="separator:ab870636af87066c51e4b383d34a2649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf71829dbcdadbd24d3c22814113ebf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a2bf71829dbcdadbd24d3c22814113ebf">unsignedAddMayOverflow</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a2bf71829dbcdadbd24d3c22814113ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether unsigned add of the two ranges always/never overflows.  <a href="classllvm_1_1ConstantRange.html#a2bf71829dbcdadbd24d3c22814113ebf">More...</a><br /></td></tr>
<tr class="separator:a2bf71829dbcdadbd24d3c22814113ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e4a3ec7de159965bcee94fae9df74b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ab1e4a3ec7de159965bcee94fae9df74b">signedAddMayOverflow</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:ab1e4a3ec7de159965bcee94fae9df74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether signed add of the two ranges always/never overflows.  <a href="classllvm_1_1ConstantRange.html#ab1e4a3ec7de159965bcee94fae9df74b">More...</a><br /></td></tr>
<tr class="separator:ab1e4a3ec7de159965bcee94fae9df74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a99adda34abba8c6988f8292a93815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a24a99adda34abba8c6988f8292a93815">unsignedSubMayOverflow</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a24a99adda34abba8c6988f8292a93815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether unsigned sub of the two ranges always/never overflows.  <a href="classllvm_1_1ConstantRange.html#a24a99adda34abba8c6988f8292a93815">More...</a><br /></td></tr>
<tr class="separator:a24a99adda34abba8c6988f8292a93815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae907195afbb8c9442691836e26ac0001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ae907195afbb8c9442691836e26ac0001">signedSubMayOverflow</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:ae907195afbb8c9442691836e26ac0001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether signed sub of the two ranges always/never overflows.  <a href="classllvm_1_1ConstantRange.html#ae907195afbb8c9442691836e26ac0001">More...</a><br /></td></tr>
<tr class="separator:ae907195afbb8c9442691836e26ac0001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccba85d5176205f41ad55236b7d8204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a8ccba85d5176205f41ad55236b7d8204">unsignedMulMayOverflow</a> (const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other) const</td></tr>
<tr class="memdesc:a8ccba85d5176205f41ad55236b7d8204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether unsigned mul of the two ranges always/never overflows.  <a href="classllvm_1_1ConstantRange.html#a8ccba85d5176205f41ad55236b7d8204">More...</a><br /></td></tr>
<tr class="separator:a8ccba85d5176205f41ad55236b7d8204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8831f85b65cbcc9cf42d70988845a9f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a8831f85b65cbcc9cf42d70988845a9f6">print</a> (<a class="el" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS) const</td></tr>
<tr class="memdesc:a8831f85b65cbcc9cf42d70988845a9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the bounds to a stream.  <a href="classllvm_1_1ConstantRange.html#a8831f85b65cbcc9cf42d70988845a9f6">More...</a><br /></td></tr>
<tr class="separator:a8831f85b65cbcc9cf42d70988845a9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e43abf85f6911f09023f40cf86cc5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a59e43abf85f6911f09023f40cf86cc5f">dump</a> () const</td></tr>
<tr class="memdesc:a59e43abf85f6911f09023f40cf86cc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing from a debugger easily.  <a href="classllvm_1_1ConstantRange.html#a59e43abf85f6911f09023f40cf86cc5f">More...</a><br /></td></tr>
<tr class="separator:a59e43abf85f6911f09023f40cf86cc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aff6f6c6a6df94af8be1bd5accff28a71"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aff6f6c6a6df94af8be1bd5accff28a71">getEmpty</a> (<a class="el" href="classuint32__t.html">uint32_t</a> BitWidth)</td></tr>
<tr class="memdesc:aff6f6c6a6df94af8be1bd5accff28a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create empty constant range with the given bit width.  <a href="classllvm_1_1ConstantRange.html#aff6f6c6a6df94af8be1bd5accff28a71">More...</a><br /></td></tr>
<tr class="separator:aff6f6c6a6df94af8be1bd5accff28a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bc7c6f540132189d07ad7f73bda1ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a20bc7c6f540132189d07ad7f73bda1ee">getFull</a> (<a class="el" href="classuint32__t.html">uint32_t</a> BitWidth)</td></tr>
<tr class="memdesc:a20bc7c6f540132189d07ad7f73bda1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create full constant range with the given bit width.  <a href="classllvm_1_1ConstantRange.html#a20bc7c6f540132189d07ad7f73bda1ee">More...</a><br /></td></tr>
<tr class="separator:a20bc7c6f540132189d07ad7f73bda1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8afecbb15ee69487d5339371f64a76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#acd8afecbb15ee69487d5339371f64a76">getNonEmpty</a> (APInt Lower, APInt Upper)</td></tr>
<tr class="memdesc:acd8afecbb15ee69487d5339371f64a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create non-empty constant range with the given bounds.  <a href="classllvm_1_1ConstantRange.html#acd8afecbb15ee69487d5339371f64a76">More...</a><br /></td></tr>
<tr class="separator:acd8afecbb15ee69487d5339371f64a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211874a1535ba321cab61942cde9398f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a211874a1535ba321cab61942cde9398f">fromKnownBits</a> (const <a class="el" href="structllvm_1_1KnownBits.html">KnownBits</a> &amp;Known, <a class="el" href="classbool.html">bool</a> IsSigned)</td></tr>
<tr class="memdesc:a211874a1535ba321cab61942cde9398f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a range based on a known bits constraint.  <a href="classllvm_1_1ConstantRange.html#a211874a1535ba321cab61942cde9398f">More...</a><br /></td></tr>
<tr class="separator:a211874a1535ba321cab61942cde9398f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0830ec6778859b4abb3e8bf0b9e0e38"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aa0830ec6778859b4abb3e8bf0b9e0e38">makeAllowedICmpRegion</a> (<a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a> Pred, const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other)</td></tr>
<tr class="memdesc:aa0830ec6778859b4abb3e8bf0b9e0e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the smallest range such that all values that may satisfy the given predicate with any value contained within Other is contained in the returned range.  <a href="classllvm_1_1ConstantRange.html#aa0830ec6778859b4abb3e8bf0b9e0e38">More...</a><br /></td></tr>
<tr class="separator:aa0830ec6778859b4abb3e8bf0b9e0e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbc74ae7d3a1a1423c26b9ce948f34c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#a6fbc74ae7d3a1a1423c26b9ce948f34c">makeSatisfyingICmpRegion</a> (<a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a> Pred, const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other)</td></tr>
<tr class="memdesc:a6fbc74ae7d3a1a1423c26b9ce948f34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the largest range such that all values in the returned range satisfy the given predicate with all values contained within Other.  <a href="classllvm_1_1ConstantRange.html#a6fbc74ae7d3a1a1423c26b9ce948f34c">More...</a><br /></td></tr>
<tr class="separator:a6fbc74ae7d3a1a1423c26b9ce948f34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89e9cec92a0b38d2f47a077bf12cc98"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aa89e9cec92a0b38d2f47a077bf12cc98">makeExactICmpRegion</a> (<a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a> Pred, const APInt &amp;Other)</td></tr>
<tr class="memdesc:aa89e9cec92a0b38d2f47a077bf12cc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the exact range such that all values in the returned range satisfy the given predicate with any value contained within Other.  <a href="classllvm_1_1ConstantRange.html#aa89e9cec92a0b38d2f47a077bf12cc98">More...</a><br /></td></tr>
<tr class="separator:aa89e9cec92a0b38d2f47a077bf12cc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace208c0bd1d845fe49f319be6a954764"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#ace208c0bd1d845fe49f319be6a954764">makeGuaranteedNoWrapRegion</a> (<a class="el" href="classllvm_1_1Instruction.html#ac26154a24f393f523c87cc5f8239f36c">Instruction::BinaryOps</a> BinOp, const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;Other, <a class="el" href="classunsigned.html">unsigned</a> NoWrapKind)</td></tr>
<tr class="memdesc:ace208c0bd1d845fe49f319be6a954764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the largest range containing all X such that "X BinOp Y" is guaranteed not to wrap (overflow) for <em>all</em> Y in Other.  <a href="classllvm_1_1ConstantRange.html#ace208c0bd1d845fe49f319be6a954764">More...</a><br /></td></tr>
<tr class="separator:ace208c0bd1d845fe49f319be6a954764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddb6f4f9ffcb9e893e5cb321b7a7f83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ConstantRange.html#aeddb6f4f9ffcb9e893e5cb321b7a7f83">makeExactNoWrapRegion</a> (<a class="el" href="classllvm_1_1Instruction.html#ac26154a24f393f523c87cc5f8239f36c">Instruction::BinaryOps</a> BinOp, const APInt &amp;Other, <a class="el" href="classunsigned.html">unsigned</a> NoWrapKind)</td></tr>
<tr class="memdesc:aeddb6f4f9ffcb9e893e5cb321b7a7f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the range that contains X if and only if "X BinOp Other" does not wrap.  <a href="classllvm_1_1ConstantRange.html#aeddb6f4f9ffcb9e893e5cb321b7a7f83">More...</a><br /></td></tr>
<tr class="separator:aeddb6f4f9ffcb9e893e5cb321b7a7f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This class represents a range of values. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00047">47</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac5a96896a96f880fbd295aec85a81a87" name="ac5a96896a96f880fbd295aec85a81a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a96896a96f880fbd295aec85a81a87">&#9670;&nbsp;</a></span>OverflowResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">llvm::ConstantRange::OverflowResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents whether an operation on the given constant range is known to always or never overflow. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac5a96896a96f880fbd295aec85a81a87ac8cc76d76703c81c16e939be370683c1" name="ac5a96896a96f880fbd295aec85a81a87ac8cc76d76703c81c16e939be370683c1"></a>AlwaysOverflowsLow&#160;</td><td class="fielddoc"><p >Always overflows in the direction of signed/unsigned min value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5a96896a96f880fbd295aec85a81a87a9ac50ff0c308dad407db9f09e418363e" name="ac5a96896a96f880fbd295aec85a81a87a9ac50ff0c308dad407db9f09e418363e"></a>AlwaysOverflowsHigh&#160;</td><td class="fielddoc"><p >Always overflows in the direction of signed/unsigned max value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5a96896a96f880fbd295aec85a81a87ad4d9862eafa015a05101d9f662bb153a" name="ac5a96896a96f880fbd295aec85a81a87ad4d9862eafa015a05101d9f662bb153a"></a>MayOverflow&#160;</td><td class="fielddoc"><p >May or may not overflow. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5a96896a96f880fbd295aec85a81a87a56624a95592b438e05ab500a6a200a03" name="ac5a96896a96f880fbd295aec85a81a87a56624a95592b438e05ab500a6a200a03"></a>NeverOverflows&#160;</td><td class="fielddoc"><p >Never overflows. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00426">426</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

</div>
</div>
<a id="a0e6f2069000829208cbac185a07d8082" name="a0e6f2069000829208cbac185a07d8082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6f2069000829208cbac185a07d8082">&#9670;&nbsp;</a></span>PreferredRangeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082">llvm::ConstantRange::PreferredRangeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If represented precisely, the result of some range operations may consist of multiple disjoint ranges. </p>
<p >As only a single range may be returned, any range covering these disjoint ranges constitutes a valid result, but some may be more useful than others depending on context. The preferred range type specifies whether a range that is non-wrapping in the unsigned or signed domain, or has the smallest size, is preferred. If a signedness is preferred but all ranges are non-wrapping or all wrapping, then the smallest set size is preferred. If there are multiple smallest sets, any one of them may be returned. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0e6f2069000829208cbac185a07d8082a25a373cd66e09df5cb7b8cf3f443ea2b" name="a0e6f2069000829208cbac185a07d8082a25a373cd66e09df5cb7b8cf3f443ea2b"></a>Smallest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0e6f2069000829208cbac185a07d8082ade1662f5186fd8852b4dcce8eb6563bc" name="a0e6f2069000829208cbac185a07d8082ade1662f5186fd8852b4dcce8eb6563bc"></a>Unsigned&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0e6f2069000829208cbac185a07d8082a8260f3d302e2463fd93753dfd0de6ec1" name="a0e6f2069000829208cbac185a07d8082a8260f3d302e2463fd93753dfd0de6ec1"></a>Signed&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00272">272</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8cbe37c4ba99ff3bc99338fcc618c618" name="a8cbe37c4ba99ff3bc99338fcc618c618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbe37c4ba99ff3bc99338fcc618c618">&#9670;&nbsp;</a></span>ConstantRange() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange::ConstantRange</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isFullSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a full or empty set for the specified bit width. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00042">42</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

</div>
</div>
<a id="a8863b38c3cf398d6e49eb2ddf4d794a0" name="a8863b38c3cf398d6e49eb2ddf4d794a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8863b38c3cf398d6e49eb2ddf4d794a0">&#9670;&nbsp;</a></span>ConstantRange() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange::ConstantRange</a> </td>
          <td>(</td>
          <td class="paramtype">APInt&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a range to hold the single specified value. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00046">46</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

</div>
</div>
<a id="a61d4542296a6b1d3954afa57fd256948" name="a61d4542296a6b1d3954afa57fd256948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d4542296a6b1d3954afa57fd256948">&#9670;&nbsp;</a></span>ConstantRange() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange::ConstantRange</a> </td>
          <td>(</td>
          <td class="paramtype">APInt&#160;</td>
          <td class="paramname"><em>Lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">APInt&#160;</td>
          <td class="paramname"><em>Upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a range of values explicitly. </p>
<p >This will assert out if Lower==Upper and Lower != Min or Max value for its type. It will also assert out if the two APInt's are not the same bit width. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00049">49</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab870636af87066c51e4b383d34a2649b" name="ab870636af87066c51e4b383d34a2649b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab870636af87066c51e4b383d34a2649b">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::abs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate absolute value range. </p>
<p >If the original range contains signed min, then the resulting range will also contain signed min. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01259">1259</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00299">isSignWrappedSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01065">srem()</a>.</p>

</div>
</div>
<a id="a04b4ad79ea8ce56e62e0e0323d302eec" name="a04b4ad79ea8ce56e62e0e0323d302eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b4ad79ea8ce56e62e0e0323d302eec">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from an addition of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00799">799</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00159">getLower()</a>, <a class="el" href="ConstantRange_8h_source.html#l00162">getUpper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>, and <a class="el" href="JumpThreading_8cpp_source.html#l00583">llvm::JumpThreadingPass::ComputeValueKnownInPredecessorsImpl()</a>.</p>

</div>
</div>
<a id="a748a1f04465da9ee57a89403c56a6eca" name="a748a1f04465da9ee57a89403c56a6eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748a1f04465da9ee57a89403c56a6eca">&#9670;&nbsp;</a></span>addWithNoSignedWrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::addWithNoSignedWrap </td>
          <td>(</td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a known NSW addition of a value in this range and <code>Other</code> constant. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00818">818</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00275">makeExactNoWrapRegion()</a>, and <a class="el" href="Operator_8h_source.html#l00070">llvm::OverflowingBinaryOperator::NoSignedWrap</a>.</p>

</div>
</div>
<a id="aabcad8746eb26dcbb5831974e39a3d34" name="aabcad8746eb26dcbb5831974e39a3d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcad8746eb26dcbb5831974e39a3d34">&#9670;&nbsp;</a></span>ashr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::ashr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a arithmetic right shift of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01165">1165</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="aac5f27f8d0ff473183fff55780e5796c" name="aac5f27f8d0ff473183fff55780e5796c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5f27f8d0ff473183fff55780e5796c">&#9670;&nbsp;</a></span>binaryAnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::binaryAnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a binary-and of a value in this range by a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01108">1108</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00936">umin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="ae23c0a0a029dcfece9ccade74a1e1536" name="ae23c0a0a029dcfece9ccade74a1e1536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23c0a0a029dcfece9ccade74a1e1536">&#9670;&nbsp;</a></span>binaryOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::binaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html#ac26154a24f393f523c87cc5f8239f36c">Instruction::BinaryOps</a>&#160;</td>
          <td class="paramname"><em>BinOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from an application of the specified binary operator to an left hand side of this range and a right hand side of <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00755">755</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00799">add()</a>, <a class="el" href="Instructions_8h_source.html#l00713">llvm::AtomicRMWInst::And</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01165">ashr()</a>, <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01108">binaryAnd()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01119">binaryOr()</a>, <a class="el" href="Instructions_8h_source.html#l00730">llvm::AtomicRMWInst::FAdd</a>, <a class="el" href="Instructions_8h_source.html#l00733">llvm::AtomicRMWInst::FSub</a>, <a class="el" href="Instruction_8h_source.html#l00130">llvm::Instruction::isBinaryOp()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01155">lshr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="Instructions_8h_source.html#l00717">llvm::AtomicRMWInst::Or</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00967">sdiv()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01130">shl()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01065">srem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00829">sub()</a>, <a class="el" href="Instructions_8h_source.html#l00711">llvm::AtomicRMWInst::Sub</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00947">udiv()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l01052">urem()</a>.</p>

</div>
</div>
<a id="ae3a906a72244158de8ae4a764e861d79" name="ae3a906a72244158de8ae4a764e861d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a906a72244158de8ae4a764e861d79">&#9670;&nbsp;</a></span>binaryOr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::binaryOr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a binary-or of a value in this range by a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01119">1119</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00914">umax()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="a4c3a3d6e30e1512fd3b160cae4025f26" name="a4c3a3d6e30e1512fd3b160cae4025f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3a3d6e30e1512fd3b160cae4025f26">&#9670;&nbsp;</a></span>castOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::castOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html#afa0b2fa29ba074f2b6ec9ac11163f2d9">Instruction::CastOps</a>&#160;</td>
          <td class="paramname"><em>CastOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from an application of the specified cast operator to this range. </p>
<p ><code>BitWidth</code> is the target bitwidth of the cast. For casts which don't change bitwidth, it must be the same as the source bitwidth. For casts which do change bitwidth, the bitwidth must be consistent with the requested cast and source bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00605">605</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ErrorHandling_8h_source.html#l00135">llvm_unreachable</a>, <a class="el" href="Operator_8h_source.html#l00547">llvm::PtrToIntOperator::PtrToInt</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00665">signExtend()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00648">zeroExtend()</a>.</p>

</div>
</div>
<a id="aaca3a4d2b25c24b11179cbd01079b73c" name="aaca3a4d2b25c24b11179cbd01079b73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca3a4d2b25c24b11179cbd01079b73c">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::contains </td>
          <td>(</td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified value is in the set. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00367">367</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00295">isUpperWrapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="JumpThreading_8cpp_source.html#l00583">llvm::JumpThreadingPass::ComputeValueKnownInPredecessorsImpl()</a>, <a class="el" href="Local_8cpp_source.html#l02531">llvm::copyRangeMetadata()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l10722">llvm::SCEVAddRecExpr::getNumIterationsInRange()</a>, <a class="el" href="LazyValueInfo_8cpp_source.html#l01720">getPredicateResult()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l05738">getRangeForAffineARHelper()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01940">llvm::ScalarEvolution::getSignExtendExpr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01634">llvm::ScalarEvolution::getZeroExtendExpr()</a>, <a class="el" href="CorrelatedValuePropagation_8cpp_source.html#l00635">processBinOp()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l01972">rangeMetadataExcludesValue()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00967">sdiv()</a>, <a class="el" href="InstructionSimplify_8cpp_source.html#l02468">simplifyICmpWithConstant()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08537">SolveQuadraticAddRecRange()</a>, and <a class="el" href="CorrelatedValuePropagation_8cpp_source.html#l00409">willNotOverflow()</a>.</p>

</div>
</div>
<a id="a2dbc1c19b39eab8b8473d97df0470855" name="a2dbc1c19b39eab8b8473d97df0470855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbc1c19b39eab8b8473d97df0470855">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>CR</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the other range is a subset of this one. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00376">376</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00295">isUpperWrapped()</a>.</p>

</div>
</div>
<a id="a4f4790febf2bf7aa44f5283a74ddf744" name="a4f4790febf2bf7aa44f5283a74ddf744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4790febf2bf7aa44f5283a74ddf744">&#9670;&nbsp;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>CR</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract the specified range from this range (aka relative complement of the sets). </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00402">402</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l01251">inverse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LazyValueInfo_8cpp_source.html#l01327">getEdgeValueLocal()</a>, and <a class="el" href="ValueTracking_8cpp_source.html#l05246">isImpliedCondMatchingImmOperands()</a>.</p>

</div>
</div>
<a id="a59e43abf85f6911f09023f40cf86cc5f" name="a59e43abf85f6911f09023f40cf86cc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e43abf85f6911f09023f40cf86cc5f">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Compiler_8h.html#aa863693eef567397d9c292da5bf22d34">LLVM_DUMP_METHOD</a> void ConstantRange::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow printing from a debugger easily. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01412">1412</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l01402">print()</a>.</p>

</div>
</div>
<a id="a211874a1535ba321cab61942cde9398f" name="a211874a1535ba321cab61942cde9398f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211874a1535ba321cab61942cde9398f">&#9670;&nbsp;</a></span>fromKnownBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::fromKnownBits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllvm_1_1KnownBits.html">KnownBits</a> &amp;&#160;</td>
          <td class="paramname"><em>Known</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsSigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a range based on a known bits constraint. </p>
<p >The IsSigned flag indicates whether the constant range should not wrap in the signed or unsigned domain. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00057">57</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="KnownBits_8h_source.html#l00039">llvm::KnownBits::getBitWidth()</a>, <a class="el" href="KnownBits_8h_source.html#l00046">llvm::KnownBits::hasConflict()</a>, <a class="el" href="KnownBits_8h_source.html#l00095">llvm::KnownBits::isNegative()</a>, <a class="el" href="KnownBits_8h_source.html#l00098">llvm::KnownBits::isNonNegative()</a>, <a class="el" href="KnownBits_8h_source.html#l00062">llvm::KnownBits::isUnknown()</a>, <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>, <a class="el" href="KnownBits_8h_source.html#l00024">llvm::KnownBits::One</a>, and <a class="el" href="KnownBits_8h_source.html#l00023">llvm::KnownBits::Zero</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueTracking_8cpp_source.html#l03977">computeConstantRangeIncludingKnownBits()</a>, and <a class="el" href="ValueTracking_8cpp_source.html#l03990">llvm::computeOverflowForUnsignedMul()</a>.</p>

</div>
</div>
<a id="ad7f81241f958a1f5917a3410942d3199" name="ad7f81241f958a1f5917a3410942d3199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f81241f958a1f5917a3410942d3199">&#9670;&nbsp;</a></span>getBitWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint32__t.html">uint32_t</a> llvm::ConstantRange::getBitWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bit width of this <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00165">165</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01259">abs()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01108">binaryAnd()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01119">binaryOr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00605">castOp()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l04059">computeOverflowForSignedAdd()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00149">getEquivalentICmp()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l05738">getRangeForAffineARHelper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00318">isSizeLargerThan()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00308">isSizeStrictlySmallerThan()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00197">makeExactMulNSWRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00184">makeExactMulNUWRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00967">sdiv()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00746">sextOrTrunc()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01306">signedAddMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01352">signedSubMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00665">signExtend()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01065">srem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00394">subtract()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00532">unionWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01052">urem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00648">zeroExtend()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00737">zextOrTrunc()</a>.</p>

</div>
</div>
<a id="aff6f6c6a6df94af8be1bd5accff28a71" name="aff6f6c6a6df94af8be1bd5accff28a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6f6c6a6df94af8be1bd5accff28a71">&#9670;&nbsp;</a></span>getEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> llvm::ConstantRange::getEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create empty constant range with the given bit width. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00073">73</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

</div>
</div>
<a id="a1616515fc811646b8cc5e6625e36b954" name="a1616515fc811646b8cc5e6625e36b954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1616515fc811646b8cc5e6625e36b954">&#9670;&nbsp;</a></span>getEquivalentICmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::getEquivalentICmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">APInt &amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up <code>Pred</code> and <code>RHS</code> such that ConstantRange::makeExactICmpRegion(Pred, RHS) == *this. </p>
<p >Return true if successful. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00149">149</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00159">getLower()</a>, <a class="el" href="ConstantRange_8h_source.html#l00207">getSingleElement()</a>, <a class="el" href="ConstantRange_8h_source.html#l00215">getSingleMissingElement()</a>, <a class="el" href="ConstantRange_8h_source.html#l00162">getUpper()</a>, <a class="el" href="InstrTypes_8h_source.html#l00753">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00754">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00760">llvm::CmpInst::ICMP_SGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00761">llvm::CmpInst::ICMP_SLT</a>, <a class="el" href="InstrTypes_8h_source.html#l00756">llvm::CmpInst::ICMP_UGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00757">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00137">makeExactICmpRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l08857">llvm::ScalarEvolution::SimplifyICmpOperands()</a>.</p>

</div>
</div>
<a id="a20bc7c6f540132189d07ad7f73bda1ee" name="a20bc7c6f540132189d07ad7f73bda1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bc7c6f540132189d07ad7f73bda1ee">&#9670;&nbsp;</a></span>getFull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> llvm::ConstantRange::getFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create full constant range with the given bit width. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00078">78</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

</div>
</div>
<a id="a23f4339e49343721146062b10c144052" name="a23f4339e49343721146062b10c144052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f4339e49343721146062b10c144052">&#9670;&nbsp;</a></span>getLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const APInt &amp; llvm::ConstantRange::getLower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the lower value for this range. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00159">159</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00799">add()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00149">getEquivalentICmp()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l10722">llvm::SCEVAddRecExpr::getNumIterationsInRange()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l05738">getRangeForAffineARHelper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="Metadata_8cpp_source.html#l00940">isContiguous()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ValueLattice_8cpp_source.html#l00012">llvm::operator&lt;&lt;()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08537">SolveQuadraticAddRecRange()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00829">sub()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00947">udiv()</a>.</p>

</div>
</div>
<a id="acd8afecbb15ee69487d5339371f64a76" name="acd8afecbb15ee69487d5339371f64a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8afecbb15ee69487d5339371f64a76">&#9670;&nbsp;</a></span>getNonEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> llvm::ConstantRange::getNonEmpty </td>
          <td>(</td>
          <td class="paramtype">APInt&#160;</td>
          <td class="paramname"><em>Lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">APInt&#160;</td>
          <td class="paramname"><em>Upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create non-empty constant range with the given bounds. </p>
<p >If Lower and Upper are the same, a full range is returned. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00084">84</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>, and <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0a19de5b94f7b83900d4b296d9fa491aec">llvm::Upper</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01165">ashr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01108">binaryAnd()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01119">binaryOr()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l05681">llvm::computeConstantRange()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l05738">getRangeForAffineARHelper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01155">lshr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00184">makeExactMulNUWRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00225">makeGuaranteedNoWrapRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01224">sadd_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00903">smax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00925">smin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01242">ssub_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01215">uadd_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00947">udiv()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00914">umax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00936">umin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01052">urem()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l01233">usub_sat()</a>.</p>

</div>
</div>
<a id="ac45b1557ea43684a07058cb74396c435" name="ac45b1557ea43684a07058cb74396c435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45b1557ea43684a07058cb74396c435">&#9670;&nbsp;</a></span>getSignedMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APInt ConstantRange::getSignedMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the largest signed value contained in the <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00355">355</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00162">getUpper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00303">isUpperSignWrapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01259">abs()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01165">ashr()</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00855">llvm::ScalarEvolution::getSignedRangeMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01224">sadd_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01306">signedAddMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01352">signedSubMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00903">smax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00925">smin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01065">srem()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l01242">ssub_sat()</a>.</p>

</div>
</div>
<a id="a6c03477d3ea04e382431f02a0f21aa41" name="a6c03477d3ea04e382431f02a0f21aa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c03477d3ea04e382431f02a0f21aa41">&#9670;&nbsp;</a></span>getSignedMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APInt ConstantRange::getSignedMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the smallest signed value contained in the <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00361">361</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00159">getLower()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00299">isSignWrappedSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01259">abs()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01165">ashr()</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00850">llvm::ScalarEvolution::getSignedRangeMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01224">sadd_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01306">signedAddMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01352">signedSubMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00903">smax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00925">smin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01065">srem()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l01242">ssub_sat()</a>.</p>

</div>
</div>
<a id="a1d705f2b7894d43bae1ff46eaf600181" name="a1d705f2b7894d43bae1ff46eaf600181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d705f2b7894d43bae1ff46eaf600181">&#9670;&nbsp;</a></span>getSingleElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const APInt * llvm::ConstantRange::getSingleElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this set contains a single element, return it, otherwise return null. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00207">207</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>, and <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0a19de5b94f7b83900d4b296d9fa491aec">llvm::Upper</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueLattice_8h_source.html#l00164">llvm::ValueLatticeElement::asConstantInteger()</a>, <a class="el" href="LazyValueInfo_8cpp_source.html#l01642">llvm::LazyValueInfo::getConstant()</a>, <a class="el" href="LazyValueInfo_8cpp_source.html#l01682">llvm::LazyValueInfo::getConstantOnEdge()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00149">getEquivalentICmp()</a>.</p>

</div>
</div>
<a id="a21152e890e7ed361d9ec662af218c4c8" name="a21152e890e7ed361d9ec662af218c4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21152e890e7ed361d9ec662af218c4c8">&#9670;&nbsp;</a></span>getSingleMissingElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const APInt * llvm::ConstantRange::getSingleMissingElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this set contains all but a single element, return it, otherwise return null. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00215">215</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>, and <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0a19de5b94f7b83900d4b296d9fa491aec">llvm::Upper</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00149">getEquivalentICmp()</a>.</p>

</div>
</div>
<a id="ab7f67c2ed8b2799c64ec64ca31d75c60" name="ab7f67c2ed8b2799c64ec64ca31d75c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f67c2ed8b2799c64ec64ca31d75c60">&#9670;&nbsp;</a></span>getUnsignedMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APInt ConstantRange::getUnsignedMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the largest unsigned value contained in the <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00343">343</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00162">getUpper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00295">isUpperWrapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolutionAliasAnalysis_8cpp_source.html#l00024">llvm::SCEVAAResult::alias()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01108">binaryAnd()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l00438">llvm::computeKnownBitsFromRangeMetadata()</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00839">llvm::ScalarEvolution::getUnsignedRangeMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01155">lshr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="PlaceSafepoints_8cpp_source.html#l00240">mustBeFiniteCountedLoop()</a>, <a class="el" href="CorrelatedValuePropagation_8cpp_source.html#l00535">processUDivOrURem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01130">shl()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01065">srem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01215">uadd_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00947">udiv()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00914">umax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00936">umin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01290">unsignedAddMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01382">unsignedMulMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01336">unsignedSubMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01052">urem()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l01233">usub_sat()</a>.</p>

</div>
</div>
<a id="a4d69e164b5fb0f73a15a07119c4302f7" name="a4d69e164b5fb0f73a15a07119c4302f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d69e164b5fb0f73a15a07119c4302f7">&#9670;&nbsp;</a></span>getUnsignedMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APInt ConstantRange::getUnsignedMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the smallest unsigned value contained in the <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00349">349</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00159">getLower()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00291">isWrappedSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolutionAliasAnalysis_8cpp_source.html#l00024">llvm::SCEVAAResult::alias()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01119">binaryOr()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l00438">llvm::computeKnownBitsFromRangeMetadata()</a>, <a class="el" href="ScalarEvolution_8h_source.html#l00834">llvm::ScalarEvolution::getUnsignedRangeMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01155">lshr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01130">shl()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01065">srem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01215">uadd_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00947">udiv()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00914">umax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00936">umin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01290">unsignedAddMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01382">unsignedMulMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01336">unsignedSubMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01052">urem()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l01233">usub_sat()</a>.</p>

</div>
</div>
<a id="aa1955c426e1ff66455b4bb6657ee995d" name="aa1955c426e1ff66455b4bb6657ee995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1955c426e1ff66455b4bb6657ee995d">&#9670;&nbsp;</a></span>getUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const APInt &amp; llvm::ConstantRange::getUpper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the upper value for this range. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00162">162</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0a19de5b94f7b83900d4b296d9fa491aec">llvm::Upper</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00799">add()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00149">getEquivalentICmp()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l10722">llvm::SCEVAddRecExpr::getNumIterationsInRange()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l05738">getRangeForAffineARHelper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="Metadata_8cpp_source.html#l00940">isContiguous()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="ValueLattice_8cpp_source.html#l00012">llvm::operator&lt;&lt;()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08537">SolveQuadraticAddRecRange()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00829">sub()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00947">udiv()</a>.</p>

</div>
</div>
<a id="ac098fe4f07549fb029fbf950dbe78fd3" name="ac098fe4f07549fb029fbf950dbe78fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac098fe4f07549fb029fbf950dbe78fd3">&#9670;&nbsp;</a></span>intersectWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::intersectWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>CR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082">PreferredRangeType</a>&#160;</td>
          <td class="paramname"><em>Type</em> = <code><a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082a25a373cd66e09df5cb7b8cf3f443ea2b">Smallest</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the range that results from the intersection of this range with another range. </p>
<p >If the intersection is disjoint, such that two results are possible, the preferred range is determined by the PreferredRangeType. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00426">426</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00406">getPreferredRange()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00295">isUpperWrapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00818">addWithNoSignedWrap()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l05681">llvm::computeConstantRange()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l03977">computeConstantRangeIncludingKnownBits()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00402">difference()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l05246">isImpliedCondMatchingImmOperands()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00225">makeGuaranteedNoWrapRegion()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00967">sdiv()</a>.</p>

</div>
</div>
<a id="aaaa2f5e2c6c3122d2b484f9e50950e18" name="aaaa2f5e2c6c3122d2b484f9e50950e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa2f5e2c6c3122d2b484f9e50950e18">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range that is the logical not of the current set. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01251">1251</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="JumpThreading_8cpp_source.html#l00583">llvm::JumpThreadingPass::ComputeValueKnownInPredecessorsImpl()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00402">difference()</a>, <a class="el" href="LazyValueInfo_8cpp_source.html#l01720">getPredicateResult()</a>, <a class="el" href="LazyValueInfo_8cpp_source.html#l01203">getValueFromOverflowCondition()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00127">makeSatisfyingICmpRegion()</a>, and <a class="el" href="InstructionSimplify_8cpp_source.html#l02468">simplifyICmpWithConstant()</a>.</p>

</div>
</div>
<a id="a256a302a20f8f9c2c02c9ca2d41ea78e" name="a256a302a20f8f9c2c02c9ca2d41ea78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256a302a20f8f9c2c02c9ca2d41ea78e">&#9670;&nbsp;</a></span>isAllNegative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isAllNegative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all values in this range are negative. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00328">328</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00303">isUpperSignWrapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueTracking_8cpp_source.html#l04059">computeOverflowForSignedAdd()</a>.</p>

</div>
</div>
<a id="a99a9706be916441a29cd5b93b64f033b" name="a99a9706be916441a29cd5b93b64f033b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a9706be916441a29cd5b93b64f033b">&#9670;&nbsp;</a></span>isAllNonNegative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isAllNonNegative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if all values in this range are non-negative. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00338">338</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00299">isSignWrappedSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueTracking_8cpp_source.html#l04059">computeOverflowForSignedAdd()</a>.</p>

</div>
</div>
<a id="a5bd6d98b4a7ecc1dcdc571e4352fcc52" name="a5bd6d98b4a7ecc1dcdc571e4352fcc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd6d98b4a7ecc1dcdc571e4352fcc52">&#9670;&nbsp;</a></span>isEmptySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isEmptySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this set contains no members. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00287">287</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01259">abs()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00799">add()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01165">ashr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01108">binaryAnd()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01119">binaryOr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00376">contains()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00149">getEquivalentICmp()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01251">inverse()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00328">isAllNegative()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l05246">isImpliedCondMatchingImmOperands()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01155">lshr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01402">print()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01224">sadd_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00967">sdiv()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01130">shl()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01306">signedAddMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01352">signedSubMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00665">signExtend()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08857">llvm::ScalarEvolution::SimplifyICmpOperands()</a>, <a class="el" href="InstructionSimplify_8cpp_source.html#l02468">simplifyICmpWithConstant()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00903">smax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00925">smin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01065">srem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01242">ssub_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00829">sub()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01215">uadd_sat()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00947">udiv()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00914">umax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00936">umin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00532">unionWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01290">unsignedAddMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01382">unsignedMulMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01336">unsignedSubMayOverflow()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01052">urem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01233">usub_sat()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00648">zeroExtend()</a>.</p>

</div>
</div>
<a id="a4f6242fab5145c424cee29230fefe746" name="a4f6242fab5145c424cee29230fefe746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6242fab5145c424cee29230fefe746">&#9670;&nbsp;</a></span>isFullSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isFullSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this set contains all of the elements possible for this data-type. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00283">283</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00799">add()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00367">contains()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00149">getEquivalentICmp()</a>, <a class="el" href="Metadata_8cpp_source.html#l00977">llvm::MDNode::getMostGenericRange()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l10722">llvm::SCEVAddRecExpr::getNumIterationsInRange()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l05738">getRangeForAffineARHelper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01251">inverse()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00328">isAllNegative()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00318">isSizeLargerThan()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00308">isSizeStrictlySmallerThan()</a>, <a class="el" href="ValueLattice_8h_source.html#l00240">llvm::ValueLatticeElement::mergeIn()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01402">print()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00665">signExtend()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08857">llvm::ScalarEvolution::SimplifyICmpOperands()</a>, <a class="el" href="InstructionSimplify_8cpp_source.html#l02468">simplifyICmpWithConstant()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00829">sub()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00532">unionWith()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00648">zeroExtend()</a>.</p>

</div>
</div>
<a id="a66d4b4c9a335549fc329921f27ac67fc" name="a66d4b4c9a335549fc329921f27ac67fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d4b4c9a335549fc329921f27ac67fc">&#9670;&nbsp;</a></span>isSignWrappedSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isSignWrappedSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this set wraps around the signed domain. </p>
<p >Special cases:</p><ul>
<li>Empty set: Not wrapped.</li>
<li>Full set: Not wrapped.</li>
<li>[X, SignedMin) == [X, SignedMax]: Not wrapped. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00299">299</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01259">abs()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00406">getPreferredRange()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00338">isAllNonNegative()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00665">signExtend()</a>.</p>

</div>
</div>
<a id="a91cf2c952ea87d701fe608fe4aaabfe4" name="a91cf2c952ea87d701fe608fe4aaabfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cf2c952ea87d701fe608fe4aaabfe4">&#9670;&nbsp;</a></span>isSingleElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ConstantRange::isSingleElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this set contains exactly one member. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00222">222</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LazyValueInfo_8cpp_source.html#l01720">getPredicateResult()</a>, <a class="el" href="LazyValueInfo_8cpp_source.html#l00066">hasSingleValue()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>.</p>

</div>
</div>
<a id="a688f2c4ca99eb7f935cab42c4f6398e7" name="a688f2c4ca99eb7f935cab42c4f6398e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688f2c4ca99eb7f935cab42c4f6398e7">&#9670;&nbsp;</a></span>isSizeLargerThan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isSizeLargerThan </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>MaxSize</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare set size of this range with <a class="el" href="classllvm_1_1Value.html" title="LLVM Value Representation.">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00318">318</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>.</p>

</div>
</div>
<a id="af656a14964b9cf9e049c1064b5f30c2b" name="af656a14964b9cf9e049c1064b5f30c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af656a14964b9cf9e049c1064b5f30c2b">&#9670;&nbsp;</a></span>isSizeStrictlySmallerThan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isSizeStrictlySmallerThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>CR</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare set size of this range with the range CR. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00308">308</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00406">getPreferredRange()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>.</p>

</div>
</div>
<a id="a055ace4be97619b5dae7d6b3c4dbb4aa" name="a055ace4be97619b5dae7d6b3c4dbb4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055ace4be97619b5dae7d6b3c4dbb4aa">&#9670;&nbsp;</a></span>isUpperSignWrapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isUpperSignWrapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the (exclusive) upper bound wraps around the signed domain. </p>
<p >Special cases:</p><ul>
<li>Empty set: Not wrapped.</li>
<li>Full set: Not wrapped.</li>
<li>[X, SignedMin): Wrapped. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00303">303</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00328">isAllNegative()</a>.</p>

</div>
</div>
<a id="aa1a0c35225268e93dc3afd67e079f826" name="aa1a0c35225268e93dc3afd67e079f826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a0c35225268e93dc3afd67e079f826">&#9670;&nbsp;</a></span>isUpperWrapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isUpperWrapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the exclusive upper bound wraps around the unsigned domain. </p>
<p >Special cases:</p><ul>
<li>Empty set: Not wrapped.</li>
<li>Full set: Not wrapped.</li>
<li>[X, 0): Wrapped. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00295">295</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00367">contains()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00532">unionWith()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00648">zeroExtend()</a>.</p>

</div>
</div>
<a id="a76bca22a9253d0962fd07031c89b98e7" name="a76bca22a9253d0962fd07031c89b98e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bca22a9253d0962fd07031c89b98e7">&#9670;&nbsp;</a></span>isWrappedSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ConstantRange::isWrappedSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this set wraps around the unsigned domain. </p>
<p >Special cases:</p><ul>
<li>Empty set: Not wrapped.</li>
<li>Full set: Not wrapped.</li>
<li>[X, 0) == [X, Max]: Not wrapped. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00291">291</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00406">getPreferredRange()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>.</p>

</div>
</div>
<a id="a452f6ecfc69e273b9005e5bac75583a3" name="a452f6ecfc69e273b9005e5bac75583a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452f6ecfc69e273b9005e5bac75583a3">&#9670;&nbsp;</a></span>lshr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::lshr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a logical right shift of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01155">1155</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="aa0830ec6778859b4abb3e8bf0b9e0e38" name="aa0830ec6778859b4abb3e8bf0b9e0e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0830ec6778859b4abb3e8bf0b9e0e38">&#9670;&nbsp;</a></span>makeAllowedICmpRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::makeAllowedICmpRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a>&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the smallest range such that all values that may satisfy the given predicate with any value contained within Other is contained in the returned range. </p>
<p >Formally, this returns a superset of 'union over all y in Other . { x : icmp op x y is true }'. If the exact answer is not representable as a <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>, the return value will be a proper superset of the above.</p>
<p >Example: Pred = ult and Other = i8 [2, 5) returns Result = [0, 4) </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00077">77</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00159">getLower()</a>, <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8h_source.html#l00162">getUpper()</a>, <a class="el" href="InstrTypes_8h_source.html#l00753">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00754">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00760">llvm::CmpInst::ICMP_SGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00759">llvm::CmpInst::ICMP_SGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00762">llvm::CmpInst::ICMP_SLE</a>, <a class="el" href="InstrTypes_8h_source.html#l00761">llvm::CmpInst::ICMP_SLT</a>, <a class="el" href="InstrTypes_8h_source.html#l00756">llvm::CmpInst::ICMP_UGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00755">llvm::CmpInst::ICMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00758">llvm::CmpInst::ICMP_ULE</a>, <a class="el" href="InstrTypes_8h_source.html#l00757">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8h_source.html#l00222">isSingleElement()</a>, and <a class="el" href="ErrorHandling_8h_source.html#l00135">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="LazyValueInfo_8cpp_source.html#l01138">getValueFromICmpCondition()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l05246">isImpliedCondMatchingImmOperands()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00137">makeExactICmpRegion()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00127">makeSatisfyingICmpRegion()</a>.</p>

</div>
</div>
<a id="aa89e9cec92a0b38d2f47a077bf12cc98" name="aa89e9cec92a0b38d2f47a077bf12cc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89e9cec92a0b38d2f47a077bf12cc98">&#9670;&nbsp;</a></span>makeExactICmpRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::makeExactICmpRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a>&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>Other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the exact range such that all values in the returned range satisfy the given predicate with any value contained within Other. </p>
<p >Formally, this returns the exact answer when the superset of 'union over all y in Other is exactly same as the subset of intersection over all y in Other. { x : icmp op x y is true}'.</p>
<p >Example: Pred = ult and Other = i8 3 returns [0, 3) </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00137">137</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00127">makeSatisfyingICmpRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="JumpThreading_8cpp_source.html#l00583">llvm::JumpThreadingPass::ComputeValueKnownInPredecessorsImpl()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00149">getEquivalentICmp()</a>, <a class="el" href="LazyValueInfo_8cpp_source.html#l01720">getPredicateResult()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l05246">isImpliedCondMatchingImmOperands()</a>, <a class="el" href="InstructionSimplify_8cpp_source.html#l01468">simplifyAndOrOfICmpsWithConstants()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08857">llvm::ScalarEvolution::SimplifyICmpOperands()</a>, and <a class="el" href="InstructionSimplify_8cpp_source.html#l02468">simplifyICmpWithConstant()</a>.</p>

</div>
</div>
<a id="aeddb6f4f9ffcb9e893e5cb321b7a7f83" name="aeddb6f4f9ffcb9e893e5cb321b7a7f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddb6f4f9ffcb9e893e5cb321b7a7f83">&#9670;&nbsp;</a></span>makeExactNoWrapRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::makeExactNoWrapRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html#ac26154a24f393f523c87cc5f8239f36c">Instruction::BinaryOps</a>&#160;</td>
          <td class="paramname"><em>BinOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>NoWrapKind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the range that contains X if and only if "X BinOp Other" does not wrap. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00275">275</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00225">makeGuaranteedNoWrapRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00818">addWithNoSignedWrap()</a>, and <a class="el" href="LazyValueInfo_8cpp_source.html#l01203">getValueFromOverflowCondition()</a>.</p>

</div>
</div>
<a id="ace208c0bd1d845fe49f319be6a954764" name="ace208c0bd1d845fe49f319be6a954764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace208c0bd1d845fe49f319be6a954764">&#9670;&nbsp;</a></span>makeGuaranteedNoWrapRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::makeGuaranteedNoWrapRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html#ac26154a24f393f523c87cc5f8239f36c">Instruction::BinaryOps</a>&#160;</td>
          <td class="paramname"><em>BinOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>NoWrapKind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the largest range containing all X such that "X BinOp Y" is guaranteed not to wrap (overflow) for <em>all</em> Y in Other. </p>
<p >However, there may be <em>some</em> Y in Other for which additional X not contained in the result also do not overflow.</p>
<p >NoWrapKind must be one of OBO::NoUnsignedWrap or OBO::NoSignedWrap.</p>
<p >Examples: typedef <a class="el" href="classllvm_1_1OverflowingBinaryOperator.html" title="Utility class for integer operators which may exhibit overflow - Add, Sub, Mul, and Shl.">OverflowingBinaryOperator</a> OBO; #define MGNR makeGuaranteedNoWrapRegion MGNR(Add, [i8 1, 2), OBO::NoSignedWrap) == [-128, 127) MGNR(Add, [i8 1, 2), OBO::NoUnsignedWrap) == [0, -1) MGNR(Add, [i8 0, 1), OBO::NoUnsignedWrap) == Full Set MGNR(Add, [i8 -1, 6), OBO::NoSignedWrap) == [INT_MIN+1, INT_MAX-4) MGNR(Sub, [i8 1, 2), OBO::NoSignedWrap) == [-127, 128) MGNR(Sub, [i8 1, 2), OBO::NoUnsignedWrap) == [1, 0) </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00225">225</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="Instruction_8h_source.html#l00130">llvm::Instruction::isBinaryOp()</a>, <a class="el" href="ErrorHandling_8h_source.html#l00135">llvm_unreachable</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00197">makeExactMulNSWRegion()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00184">makeExactMulNUWRegion()</a>, <a class="el" href="Instructions_8h_source.html#l00711">llvm::AtomicRMWInst::Sub</a>, and <a class="el" href="ConstantRange_8h_source.html#l00272">Unsigned</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00275">makeExactNoWrapRegion()</a>, <a class="el" href="CorrelatedValuePropagation_8cpp_source.html#l00635">processBinOp()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l02333">StrengthenNoWrapFlags()</a>, and <a class="el" href="CorrelatedValuePropagation_8cpp_source.html#l00409">willNotOverflow()</a>.</p>

</div>
</div>
<a id="a6fbc74ae7d3a1a1423c26b9ce948f34c" name="a6fbc74ae7d3a1a1423c26b9ce948f34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbc74ae7d3a1a1423c26b9ce948f34c">&#9670;&nbsp;</a></span>makeSatisfyingICmpRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::makeSatisfyingICmpRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a>&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the largest range such that all values in the returned range satisfy the given predicate with all values contained within Other. </p>
<p >Formally, this returns a subset of 'intersection over all y in Other . { x : icmp op x y is true }'. If the exact answer is not representable as a <a class="el" href="classllvm_1_1ConstantRange.html" title="This class represents a range of values.">ConstantRange</a>, the return value will be a proper subset of the above.</p>
<p >Example: Pred = ult and Other = i8 [2, 5) returns [0, 2) </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00127">127</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstrTypes_8h_source.html#l00831">llvm::CmpInst::getInversePredicate()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l01251">inverse()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00077">makeAllowedICmpRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueLattice_8h_source.html#l00293">llvm::ValueLatticeElement::getCompare()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00137">makeExactICmpRegion()</a>, and <a class="el" href="InstructionSimplify_8cpp_source.html#l03027">SimplifyICmpInst()</a>.</p>

</div>
</div>
<a id="a0309899567234d74bf87a3899207bc15" name="a0309899567234d74bf87a3899207bc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0309899567234d74bf87a3899207bc15">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a multiplication of a value in this range and a value in <code>Other</code>, treating both this and <code>Other</code> as unsigned ranges. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00849">849</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8h_source.html#l00162">getUpper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00308">isSizeStrictlySmallerThan()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00295">isUpperWrapped()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="ac9f0de2ee6d1ca4bb53bba22b237dee9" name="ac9f0de2ee6d1ca4bb53bba22b237dee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f0de2ee6d1ca4bb53bba22b237dee9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1bfi__detail_1_1BlockMass.html#a07e9c2c2d820ae6830cb200d9c127839">llvm::ConstantRange::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>CR</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00252">252</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

</div>
</div>
<a id="a8748bc223c6110faf90246950c579112" name="a8748bc223c6110faf90246950c579112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8748bc223c6110faf90246950c579112">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ConstantRange::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>CR</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this range is equal to another range. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8h_source.html#l00249">249</a> of file <a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>, and <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0a19de5b94f7b83900d4b296d9fa491aec">llvm::Upper</a>.</p>

</div>
</div>
<a id="a8831f85b65cbcc9cf42d70988845a9f6" name="a8831f85b65cbcc9cf42d70988845a9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8831f85b65cbcc9cf42d70988845a9f6">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConstantRange::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>OS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the bounds to a stream. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01402">1402</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01412">dump()</a>, <a class="el" href="ConstantRange_8h_source.html#l00459">llvm::operator&lt;&lt;()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l11481">llvm::ScalarEvolution::print()</a>.</p>

</div>
</div>
<a id="a54097522b509c08dd84e5ce59437c8b9" name="a54097522b509c08dd84e5ce59437c8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54097522b509c08dd84e5ce59437c8b9">&#9670;&nbsp;</a></span>sadd_sat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::sadd_sat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a signed saturating addition of two constant ranges. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01224">1224</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

</div>
</div>
<a id="aa160a2ac0c31b48c41da949e53cc21b7" name="aa160a2ac0c31b48c41da949e53cc21b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa160a2ac0c31b48c41da949e53cc21b7">&#9670;&nbsp;</a></span>sdiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::sdiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a signed division of a value in this range and a value in <code>Other</code>. </p>
<p >Division by zero and division of SignedMin by -1 are considered undefined behavior, in line with IR, and do not contribute towards the result. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00967">967</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00367">contains()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00426">intersectWith()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00967">sdiv()</a>, <a class="el" href="ConstantRange_8h_source.html#l00272">Signed</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00532">unionWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00967">sdiv()</a>.</p>

</div>
</div>
<a id="aebc1456c2e4f9d6d95aa0b089b3df535" name="aebc1456c2e4f9d6d95aa0b089b3df535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc1456c2e4f9d6d95aa0b089b3df535">&#9670;&nbsp;</a></span>sextOrTrunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::sextOrTrunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make this range have the bit width given by <code>BitWidth</code>. </p>
<p >The value is sign extended, truncated, or left alone to make it that width. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00746">746</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00665">signExtend()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l01940">llvm::ScalarEvolution::getSignExtendExpr()</a>.</p>

</div>
</div>
<a id="a62222502f5be2dd8e300b48469aeab4f" name="a62222502f5be2dd8e300b48469aeab4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62222502f5be2dd8e300b48469aeab4f">&#9670;&nbsp;</a></span>shl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::shl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a left shift of a value in this range by a value in <code>Other</code>. </p>
<p >TODO: This isn't fully implemented yet. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01130">1130</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="ab1e4a3ec7de159965bcee94fae9df74b" name="ab1e4a3ec7de159965bcee94fae9df74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e4a3ec7de159965bcee94fae9df74b">&#9670;&nbsp;</a></span>signedAddMayOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">ConstantRange::OverflowResult</a> ConstantRange::signedAddMayOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether signed add of the two ranges always/never overflows. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01306">1306</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a9ac50ff0c308dad407db9f09e418363e">AlwaysOverflowsHigh</a>, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ac8cc76d76703c81c16e939be370683c1">AlwaysOverflowsLow</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ad4d9862eafa015a05101d9f662bb153a">MayOverflow</a>, and <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a56624a95592b438e05ab500a6a200a03">NeverOverflows</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueTracking_8cpp_source.html#l04059">computeOverflowForSignedAdd()</a>.</p>

</div>
</div>
<a id="ae907195afbb8c9442691836e26ac0001" name="ae907195afbb8c9442691836e26ac0001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae907195afbb8c9442691836e26ac0001">&#9670;&nbsp;</a></span>signedSubMayOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">ConstantRange::OverflowResult</a> ConstantRange::signedSubMayOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether signed sub of the two ranges always/never overflows. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01352">1352</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a9ac50ff0c308dad407db9f09e418363e">AlwaysOverflowsHigh</a>, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ac8cc76d76703c81c16e939be370683c1">AlwaysOverflowsLow</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ad4d9862eafa015a05101d9f662bb153a">MayOverflow</a>, and <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a56624a95592b438e05ab500a6a200a03">NeverOverflows</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueTracking_8cpp_source.html#l04135">llvm::computeOverflowForSignedSub()</a>.</p>

</div>
</div>
<a id="a9c8872e25eeddcc398a41e003e7c3f55" name="a9c8872e25eeddcc398a41e003e7c3f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8872e25eeddcc398a41e003e7c3f55">&#9670;&nbsp;</a></span>signExtend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::signExtend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range in the specified integer type, which must be strictly larger than the current type. </p>
<p >The returned range will correspond to the possible range of values if the source range had been sign extended to BitWidth. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00665">665</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00299">isSignWrappedSet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00605">castOp()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01940">llvm::ScalarEvolution::getSignExtendExpr()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00746">sextOrTrunc()</a>.</p>

</div>
</div>
<a id="ae0d25c37392410b0b31e43feae19489c" name="ae0d25c37392410b0b31e43feae19489c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d25c37392410b0b31e43feae19489c">&#9670;&nbsp;</a></span>smax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::smax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a signed maximum of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00903">903</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

</div>
</div>
<a id="ad14e808f6eb7296b587b22cc49919da7" name="ad14e808f6eb7296b587b22cc49919da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14e808f6eb7296b587b22cc49919da7">&#9670;&nbsp;</a></span>smin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::smin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a signed minimum of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00925">925</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

</div>
</div>
<a id="a51ae77be815f3771d7e0e1837204af01" name="a51ae77be815f3771d7e0e1837204af01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ae77be815f3771d7e0e1837204af01">&#9670;&nbsp;</a></span>srem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::srem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a signed remainder operation of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01065">1065</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8cpp_source.html#l01259">abs()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>, and <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0a19de5b94f7b83900d4b296d9fa491aec">llvm::Upper</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="a993a75b630274a45cb0c20938962796f" name="a993a75b630274a45cb0c20938962796f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993a75b630274a45cb0c20938962796f">&#9670;&nbsp;</a></span>ssub_sat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::ssub_sat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a signed saturating subtraction of two constant ranges. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01242">1242</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00355">getSignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00361">getSignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

</div>
</div>
<a id="aeb57116b101c8d1263ff5ffdaccdcad0" name="aeb57116b101c8d1263ff5ffdaccdcad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb57116b101c8d1263ff5ffdaccdcad0">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> <a class="el" href="structllvm_1_1cl_1_1sub.html">ConstantRange::sub</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from a subtraction of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00829">829</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00159">getLower()</a>, <a class="el" href="ConstantRange_8h_source.html#l00162">getUpper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="a1d29074c7a610816d4f328b7cd9b783d" name="a1d29074c7a610816d4f328b7cd9b783d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d29074c7a610816d4f328b7cd9b783d">&#9670;&nbsp;</a></span>subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::subtract </td>
          <td>(</td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>CI</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract the specified constant from the endpoints of this constant range. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00394">394</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l10722">llvm::SCEVAddRecExpr::getNumIterationsInRange()</a>, and <a class="el" href="LazyValueInfo_8cpp_source.html#l01138">getValueFromICmpCondition()</a>.</p>

</div>
</div>
<a id="a2bc441c8fe8dfeea5471f11d2d823ec1" name="a2bc441c8fe8dfeea5471f11d2d823ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc441c8fe8dfeea5471f11d2d823ec1">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range in the specified integer type, which must be strictly smaller than the current type. </p>
<p >The returned range will correspond to the possible range of values if the source range had been truncated to the specified type. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00683">683</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00295">isUpperWrapped()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00532">unionWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00605">castOp()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01940">llvm::ScalarEvolution::getSignExtendExpr()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01634">llvm::ScalarEvolution::getZeroExtendExpr()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00849">multiply()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00746">sextOrTrunc()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00737">zextOrTrunc()</a>.</p>

</div>
</div>
<a id="a81da9170db4b7b8f89c9d196c07a6efb" name="a81da9170db4b7b8f89c9d196c07a6efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81da9170db4b7b8f89c9d196c07a6efb">&#9670;&nbsp;</a></span>uadd_sat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::uadd_sat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an unsigned saturating addition of two constant ranges. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01215">1215</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

</div>
</div>
<a id="ad41d307fed42f6776d36397336e81985" name="ad41d307fed42f6776d36397336e81985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41d307fed42f6776d36397336e81985">&#9670;&nbsp;</a></span>udiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::udiv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from an unsigned division of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00947">947</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00159">getLower()</a>, <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8h_source.html#l00162">getUpper()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0ab75fcdd2d72d9e000beab48622402d93">llvm::Lower</a>, and <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0a19de5b94f7b83900d4b296d9fa491aec">llvm::Upper</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="a99d98815d214fb4c80537873777e91fb" name="a99d98815d214fb4c80537873777e91fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d98815d214fb4c80537873777e91fb">&#9670;&nbsp;</a></span>umax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::umax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from an unsigned maximum of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00914">914</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01119">binaryOr()</a>.</p>

</div>
</div>
<a id="a4cabbd29371bbe4737500f0bf60774fd" name="a4cabbd29371bbe4737500f0bf60774fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cabbd29371bbe4737500f0bf60774fd">&#9670;&nbsp;</a></span>umin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::umin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from an unsigned minimum of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00936">936</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01108">binaryAnd()</a>.</p>

</div>
</div>
<a id="aa81521f99442a5c30f9061b8c6ce795e" name="aa81521f99442a5c30f9061b8c6ce795e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81521f99442a5c30f9061b8c6ce795e">&#9670;&nbsp;</a></span>unionWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::unionWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>CR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082">PreferredRangeType</a>&#160;</td>
          <td class="paramname"><em>Type</em> = <code><a class="el" href="classllvm_1_1ConstantRange.html#a0e6f2069000829208cbac185a07d8082a25a373cd66e09df5cb7b8cf3f443ea2b">Smallest</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the range that results from the union of this range with another range. </p>
<p >The resultant range is guaranteed to include the elements of both sets, but may contain more. For example, [3, 9) union [12,15) is [3, 15), which includes 9, 10, and 11, which were not included in either set before. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00532">532</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00406">getPreferredRange()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00295">isUpperWrapped()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00532">unionWith()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l01417">llvm::getConstantRangeFromMetadata()</a>, <a class="el" href="LazyValueInfo_8cpp_source.html#l01327">getEdgeValueLocal()</a>, <a class="el" href="ValueLattice_8h_source.html#l00240">llvm::ValueLatticeElement::mergeIn()</a>, <a class="el" href="CorrelatedValuePropagation_8cpp_source.html#l00535">processUDivOrURem()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00967">sdiv()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>, <a class="el" href="Metadata_8cpp_source.html#l00948">tryMergeRange()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00532">unionWith()</a>.</p>

</div>
</div>
<a id="a2bf71829dbcdadbd24d3c22814113ebf" name="a2bf71829dbcdadbd24d3c22814113ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf71829dbcdadbd24d3c22814113ebf">&#9670;&nbsp;</a></span>unsignedAddMayOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">ConstantRange::OverflowResult</a> ConstantRange::unsignedAddMayOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether unsigned add of the two ranges always/never overflows. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01290">1290</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a9ac50ff0c308dad407db9f09e418363e">AlwaysOverflowsHigh</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ad4d9862eafa015a05101d9f662bb153a">MayOverflow</a>, and <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a56624a95592b438e05ab500a6a200a03">NeverOverflows</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueTracking_8cpp_source.html#l04046">llvm::computeOverflowForUnsignedAdd()</a>.</p>

</div>
</div>
<a id="a8ccba85d5176205f41ad55236b7d8204" name="a8ccba85d5176205f41ad55236b7d8204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccba85d5176205f41ad55236b7d8204">&#9670;&nbsp;</a></span>unsignedMulMayOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">ConstantRange::OverflowResult</a> ConstantRange::unsignedMulMayOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether unsigned mul of the two ranges always/never overflows. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01382">1382</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a9ac50ff0c308dad407db9f09e418363e">AlwaysOverflowsHigh</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ad4d9862eafa015a05101d9f662bb153a">MayOverflow</a>, and <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a56624a95592b438e05ab500a6a200a03">NeverOverflows</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueTracking_8cpp_source.html#l03990">llvm::computeOverflowForUnsignedMul()</a>.</p>

</div>
</div>
<a id="a24a99adda34abba8c6988f8292a93815" name="a24a99adda34abba8c6988f8292a93815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a99adda34abba8c6988f8292a93815">&#9670;&nbsp;</a></span>unsignedSubMayOverflow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87">ConstantRange::OverflowResult</a> ConstantRange::unsignedSubMayOverflow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether unsigned sub of the two ranges always/never overflows. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01336">1336</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ac8cc76d76703c81c16e939be370683c1">AlwaysOverflowsLow</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87ad4d9862eafa015a05101d9f662bb153a">MayOverflow</a>, and <a class="el" href="classllvm_1_1ConstantRange.html#ac5a96896a96f880fbd295aec85a81a87a56624a95592b438e05ab500a6a200a03">NeverOverflows</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueTracking_8cpp_source.html#l04122">llvm::computeOverflowForUnsignedSub()</a>.</p>

</div>
</div>
<a id="a336e2050c47c9d72b2cb4b13726fbba3" name="a336e2050c47c9d72b2cb4b13726fbba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336e2050c47c9d72b2cb4b13726fbba3">&#9670;&nbsp;</a></span>urem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::urem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range representing the possible values resulting from an unsigned remainder operation of a value in this range and a value in <code>Other</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01052">1052</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, and <a class="el" href="namespacellvm.html#a6893db19648a2dba0912d181aaa57ec0a19de5b94f7b83900d4b296d9fa491aec">llvm::Upper</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00755">binaryOp()</a>.</p>

</div>
</div>
<a id="a7a13c7e552038eb1d567e1572d91c411" name="a7a13c7e552038eb1d567e1572d91c411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a13c7e552038eb1d567e1572d91c411">&#9670;&nbsp;</a></span>usub_sat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::usub_sat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an unsigned saturating subtraction of two constant ranges. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l01233">1233</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00084">getNonEmpty()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00343">getUnsignedMax()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00349">getUnsignedMin()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>.</p>

</div>
</div>
<a id="a636ddf018d314a1d73f98e2fa4efbafb" name="a636ddf018d314a1d73f98e2fa4efbafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636ddf018d314a1d73f98e2fa4efbafb">&#9670;&nbsp;</a></span>zeroExtend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::zeroExtend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new range in the specified integer type, which must be strictly larger than the current type. </p>
<p >The returned range will correspond to the possible range of values if the source range had been zero extended to BitWidth. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00648">648</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00287">isEmptySet()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00283">isFullSet()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00295">isUpperWrapped()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantRange_8cpp_source.html#l00605">castOp()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l01634">llvm::ScalarEvolution::getZeroExtendExpr()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00737">zextOrTrunc()</a>.</p>

</div>
</div>
<a id="a05ef50c1573b919a575fccb31cc523b4" name="a05ef50c1573b919a575fccb31cc523b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ef50c1573b919a575fccb31cc523b4">&#9670;&nbsp;</a></span>zextOrTrunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a> ConstantRange::zextOrTrunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make this range have the bit width given by <code>BitWidth</code>. </p>
<p >The value is zero extended, truncated, or left alone to make it that width. </p>

<p class="definition">Definition at line <a class="el" href="ConstantRange_8cpp_source.html#l00737">737</a> of file <a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantRange_8h_source.html#l00165">getBitWidth()</a>, <a class="el" href="ConstantRange_8cpp_source.html#l00683">truncate()</a>, and <a class="el" href="ConstantRange_8cpp_source.html#l00648">zeroExtend()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l01634">llvm::ScalarEvolution::getZeroExtendExpr()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/llvm/IR/<a class="el" href="ConstantRange_8h_source.html">ConstantRange.h</a></li>
<li>lib/IR/<a class="el" href="ConstantRange_8cpp_source.html">ConstantRange.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:56:44 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
