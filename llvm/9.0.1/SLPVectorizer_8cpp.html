<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/Vectorize/SLPVectorizer.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_acb975f027bc8cf760392318543d920a.html">Vectorize</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">SLPVectorizer.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;llvm/Transforms/Vectorize/SLPVectorizer.h&quot;</code><br />
<code>#include &quot;llvm/ADT/ArrayRef.h&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseMap.h&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/MapVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/None.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Optional.h&quot;</code><br />
<code>#include &quot;llvm/ADT/PostOrderIterator.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SetVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallPtrSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Statistic.h&quot;</code><br />
<code>#include &quot;llvm/ADT/iterator.h&quot;</code><br />
<code>#include &quot;llvm/ADT/iterator_range.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/AliasAnalysis.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/CodeMetrics.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/DemandedBits.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/GlobalsModRef.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/LoopAccessAnalysis.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/LoopInfo.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/MemoryLocation.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/OptimizationRemarkEmitter.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/ScalarEvolution.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/ScalarEvolutionExpressions.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/TargetLibraryInfo.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/TargetTransformInfo.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/ValueTracking.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/VectorUtils.h&quot;</code><br />
<code>#include &quot;llvm/IR/Attributes.h&quot;</code><br />
<code>#include &quot;llvm/IR/BasicBlock.h&quot;</code><br />
<code>#include &quot;llvm/IR/Constant.h&quot;</code><br />
<code>#include &quot;llvm/IR/Constants.h&quot;</code><br />
<code>#include &quot;llvm/IR/DataLayout.h&quot;</code><br />
<code>#include &quot;llvm/IR/DebugLoc.h&quot;</code><br />
<code>#include &quot;llvm/IR/DerivedTypes.h&quot;</code><br />
<code>#include &quot;llvm/IR/Dominators.h&quot;</code><br />
<code>#include &quot;llvm/IR/Function.h&quot;</code><br />
<code>#include &quot;llvm/IR/IRBuilder.h&quot;</code><br />
<code>#include &quot;llvm/IR/InstrTypes.h&quot;</code><br />
<code>#include &quot;llvm/IR/Instruction.h&quot;</code><br />
<code>#include &quot;llvm/IR/Instructions.h&quot;</code><br />
<code>#include &quot;llvm/IR/IntrinsicInst.h&quot;</code><br />
<code>#include &quot;llvm/IR/Intrinsics.h&quot;</code><br />
<code>#include &quot;llvm/IR/Module.h&quot;</code><br />
<code>#include &quot;llvm/IR/NoFolder.h&quot;</code><br />
<code>#include &quot;llvm/IR/Operator.h&quot;</code><br />
<code>#include &quot;llvm/IR/PassManager.h&quot;</code><br />
<code>#include &quot;llvm/IR/PatternMatch.h&quot;</code><br />
<code>#include &quot;llvm/IR/Type.h&quot;</code><br />
<code>#include &quot;llvm/IR/Use.h&quot;</code><br />
<code>#include &quot;llvm/IR/User.h&quot;</code><br />
<code>#include &quot;llvm/IR/Value.h&quot;</code><br />
<code>#include &quot;llvm/IR/ValueHandle.h&quot;</code><br />
<code>#include &quot;llvm/IR/Verifier.h&quot;</code><br />
<code>#include &quot;llvm/Pass.h&quot;</code><br />
<code>#include &quot;llvm/Support/Casting.h&quot;</code><br />
<code>#include &quot;llvm/Support/CommandLine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Compiler.h&quot;</code><br />
<code>#include &quot;llvm/Support/DOTGraphTraits.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/ErrorHandling.h&quot;</code><br />
<code>#include &quot;llvm/Support/GraphWriter.h&quot;</code><br />
<code>#include &quot;llvm/Support/KnownBits.h&quot;</code><br />
<code>#include &quot;llvm/Support/MathExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &quot;llvm/Transforms/Utils/LoopUtils.h&quot;</code><br />
<code>#include &quot;llvm/Transforms/Vectorize.h&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="SLPVectorizer_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1slpvectorizer_1_1BoUpSLP.html">llvm::slpvectorizer::BoUpSLP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bottom Up SLP Vectorizer.  <a href="classllvm_1_1slpvectorizer_1_1BoUpSLP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1slpvectorizer_1_1BoUpSLP_1_1EdgeInfo.html">llvm::slpvectorizer::BoUpSLP::EdgeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure holds any data we need about the edges being traversed during buildTree_rec().  <a href="structllvm_1_1slpvectorizer_1_1BoUpSLP_1_1EdgeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1slpvectorizer_1_1BoUpSLP_1_1VLOperands.html">llvm::slpvectorizer::BoUpSLP::VLOperands</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper data structure to hold the operands of a vector of instructions.  <a href="classllvm_1_1slpvectorizer_1_1BoUpSLP_1_1VLOperands.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1slpvectorizer_1_1BoUpSLP_1_1BlockScheduling_1_1ReadyList.html">llvm::slpvectorizer::BoUpSLP::BlockScheduling::ReadyList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1GraphTraits_3_01BoUpSLP_01_5_01_4.html">llvm::GraphTraits&lt; BoUpSLP * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1GraphTraits_3_01BoUpSLP_01_5_01_4_1_1ChildIteratorType.html">llvm::GraphTraits&lt; BoUpSLP * &gt;::ChildIteratorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the VectorizableTree to the index iterator to be able to return TreeEntry pointers.  <a href="structllvm_1_1GraphTraits_3_01BoUpSLP_01_5_01_4_1_1ChildIteratorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1GraphTraits_3_01BoUpSLP_01_5_01_4_1_1nodes__iterator.html">llvm::GraphTraits&lt; BoUpSLP * &gt;::nodes_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the node iterator we just need to turn the TreeEntry iterator into a TreeEntry* iterator so that it dereferences to NodeRef.  <a href="classllvm_1_1GraphTraits_3_01BoUpSLP_01_5_01_4_1_1nodes__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1DOTGraphTraits_3_01BoUpSLP_01_5_01_4.html">llvm::DOTGraphTraits&lt; BoUpSLP * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellvm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm_1_1slpvectorizer"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1slpvectorizer.html">llvm::slpvectorizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a274654b7f5932cae6a71a113322481be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a274654b7f5932cae6a71a113322481be">SV_NAME</a>&#160;&#160;&#160;&quot;slp-vectorizer&quot;</td></tr>
<tr class="separator:a274654b7f5932cae6a71a113322481be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;SLP&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae36ebcd8ea18a5e24ffe0c11fb9e965f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#ae36ebcd8ea18a5e24ffe0c11fb9e965f">STATISTIC</a> (NumVectorInstructions, &quot;Number of vector <a class="el" href="InstructionCombining_8cpp.html#a9360db2a972441c49cdbbabb5b20cc27">instructions</a> generated&quot;)</td></tr>
<tr class="separator:ae36ebcd8ea18a5e24ffe0c11fb9e965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043a8336eb4f346f6cb7f88be4ed611c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a043a8336eb4f346f6cb7f88be4ed611c">SLPCostThreshold</a> (&quot;slp-threshold&quot;, cl::init(0), cl::Hidden, cl::desc(&quot;Only vectorize <a class="el" href="DeadArgumentElimination_8cpp.html#ac09a30d47dd36dfe05dda91e8d67e92f">if</a> you gain more than this &quot; &quot;number &quot;))</td></tr>
<tr class="separator:a043a8336eb4f346f6cb7f88be4ed611c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990230d1fc14f4b06a496ff7a4b901fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a990230d1fc14f4b06a496ff7a4b901fa">ShouldVectorizeHor</a> (&quot;slp-vectorize-hor&quot;, cl::init(<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>), cl::Hidden, cl::desc(&quot;Attempt to vectorize horizontal reductions&quot;))</td></tr>
<tr class="separator:a990230d1fc14f4b06a496ff7a4b901fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc49ed8e85692a2ddd2007dcd4f283b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#acc49ed8e85692a2ddd2007dcd4f283b6">ShouldStartVectorizeHorAtStore</a> (&quot;slp-vectorize-hor-store&quot;, cl::init(false), cl::Hidden, cl::desc(&quot;Attempt to vectorize horizontal reductions feeding into a store&quot;))</td></tr>
<tr class="separator:acc49ed8e85692a2ddd2007dcd4f283b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc59529b0ce5da6b39838c2bc79556e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a5bc59529b0ce5da6b39838c2bc79556e">MaxVectorRegSizeOption</a> (&quot;slp-max-reg-size&quot;, cl::init(128), cl::Hidden, cl::desc(&quot;Attempt to vectorize for this register size in bits&quot;))</td></tr>
<tr class="separator:a5bc59529b0ce5da6b39838c2bc79556e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d70d1e3c4fc05998ae502e5cc9831ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a1d70d1e3c4fc05998ae502e5cc9831ea">ScheduleRegionSizeBudget</a> (&quot;slp-schedule-budget&quot;, cl::init(100000), cl::Hidden, cl::desc(&quot;Limit the size of the SLP scheduling region per block&quot;))</td></tr>
<tr class="memdesc:a1d70d1e3c4fc05998ae502e5cc9831ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limits the size of scheduling regions in a block.  <a href="SLPVectorizer_8cpp.html#a1d70d1e3c4fc05998ae502e5cc9831ea">More...</a><br /></td></tr>
<tr class="separator:a1d70d1e3c4fc05998ae502e5cc9831ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad694e5f5d4e351bd1ab0fa825e6ae319"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#ad694e5f5d4e351bd1ab0fa825e6ae319">MinVectorRegSizeOption</a> (&quot;slp-min-reg-size&quot;, cl::init(128), cl::Hidden, cl::desc(&quot;Attempt to vectorize for this register size in bits&quot;))</td></tr>
<tr class="separator:ad694e5f5d4e351bd1ab0fa825e6ae319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af496ac4d91174633d3f1a6794d03603d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#af496ac4d91174633d3f1a6794d03603d">RecursionMaxDepth</a> (&quot;slp-<a class="el" href="DeadArgumentElimination_8cpp.html#a05fa3b6b6c6cbc0732f37d9953bdf480">recursion</a>-max-depth&quot;, cl::init(12), cl::Hidden, cl::desc(&quot;Limit the <a class="el" href="DeadArgumentElimination_8cpp.html#a05fa3b6b6c6cbc0732f37d9953bdf480">recursion</a> depth when building a vectorizable tree&quot;))</td></tr>
<tr class="separator:af496ac4d91174633d3f1a6794d03603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01b22e2be5259649042e2da6818a292"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#af01b22e2be5259649042e2da6818a292">MinTreeSize</a> (&quot;slp-min-tree-size&quot;, cl::init(3), cl::Hidden, cl::desc(&quot;Only vectorize small trees <a class="el" href="DeadArgumentElimination_8cpp.html#ac09a30d47dd36dfe05dda91e8d67e92f">if</a> they are fully vectorizable&quot;))</td></tr>
<tr class="separator:af01b22e2be5259649042e2da6818a292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a83f669bc1ecf94617c7451936421de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a8a83f669bc1ecf94617c7451936421de">ViewSLPTree</a> (&quot;view-slp-tree&quot;, cl::Hidden, cl::desc(&quot;Display the SLP trees with Graphviz&quot;))</td></tr>
<tr class="separator:a8a83f669bc1ecf94617c7451936421de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc15b8825f5e5c6718e7f19a5094f55"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#adcc15b8825f5e5c6718e7f19a5094f55">isValidElementType</a> (Type *Ty)</td></tr>
<tr class="memdesc:adcc15b8825f5e5c6718e7f19a5094f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for the element types that the SLP vectorizer supports.  <a href="SLPVectorizer_8cpp.html#adcc15b8825f5e5c6718e7f19a5094f55">More...</a><br /></td></tr>
<tr class="separator:adcc15b8825f5e5c6718e7f19a5094f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5114d6b451e9ca85a36fc3f19f76c4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#abd5114d6b451e9ca85a36fc3f19f76c4">allSameBlock</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt; VL)</td></tr>
<tr class="separator:abd5114d6b451e9ca85a36fc3f19f76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7568c08b526dbf7f7b5402f3eb605b55"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a7568c08b526dbf7f7b5402f3eb605b55">allConstant</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt; VL)</td></tr>
<tr class="separator:a7568c08b526dbf7f7b5402f3eb605b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef5b86735d738868e5fb00a18643b1c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a6ef5b86735d738868e5fb00a18643b1c">isSplat</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt; VL)</td></tr>
<tr class="separator:a6ef5b86735d738868e5fb00a18643b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0da56db6da27340e5a7151a4676106a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#ab0da56db6da27340e5a7151a4676106a">isCommutative</a> (Instruction *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="separator:ab0da56db6da27340e5a7151a4676106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff001ae4bec33ac20922ab80b0d2da2"><td class="memItemLeft" align="right" valign="top">static Optional&lt; TargetTransformInfo::ShuffleKind &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a4ff001ae4bec33ac20922ab80b0d2da2">isShuffle</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt; VL)</td></tr>
<tr class="memdesc:a4ff001ae4bec33ac20922ab80b0d2da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vector of instructions can be represented as a shuffle, like: x0 = extractelement &lt;4 x i8&gt; x, i32 0 x3 = extractelement &lt;4 x i8&gt; x, i32 3 y1 = extractelement &lt;4 x i8&gt; y, i32 1 y2 = extractelement &lt;4 x i8&gt; y, i32 2 x0x0 = mul i8 x0, x0 x3x3 = mul i8 x3, x3 y1y1 = mul i8 y1, y1 y2y2 = mul i8 y2, y2 ins1 = insertelement &lt;4 x i8&gt; undef, i8 x0x0, i32 0 ins2 = insertelement &lt;4 x i8&gt; ins1, i8 x3x3, i32 1 ins3 = insertelement &lt;4 x i8&gt; ins2, i8 y1y1, i32 2 ins4 = insertelement &lt;4 x i8&gt; ins3, i8 y2y2, i32 3 ret &lt;4 x i8&gt; ins4 can be transformed into: %1 = shufflevector &lt;4 x i8&gt; x, &lt;4 x i8&gt; y, &lt;4 x i32&gt; &lt;i32 0, i32 3, i32 5, i32 6&gt; %2 = mul &lt;4 x i8&gt; %1, %1 ret &lt;4 x i8&gt; %2 We convert this initially to something like: x0 = extractelement &lt;4 x i8&gt; x, i32 0 x3 = extractelement &lt;4 x i8&gt; x, i32 3 y1 = extractelement &lt;4 x i8&gt; y, i32 1 y2 = extractelement &lt;4 x i8&gt; y, i32 2 %1 = insertelement &lt;4 x i8&gt; undef, i8 x0, i32 0 %2 = insertelement &lt;4 x i8&gt; %1, i8 x3, i32 1 %3 = insertelement &lt;4 x i8&gt; %2, i8 y1, i32 2 %4 = insertelement &lt;4 x i8&gt; %3, i8 y2, i32 3 %5 = mul &lt;4 x i8&gt; %4, %4 %6 = extractelement &lt;4 x i8&gt; %5, i32 0 ins1 = insertelement &lt;4 x i8&gt; undef, i8 %6, i32 0 %7 = extractelement &lt;4 x i8&gt; %5, i32 1 ins2 = insertelement &lt;4 x i8&gt; ins1, i8 %7, i32 1 %8 = extractelement &lt;4 x i8&gt; %5, i32 2 ins3 = insertelement &lt;4 x i8&gt; ins2, i8 %8, i32 2 %9 = extractelement &lt;4 x i8&gt; %5, i32 3 ins4 = insertelement &lt;4 x i8&gt; ins3, i8 %9, i32 3 ret &lt;4 x i8&gt; ins4 InstCombiner transforms this into a shuffle and vector mul TODO: Can we split off and reuse the shuffle mask detection from TargetTransformInfo::getInstructionThroughput?  <a href="SLPVectorizer_8cpp.html#a4ff001ae4bec33ac20922ab80b0d2da2">More...</a><br /></td></tr>
<tr class="separator:a4ff001ae4bec33ac20922ab80b0d2da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119e14ec060ce3f75acefac34c082bad"><td class="memItemLeft" align="right" valign="top">static Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a119e14ec060ce3f75acefac34c082bad">isOneOf</a> (const InstructionsState &amp;S, Value *Op)</td></tr>
<tr class="memdesc:a119e14ec060ce3f75acefac34c082bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses the correct key for scheduling data.  <a href="SLPVectorizer_8cpp.html#a119e14ec060ce3f75acefac34c082bad">More...</a><br /></td></tr>
<tr class="separator:a119e14ec060ce3f75acefac34c082bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ac13de9baf57a57ba81c1b50c059dd"><td class="memItemLeft" align="right" valign="top">static InstructionsState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a15ac13de9baf57a57ba81c1b50c059dd">getSameOpcode</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt; VL, unsigned BaseIndex=0)</td></tr>
<tr class="separator:a15ac13de9baf57a57ba81c1b50c059dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfbce373feafd33ca9e104d8b164ece"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#aabfbce373feafd33ca9e104d8b164ece">allSameType</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt; VL)</td></tr>
<tr class="separator:aabfbce373feafd33ca9e104d8b164ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d601336b82553eb938d1f15351c8ce5"><td class="memItemLeft" align="right" valign="top">static Optional&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a4d601336b82553eb938d1f15351c8ce5">getExtractIndex</a> (Instruction *E)</td></tr>
<tr class="separator:a4d601336b82553eb938d1f15351c8ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebd06edd5d7c956687d26be5c6040c1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#afebd06edd5d7c956687d26be5c6040c1">InTreeUserNeedToExtract</a> (Value *Scalar, Instruction *UserInst, TargetLibraryInfo *TLI)</td></tr>
<tr class="separator:afebd06edd5d7c956687d26be5c6040c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd468738cbcd26ce7a75f2fa361790c"><td class="memItemLeft" align="right" valign="top">static MemoryLocation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a0cd468738cbcd26ce7a75f2fa361790c">getLocation</a> (Instruction *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, AliasAnalysis *AA)</td></tr>
<tr class="separator:a0cd468738cbcd26ce7a75f2fa361790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca9742688618517cc4690fb947fb609"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a3ca9742688618517cc4690fb947fb609">isSimple</a> (Instruction *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="separator:a3ca9742688618517cc4690fb947fb609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18d96e97f0982c1fab5896d31597746"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#ac18d96e97f0982c1fab5896d31597746">inversePermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; Indices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;Mask)</td></tr>
<tr class="separator:ac18d96e97f0982c1fab5896d31597746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3b8b509fcb2a84e3b9e3bd678ba27f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#ada3b8b509fcb2a84e3b9e3bd678ba27f">collectValuesToDemote</a> (Value *V, SmallPtrSetImpl&lt; Value * &gt; &amp;Expr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Value * &gt; &amp;ToDemote, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Value * &gt; &amp;Roots)</td></tr>
<tr class="separator:ada3b8b509fcb2a84e3b9e3bd678ba27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fcf5774db6a4f0b2eb38567f52fe86"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a45fcf5774db6a4f0b2eb38567f52fe86">hasValueBeenRAUWed</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt; VL, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; WeakTrackingVH &gt; VH, unsigned SliceBegin, unsigned SliceSize)</td></tr>
<tr class="memdesc:a45fcf5774db6a4f0b2eb38567f52fe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the Values in the slice in VL array are still existent in the WeakTrackingVH array.  <a href="SLPVectorizer_8cpp.html#a45fcf5774db6a4f0b2eb38567f52fe86">More...</a><br /></td></tr>
<tr class="separator:a45fcf5774db6a4f0b2eb38567f52fe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0edda58e11d0c9ba6d6e0f21cfdc3fe"><td class="memItemLeft" align="right" valign="top">static Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#ab0edda58e11d0c9ba6d6e0f21cfdc3fe">createRdxShuffleMask</a> (unsigned VecLen, unsigned NumEltsToRdx, bool IsPairwise, bool IsLeft, IRBuilder&lt;&gt; &amp;Builder)</td></tr>
<tr class="memdesc:ab0edda58e11d0c9ba6d6e0f21cfdc3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a shuffle mask to be used in a reduction tree.  <a href="SLPVectorizer_8cpp.html#ab0edda58e11d0c9ba6d6e0f21cfdc3fe">More...</a><br /></td></tr>
<tr class="separator:ab0edda58e11d0c9ba6d6e0f21cfdc3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b0618c25fd2d2573d9b2de94585020"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a76b0618c25fd2d2573d9b2de94585020">findBuildVector</a> (InsertElementInst *LastInsertElem, TargetTransformInfo *TTI, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Value * &gt; &amp;BuildVectorOpds, int &amp;UserCost)</td></tr>
<tr class="memdesc:a76b0618c25fd2d2573d9b2de94585020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recognize construction of vectors like ra = insertelement &lt;4 x float&gt; undef, float s0, i32 0 rb = insertelement &lt;4 x float&gt; ra, float s1, i32 1 rc = insertelement &lt;4 x float&gt; rb, float s2, i32 2 rd = insertelement &lt;4 x float&gt; rc, float s3, i32 3 starting from the last insertelement instruction.  <a href="SLPVectorizer_8cpp.html#a76b0618c25fd2d2573d9b2de94585020">More...</a><br /></td></tr>
<tr class="separator:a76b0618c25fd2d2573d9b2de94585020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f4407185ff51e0bb91bda924d6750c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#af4f4407185ff51e0bb91bda924d6750c">findBuildAggregate</a> (InsertValueInst *IV, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Value * &gt; &amp;BuildVectorOpds)</td></tr>
<tr class="memdesc:af4f4407185ff51e0bb91bda924d6750c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like findBuildVector, but looks for construction of aggregate.  <a href="SLPVectorizer_8cpp.html#af4f4407185ff51e0bb91bda924d6750c">More...</a><br /></td></tr>
<tr class="separator:af4f4407185ff51e0bb91bda924d6750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3361ac29f4340e5920aa8285320536c6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a3361ac29f4340e5920aa8285320536c6">PhiTypeSorterFunc</a> (Value *V, Value *V2)</td></tr>
<tr class="separator:a3361ac29f4340e5920aa8285320536c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea28c0fb124d7a75dc182a7f7010655"><td class="memItemLeft" align="right" valign="top">static Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#adea28c0fb124d7a75dc182a7f7010655">getReductionValue</a> (const DominatorTree *DT, PHINode *<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, BasicBlock *ParentBB, LoopInfo *LI)</td></tr>
<tr class="memdesc:adea28c0fb124d7a75dc182a7f7010655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try and get a reduction value from a phi node.  <a href="SLPVectorizer_8cpp.html#adea28c0fb124d7a75dc182a7f7010655">More...</a><br /></td></tr>
<tr class="separator:adea28c0fb124d7a75dc182a7f7010655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87767111a82c8278e09d73ed639e21fc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a87767111a82c8278e09d73ed639e21fc">tryToVectorizeHorReductionOrInstOperands</a> (PHINode *<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, Instruction *Root, BasicBlock *BB, <a class="el" href="classllvm_1_1slpvectorizer_1_1BoUpSLP.html">BoUpSLP</a> &amp;R, TargetTransformInfo *TTI, const function_ref&lt; bool(Instruction *, <a class="el" href="classllvm_1_1slpvectorizer_1_1BoUpSLP.html">BoUpSLP</a> &amp;)&gt; Vectorize)</td></tr>
<tr class="memdesc:a87767111a82c8278e09d73ed639e21fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to reduce a horizontal reduction.  <a href="SLPVectorizer_8cpp.html#a87767111a82c8278e09d73ed639e21fc">More...</a><br /></td></tr>
<tr class="separator:a87767111a82c8278e09d73ed639e21fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9d624115133c3a9ac3109be4be89a32f"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a9d624115133c3a9ac3109be4be89a32f">AliasedCheckLimit</a> = 10</td></tr>
<tr class="separator:a9d624115133c3a9ac3109be4be89a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce8fdf40e75ddf217650e2b1b15b5e6"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a4ce8fdf40e75ddf217650e2b1b15b5e6">MaxMemDepDistance</a> = 160</td></tr>
<tr class="separator:a4ce8fdf40e75ddf217650e2b1b15b5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d78104bfada8d17dad04e588b7d9a17"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a3d78104bfada8d17dad04e588b7d9a17">MinScheduleRegionSize</a> = 16</td></tr>
<tr class="memdesc:a3d78104bfada8d17dad04e588b7d9a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the ScheduleRegionSizeBudget is exhausted, we allow small scheduling regions to be handled.  <a href="SLPVectorizer_8cpp.html#a3d78104bfada8d17dad04e588b7d9a17">More...</a><br /></td></tr>
<tr class="separator:a3d78104bfada8d17dad04e588b7d9a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce679c74f9d5aa21d8ea3d1a798f0a9"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SLPVectorizer_8cpp.html#a5ce679c74f9d5aa21d8ea3d1a798f0a9">lv_name</a> [] = &quot;SLP Vectorizer&quot;</td></tr>
<tr class="separator:a5ce679c74f9d5aa21d8ea3d1a798f0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;SLP&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00104">104</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="a274654b7f5932cae6a71a113322481be" name="a274654b7f5932cae6a71a113322481be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274654b7f5932cae6a71a113322481be">&#9670;&nbsp;</a></span>SV_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SV_NAME&#160;&#160;&#160;&quot;slp-vectorizer&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00103">103</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7568c08b526dbf7f7b5402f3eb605b55" name="a7568c08b526dbf7f7b5402f3eb605b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7568c08b526dbf7f7b5402f3eb605b55">&#9670;&nbsp;</a></span>allConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool allConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt;&#160;</td>
          <td class="paramname"><em>VL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if all of the values in <code>VL</code> are constants. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00198">198</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="abd5114d6b451e9ca85a36fc3f19f76c4" name="abd5114d6b451e9ca85a36fc3f19f76c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5114d6b451e9ca85a36fc3f19f76c4">&#9670;&nbsp;</a></span>allSameBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool allSameBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt;&#160;</td>
          <td class="paramname"><em>VL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all of the instructions in <code>VL</code> are in the same block or false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00181">181</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="aabfbce373feafd33ca9e104d8b164ece" name="aabfbce373feafd33ca9e104d8b164ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfbce373feafd33ca9e104d8b164ece">&#9670;&nbsp;</a></span>allSameType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool allSameType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt;&#160;</td>
          <td class="paramname"><em>VL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all of the values in <code>VL</code> have the same type or false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00407">407</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l01954">llvm::slpvectorizer::BoUpSLP::buildTree()</a>.</p>

</div>
</div>
<a id="ada3b8b509fcb2a84e3b9e3bd678ba27f" name="ada3b8b509fcb2a84e3b9e3bd678ba27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3b8b509fcb2a84e3b9e3bd678ba27f">&#9670;&nbsp;</a></span>collectValuesToDemote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool collectValuesToDemote </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmallPtrSetImpl&lt; Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ToDemote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l04754">4754</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="SLPVectorizer_8cpp_source.html#l04754">collectValuesToDemote()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l04754">collectValuesToDemote()</a>, and <a class="el" href="SLPVectorizer_8cpp_source.html#l04822">llvm::slpvectorizer::BoUpSLP::computeMinimumValueSizes()</a>.</p>

</div>
</div>
<a id="ab0edda58e11d0c9ba6d6e0f21cfdc3fe" name="ab0edda58e11d0c9ba6d6e0f21cfdc3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0edda58e11d0c9ba6d6e0f21cfdc3fe">&#9670;&nbsp;</a></span>createRdxShuffleMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value * createRdxShuffleMask </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>VecLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>NumEltsToRdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IsPairwise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IsLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a shuffle mask to be used in a reduction tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VecLen</td><td>The length of the vector to be reduced. </td></tr>
    <tr><td class="paramname">NumEltsToRdx</td><td>The number of elements that should be reduced in the vector. </td></tr>
    <tr><td class="paramname">IsPairwise</td><td>Whether the reduction is a pairwise or splitting reduction. A pairwise reduction will generate a mask of &lt;0,2,...&gt; or &lt;1,3,..&gt; while a splitting reduction will generate &lt;2,3, undef,undef&gt; for a vector of 4 and NumElts = 2. </td></tr>
    <tr><td class="paramname">IsLeft</td><td>True will generate a mask of even elements, odd otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l05471">5471</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>.</p>

</div>
</div>
<a id="af4f4407185ff51e0bb91bda924d6750c" name="af4f4407185ff51e0bb91bda924d6750c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f4407185ff51e0bb91bda924d6750c">&#9670;&nbsp;</a></span>findBuildAggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool findBuildAggregate </td>
          <td>(</td>
          <td class="paramtype">InsertValueInst *&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>BuildVectorOpds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like findBuildVector, but looks for construction of aggregate. </p>
<dl class="section return"><dt>Returns</dt><dd>true if it matches. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l06430">6430</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="a76b0618c25fd2d2573d9b2de94585020" name="a76b0618c25fd2d2573d9b2de94585020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b0618c25fd2d2573d9b2de94585020">&#9670;&nbsp;</a></span>findBuildVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool findBuildVector </td>
          <td>(</td>
          <td class="paramtype">InsertElementInst *&#160;</td>
          <td class="paramname"><em>LastInsertElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TargetTransformInfo *&#160;</td>
          <td class="paramname"><em>TTI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>BuildVectorOpds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>UserCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recognize construction of vectors like ra = insertelement &lt;4 x float&gt; undef, float s0, i32 0 rb = insertelement &lt;4 x float&gt; ra, float s1, i32 1 rc = insertelement &lt;4 x float&gt; rb, float s2, i32 2 rd = insertelement &lt;4 x float&gt; rc, float s3, i32 3 starting from the last insertelement instruction. </p>
<p >Returns true if it matches </p>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l06403">6403</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="a4d601336b82553eb938d1f15351c8ce5" name="a4d601336b82553eb938d1f15351c8ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d601336b82553eb938d1f15351c8ce5">&#9670;&nbsp;</a></span>getExtractIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; unsigned &gt; getExtractIndex </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if Extract{Value,Element} instruction extracts element Idx. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00417">417</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>.</p>

</div>
</div>
<a id="a0cd468738cbcd26ce7a75f2fa361790c" name="a0cd468738cbcd26ce7a75f2fa361790c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd468738cbcd26ce7a75f2fa361790c">&#9670;&nbsp;</a></span>getLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemoryLocation getLocation </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AliasAnalysis *&#160;</td>
          <td class="paramname"><em>AA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the AA location that is being access by the instruction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00463">463</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="adea28c0fb124d7a75dc182a7f7010655" name="adea28c0fb124d7a75dc182a7f7010655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea28c0fb124d7a75dc182a7f7010655">&#9670;&nbsp;</a></span>getReductionValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value * getReductionValue </td>
          <td>(</td>
          <td class="paramtype">const DominatorTree *&#160;</td>
          <td class="paramname"><em>DT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PHINode *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>ParentBB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopInfo *&#160;</td>
          <td class="paramname"><em>LI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try and get a reduction value from a phi node. </p>
<p >Given a phi node <code>P</code> in a block <code>ParentBB</code>, consider possible reductions if they come from either <code>ParentBB</code> or a containing loop latch.</p>
<dl class="section return"><dt>Returns</dt><dd>A candidate reduction value if possible, or <div class="fragment"><div class="line"><span class="keyword">nullptr</span> </div>
</div><!-- fragment --> if not possible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l06457">6457</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

</div>
</div>
<a id="a15ac13de9baf57a57ba81c1b50c059dd" name="a15ac13de9baf57a57ba81c1b50c059dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ac13de9baf57a57ba81c1b50c059dd">&#9670;&nbsp;</a></span>getSameOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static InstructionsState getSameOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt;&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>BaseIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>analysis of the Instructions in <code>VL</code> described in InstructionsState, the Opcode that we suppose the whole list could be vectorized even if its structure is diverse. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00360">360</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="a45fcf5774db6a4f0b2eb38567f52fe86" name="a45fcf5774db6a4f0b2eb38567f52fe86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fcf5774db6a4f0b2eb38567f52fe86">&#9670;&nbsp;</a></span>hasValueBeenRAUWed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasValueBeenRAUWed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt;&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; WeakTrackingVH &gt;&#160;</td>
          <td class="paramname"><em>VH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SliceBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SliceSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the Values in the slice in VL array are still existent in the WeakTrackingVH array. </p>
<p >Vectorization of part of the VL array may cause later values in the VL array to become invalid. We track when this has happened in the WeakTrackingVH array. </p>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l05108">5108</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="afebd06edd5d7c956687d26be5c6040c1" name="afebd06edd5d7c956687d26be5c6040c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebd06edd5d7c956687d26be5c6040c1">&#9670;&nbsp;</a></span>InTreeUserNeedToExtract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool InTreeUserNeedToExtract </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>UserInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TargetLibraryInfo *&#160;</td>
          <td class="paramname"><em>TLI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if in-tree use also needs extract. This refers to possible scalar operand in vectorized instruction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00436">436</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l01954">llvm::slpvectorizer::BoUpSLP::buildTree()</a>.</p>

</div>
</div>
<a id="ac18d96e97f0982c1fab5896d31597746" name="ac18d96e97f0982c1fab5896d31597746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18d96e97f0982c1fab5896d31597746">&#9670;&nbsp;</a></span>inversePermutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void inversePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l03480">3480</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="ab0da56db6da27340e5a7151a4676106a" name="ab0da56db6da27340e5a7151a4676106a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0da56db6da27340e5a7151a4676106a">&#9670;&nbsp;</a></span>isCommutative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isCommutative </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if <code>I</code> is commutative, handles CmpInst as well as Instruction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00214">214</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a119e14ec060ce3f75acefac34c082bad" name="a119e14ec060ce3f75acefac34c082bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119e14ec060ce3f75acefac34c082bad">&#9670;&nbsp;</a></span>isOneOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value * isOneOf </td>
          <td>(</td>
          <td class="paramtype">const InstructionsState &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>Op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses the correct key for scheduling data. </p>
<p >If <code>Op</code> has the same (or alternate) opcode as <code>OpValue</code>, the key is <code>Op</code>. Otherwise the key is <code>OpValue</code>. </p>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00350">350</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a4ff001ae4bec33ac20922ab80b0d2da2" name="a4ff001ae4bec33ac20922ab80b0d2da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff001ae4bec33ac20922ab80b0d2da2">&#9670;&nbsp;</a></span>isShuffle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; TargetTransformInfo::ShuffleKind &gt; isShuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt;&#160;</td>
          <td class="paramname"><em>VL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vector of instructions can be represented as a shuffle, like: x0 = extractelement &lt;4 x i8&gt; x, i32 0 x3 = extractelement &lt;4 x i8&gt; x, i32 3 y1 = extractelement &lt;4 x i8&gt; y, i32 1 y2 = extractelement &lt;4 x i8&gt; y, i32 2 x0x0 = mul i8 x0, x0 x3x3 = mul i8 x3, x3 y1y1 = mul i8 y1, y1 y2y2 = mul i8 y2, y2 ins1 = insertelement &lt;4 x i8&gt; undef, i8 x0x0, i32 0 ins2 = insertelement &lt;4 x i8&gt; ins1, i8 x3x3, i32 1 ins3 = insertelement &lt;4 x i8&gt; ins2, i8 y1y1, i32 2 ins4 = insertelement &lt;4 x i8&gt; ins3, i8 y2y2, i32 3 ret &lt;4 x i8&gt; ins4 can be transformed into: %1 = shufflevector &lt;4 x i8&gt; x, &lt;4 x i8&gt; y, &lt;4 x i32&gt; &lt;i32 0, i32 3, i32 5, i32 6&gt; %2 = mul &lt;4 x i8&gt; %1, %1 ret &lt;4 x i8&gt; %2 We convert this initially to something like: x0 = extractelement &lt;4 x i8&gt; x, i32 0 x3 = extractelement &lt;4 x i8&gt; x, i32 3 y1 = extractelement &lt;4 x i8&gt; y, i32 1 y2 = extractelement &lt;4 x i8&gt; y, i32 2 %1 = insertelement &lt;4 x i8&gt; undef, i8 x0, i32 0 %2 = insertelement &lt;4 x i8&gt; %1, i8 x3, i32 1 %3 = insertelement &lt;4 x i8&gt; %2, i8 y1, i32 2 %4 = insertelement &lt;4 x i8&gt; %3, i8 y2, i32 3 %5 = mul &lt;4 x i8&gt; %4, %4 %6 = extractelement &lt;4 x i8&gt; %5, i32 0 ins1 = insertelement &lt;4 x i8&gt; undef, i8 %6, i32 0 %7 = extractelement &lt;4 x i8&gt; %5, i32 1 ins2 = insertelement &lt;4 x i8&gt; ins1, i8 %7, i32 1 %8 = extractelement &lt;4 x i8&gt; %5, i32 2 ins3 = insertelement &lt;4 x i8&gt; ins2, i8 %8, i32 2 %9 = extractelement &lt;4 x i8&gt; %5, i32 3 ins4 = insertelement &lt;4 x i8&gt; ins3, i8 %9, i32 3 ret &lt;4 x i8&gt; ins4 InstCombiner transforms this into a shuffle and vector mul TODO: Can we split off and reuse the shuffle mask detection from TargetTransformInfo::getInstructionThroughput? </p>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00262">262</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00342">Idx</a>, and <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>.</p>

</div>
</div>
<a id="a3ca9742688618517cc4690fb947fb609" name="a3ca9742688618517cc4690fb947fb609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca9742688618517cc4690fb947fb609">&#9670;&nbsp;</a></span>isSimple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isSimple </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the instruction is not a volatile or atomic load/store. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00472">472</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="DomPrinter_8cpp_source.html#l00033">llvm::DOTGraphTraits&lt; DomTreeNode * &gt;::getNodeLabel()</a>, and <a class="el" href="RegionPrinter_8cpp_source.html#l00043">llvm::DOTGraphTraits&lt; RegionNode * &gt;::getNodeLabel()</a>.</p>

</div>
</div>
<a id="a6ef5b86735d738868e5fb00a18643b1c" name="a6ef5b86735d738868e5fb00a18643b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef5b86735d738868e5fb00a18643b1c">&#9670;&nbsp;</a></span>isSplat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isSplat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; Value * &gt;&#160;</td>
          <td class="paramname"><em>VL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if all of the values in <code>VL</code> are identical. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00206">206</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l01920">llvm::DOTGraphTraits&lt; BoUpSLP * &gt;::getNodeLabel()</a>, and <a class="el" href="InstCombineVectorOps_8cpp_source.html#l01752">llvm::InstCombiner::visitShuffleVectorInst()</a>.</p>

</div>
</div>
<a id="adcc15b8825f5e5c6718e7f19a5094f55" name="adcc15b8825f5e5c6718e7f19a5094f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc15b8825f5e5c6718e7f19a5094f55">&#9670;&nbsp;</a></span>isValidElementType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PointerType::isValidElementType </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>Ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate for the element types that the SLP vectorizer supports. </p>
<p >The most important thing to filter here are types which are invalid in LLVM vectors. We also filter target specific types which have absolutely no meaningful vectorization path such as x86_fp80 and ppc_f128. This just avoids spending time checking the cost model and realizing that they will be inevitably scalarized. </p>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00174">174</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l02612">llvm::slpvectorizer::BoUpSLP::canMapToVector()</a>.</p>

</div>
</div>
<a id="a5bc59529b0ce5da6b39838c2bc79556e" name="a5bc59529b0ce5da6b39838c2bc79556e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc59529b0ce5da6b39838c2bc79556e">&#9670;&nbsp;</a></span>MaxVectorRegSizeOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; int &gt; MaxVectorRegSizeOption </td>
          <td>(</td>
          <td class="paramtype">&quot;slp-max-reg-size&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(128)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Attempt to vectorize for this register size in bits&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l00498">llvm::slpvectorizer::BoUpSLP::BoUpSLP()</a>.</p>

</div>
</div>
<a id="af01b22e2be5259649042e2da6818a292" name="af01b22e2be5259649042e2da6818a292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01b22e2be5259649042e2da6818a292">&#9670;&nbsp;</a></span>MinTreeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MinTreeSize </td>
          <td>(</td>
          <td class="paramtype">&quot;slp-min-tree-size&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(3)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Only vectorize small trees <a class="el" href="DeadArgumentElimination_8cpp.html#ac09a30d47dd36dfe05dda91e8d67e92f">if</a> they are fully vectorizable&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l03101">llvm::slpvectorizer::BoUpSLP::isTreeTinyAndNotFullyVectorizable()</a>.</p>

</div>
</div>
<a id="ad694e5f5d4e351bd1ab0fa825e6ae319" name="ad694e5f5d4e351bd1ab0fa825e6ae319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad694e5f5d4e351bd1ab0fa825e6ae319">&#9670;&nbsp;</a></span>MinVectorRegSizeOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; int &gt; MinVectorRegSizeOption </td>
          <td>(</td>
          <td class="paramtype">&quot;slp-min-reg-size&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(128)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Attempt to vectorize for this register size in bits&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l00498">llvm::slpvectorizer::BoUpSLP::BoUpSLP()</a>.</p>

</div>
</div>
<a id="a3361ac29f4340e5920aa8285320536c6" name="a3361ac29f4340e5920aa8285320536c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3361ac29f4340e5920aa8285320536c6">&#9670;&nbsp;</a></span>PhiTypeSorterFunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PhiTypeSorterFunc </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l06446">6446</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="af496ac4d91174633d3f1a6794d03603d" name="af496ac4d91174633d3f1a6794d03603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af496ac4d91174633d3f1a6794d03603d">&#9670;&nbsp;</a></span>RecursionMaxDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; RecursionMaxDepth </td>
          <td>(</td>
          <td class="paramtype">&quot;slp-<a class="el" href="DeadArgumentElimination_8cpp.html#a05fa3b6b6c6cbc0732f37d9953bdf480">recursion</a>-max-depth&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(12)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Limit the <a class="el" href="DeadArgumentElimination_8cpp.html#a05fa3b6b6c6cbc0732f37d9953bdf480">recursion</a> depth when building a vectorizable tree&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l06512">tryToVectorizeHorReductionOrInstOperands()</a>.</p>

</div>
</div>
<a id="a1d70d1e3c4fc05998ae502e5cc9831ea" name="a1d70d1e3c4fc05998ae502e5cc9831ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d70d1e3c4fc05998ae502e5cc9831ea">&#9670;&nbsp;</a></span>ScheduleRegionSizeBudget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; int &gt; ScheduleRegionSizeBudget </td>
          <td>(</td>
          <td class="paramtype">&quot;slp-schedule-budget&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(100000)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Limit the size of the SLP scheduling region per block&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Limits the size of scheduling regions in a block. </p>
<p >It avoid long compile times for <em>very</em> large blocks where vector instructions are spread over a wide range. This limit is way higher than needed by real-world functions. </p>

</div>
</div>
<a id="acc49ed8e85692a2ddd2007dcd4f283b6" name="acc49ed8e85692a2ddd2007dcd4f283b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc49ed8e85692a2ddd2007dcd4f283b6">&#9670;&nbsp;</a></span>ShouldStartVectorizeHorAtStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt; ShouldStartVectorizeHorAtStore </td>
          <td>(</td>
          <td class="paramtype">&quot;slp-vectorize-hor-store&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(false)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Attempt to vectorize horizontal reductions feeding into a store&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a990230d1fc14f4b06a496ff7a4b901fa" name="a990230d1fc14f4b06a496ff7a4b901fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990230d1fc14f4b06a496ff7a4b901fa">&#9670;&nbsp;</a></span>ShouldVectorizeHor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt; ShouldVectorizeHor </td>
          <td>(</td>
          <td class="paramtype">&quot;slp-vectorize-hor&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Attempt to vectorize horizontal reductions&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l06512">tryToVectorizeHorReductionOrInstOperands()</a>.</p>

</div>
</div>
<a id="a043a8336eb4f346f6cb7f88be4ed611c" name="a043a8336eb4f346f6cb7f88be4ed611c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043a8336eb4f346f6cb7f88be4ed611c">&#9670;&nbsp;</a></span>SLPCostThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; int &gt; SLPCostThreshold </td>
          <td>(</td>
          <td class="paramtype">&quot;slp-threshold&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(0)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Only vectorize <a class="el" href="DeadArgumentElimination_8cpp.html#ac09a30d47dd36dfe05dda91e8d67e92f">if</a> you gain more than this &quot; &quot;number &quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae36ebcd8ea18a5e24ffe0c11fb9e965f" name="ae36ebcd8ea18a5e24ffe0c11fb9e965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36ebcd8ea18a5e24ffe0c11fb9e965f">&#9670;&nbsp;</a></span>STATISTIC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumVectorInstructions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of vector <a class="el" href="InstructionCombining_8cpp.html#a9360db2a972441c49cdbbabb5b20cc27">instructions</a> generated&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87767111a82c8278e09d73ed639e21fc" name="a87767111a82c8278e09d73ed639e21fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87767111a82c8278e09d73ed639e21fc">&#9670;&nbsp;</a></span>tryToVectorizeHorReductionOrInstOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tryToVectorizeHorReductionOrInstOperands </td>
          <td>(</td>
          <td class="paramtype">PHINode *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>Root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>BB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1slpvectorizer_1_1BoUpSLP.html">BoUpSLP</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TargetTransformInfo *&#160;</td>
          <td class="paramname"><em>TTI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function_ref&lt; bool(Instruction *, <a class="el" href="classllvm_1_1slpvectorizer_1_1BoUpSLP.html">BoUpSLP</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Vectorize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to reduce a horizontal reduction. </p>
<p >If it is legal to match a horizontal reduction feeding the phi node <em>P</em> with reduction operators <em>Root</em> (or one of its operands) in a basic block <em>BB</em>, then check if it can be done. If horizontal reduction is not found and root instruction is a binary operation, vectorization of the operands is attempted. </p><dl class="section return"><dt>Returns</dt><dd>true if a horizontal reduction was matched and reduced or operands of one of the binary instruction were vectorized. </dd>
<dd>
false if a horizontal reduction was not matched (or not possible) or no vectorization of any binary operation feeding <em>Root</em> instruction was performed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l06512">6512</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="SLPVectorizer_8cpp.html#af496ac4d91174633d3f1a6794d03603d">RecursionMaxDepth()</a>, and <a class="el" href="SLPVectorizer_8cpp.html#a990230d1fc14f4b06a496ff7a4b901fa">ShouldVectorizeHor()</a>.</p>

</div>
</div>
<a id="a8a83f669bc1ecf94617c7451936421de" name="a8a83f669bc1ecf94617c7451936421de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a83f669bc1ecf94617c7451936421de">&#9670;&nbsp;</a></span>ViewSLPTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt; ViewSLPTree </td>
          <td>(</td>
          <td class="paramtype">&quot;view-slp-tree&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Display the SLP trees with Graphviz&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l03190">llvm::slpvectorizer::BoUpSLP::getTreeCost()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9d624115133c3a9ac3109be4be89a32f" name="a9d624115133c3a9ac3109be4be89a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d624115133c3a9ac3109be4be89a32f">&#9670;&nbsp;</a></span>AliasedCheckLimit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned AliasedCheckLimit = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00156">156</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="a5ce679c74f9d5aa21d8ea3d1a798f0a9" name="a5ce679c74f9d5aa21d8ea3d1a798f0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce679c74f9d5aa21d8ea3d1a798f0a9">&#9670;&nbsp;</a></span>lv_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char lv_name[] = &quot;SLP Vectorizer&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l06911">6911</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="a4ce8fdf40e75ddf217650e2b1b15b5e6" name="a4ce8fdf40e75ddf217650e2b1b15b5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce8fdf40e75ddf217650e2b1b15b5e6">&#9670;&nbsp;</a></span>MaxMemDepDistance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned MaxMemDepDistance = 160</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00161">161</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
<a id="a3d78104bfada8d17dad04e588b7d9a17" name="a3d78104bfada8d17dad04e588b7d9a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d78104bfada8d17dad04e588b7d9a17">&#9670;&nbsp;</a></span>MinScheduleRegionSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int MinScheduleRegionSize = 16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the ScheduleRegionSizeBudget is exhausted, we allow small scheduling regions to be handled. </p>

<p class="definition">Definition at line <a class="el" href="SLPVectorizer_8cpp_source.html#l00165">165</a> of file <a class="el" href="SLPVectorizer_8cpp_source.html">SLPVectorizer.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:44:45 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
