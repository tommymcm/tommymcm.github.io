<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/IR/ConstantFold.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_bfcfa2223a05221bedc89835a6573260.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ConstantFold.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ConstantFold_8h_source.html">ConstantFold.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/APSInt.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/IR/Constants.h&quot;</code><br />
<code>#include &quot;llvm/IR/DerivedTypes.h&quot;</code><br />
<code>#include &quot;llvm/IR/Function.h&quot;</code><br />
<code>#include &quot;llvm/IR/GetElementPtrTypeIterator.h&quot;</code><br />
<code>#include &quot;llvm/IR/GlobalAlias.h&quot;</code><br />
<code>#include &quot;llvm/IR/GlobalVariable.h&quot;</code><br />
<code>#include &quot;llvm/IR/Instructions.h&quot;</code><br />
<code>#include &quot;llvm/IR/Module.h&quot;</code><br />
<code>#include &quot;llvm/IR/Operator.h&quot;</code><br />
<code>#include &quot;llvm/IR/PatternMatch.h&quot;</code><br />
<code>#include &quot;llvm/Support/ErrorHandling.h&quot;</code><br />
<code>#include &quot;llvm/Support/ManagedStatic.h&quot;</code><br />
<code>#include &quot;llvm/Support/MathExtras.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ConstantFold.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="ConstantFold_8cpp__incl.png" border="0" usemap="#alib_2IR_2ConstantFold_8cpp" alt=""/></div>
<map name="alib_2IR_2ConstantFold_8cpp" id="alib_2IR_2ConstantFold_8cpp">
<area shape="rect" title=" " alt="" coords="1374,5,1545,31"/>
<area shape="rect" href="ConstantFold_8h.html" title=" " alt="" coords="23,86,141,111"/>
<area shape="rect" title=" " alt="" coords="165,86,305,111"/>
<area shape="rect" title=" " alt="" coords="329,86,504,111"/>
<area shape="rect" title=" " alt="" coords="529,86,678,111"/>
<area shape="rect" title=" " alt="" coords="703,86,875,111"/>
<area shape="rect" title=" " alt="" coords="899,86,1038,111"/>
<area shape="rect" title=" " alt="" coords="1062,79,1259,119"/>
<area shape="rect" title=" " alt="" coords="1284,86,1443,111"/>
<area shape="rect" title=" " alt="" coords="1467,86,1646,111"/>
<area shape="rect" title=" " alt="" coords="1670,86,1830,111"/>
<area shape="rect" title=" " alt="" coords="1855,86,1987,111"/>
<area shape="rect" title=" " alt="" coords="2011,86,2151,111"/>
<area shape="rect" title=" " alt="" coords="2175,86,2346,111"/>
<area shape="rect" title=" " alt="" coords="2370,86,2581,111"/>
<area shape="rect" title=" " alt="" coords="2605,86,2823,111"/>
<area shape="rect" title=" " alt="" coords="2847,86,3042,111"/>
<area shape="rect" title=" " alt="" coords="5,167,159,192"/>
</map>
</div>
</div>
<p><a href="ConstantFold_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab12afb6f2b1ebcdfd5bd5609210f4eb7"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#ab12afb6f2b1ebcdfd5bd5609210f4eb7">BitCastConstantVector</a> (Constant *CV, VectorType *DstTy)</td></tr>
<tr class="memdesc:ab12afb6f2b1ebcdfd5bd5609210f4eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the specified vector Constant node to the specified vector type.  <a href="ConstantFold_8cpp.html#ab12afb6f2b1ebcdfd5bd5609210f4eb7">More...</a><br /></td></tr>
<tr class="separator:ab12afb6f2b1ebcdfd5bd5609210f4eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c03a4228af93098afb6ab60e7283f6"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a08c03a4228af93098afb6ab60e7283f6">foldConstantCastPair</a> (unsigned opc, <a class="el" href="classConstantExpr.html">ConstantExpr</a> *Op, Type *DstTy)</td></tr>
<tr class="memdesc:a08c03a4228af93098afb6ab60e7283f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines which opcode to use to fold two constant cast expressions together.  <a href="ConstantFold_8cpp.html#a08c03a4228af93098afb6ab60e7283f6">More...</a><br /></td></tr>
<tr class="separator:a08c03a4228af93098afb6ab60e7283f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79061cbffefa2eccfe0d30d1c07eed78"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a79061cbffefa2eccfe0d30d1c07eed78">FoldBitCast</a> (Constant *V, Type *DestTy)</td></tr>
<tr class="separator:a79061cbffefa2eccfe0d30d1c07eed78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ef7500c855e3fc78f43b7766cb9808"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#ad7ef7500c855e3fc78f43b7766cb9808">ExtractConstantBytes</a> (Constant *C, unsigned ByteStart, unsigned ByteSize)</td></tr>
<tr class="memdesc:ad7ef7500c855e3fc78f43b7766cb9808"><td class="mdescLeft">&#160;</td><td class="mdescRight">V is an integer constant which only has a subset of its bytes used.  <a href="ConstantFold_8cpp.html#ad7ef7500c855e3fc78f43b7766cb9808">More...</a><br /></td></tr>
<tr class="separator:ad7ef7500c855e3fc78f43b7766cb9808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83475473710b8f5124ed99c5fea76c7b"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a83475473710b8f5124ed99c5fea76c7b">getFoldedSizeOf</a> (Type *Ty, Type *DestTy, bool Folded)</td></tr>
<tr class="memdesc:a83475473710b8f5124ed99c5fea76c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classConstantExpr.html">ConstantExpr</a> with type DestTy for sizeof on Ty, with any known factors factored out.  <a href="ConstantFold_8cpp.html#a83475473710b8f5124ed99c5fea76c7b">More...</a><br /></td></tr>
<tr class="separator:a83475473710b8f5124ed99c5fea76c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bddd6917afd7678549b4c4dce0b5771"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a8bddd6917afd7678549b4c4dce0b5771">getFoldedAlignOf</a> (Type *Ty, Type *DestTy, bool Folded)</td></tr>
<tr class="memdesc:a8bddd6917afd7678549b4c4dce0b5771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classConstantExpr.html">ConstantExpr</a> with type DestTy for alignof on Ty, with any known factors factored out.  <a href="ConstantFold_8cpp.html#a8bddd6917afd7678549b4c4dce0b5771">More...</a><br /></td></tr>
<tr class="separator:a8bddd6917afd7678549b4c4dce0b5771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5a81ce61f160fb6cbc0212d4fd2c4f"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#add5a81ce61f160fb6cbc0212d4fd2c4f">getFoldedOffsetOf</a> (Type *Ty, Constant *FieldNo, Type *DestTy, bool Folded)</td></tr>
<tr class="memdesc:add5a81ce61f160fb6cbc0212d4fd2c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classConstantExpr.html">ConstantExpr</a> with type DestTy for offsetof on Ty and FieldNo, with any known factors factored out.  <a href="ConstantFold_8cpp.html#add5a81ce61f160fb6cbc0212d4fd2c4f">More...</a><br /></td></tr>
<tr class="separator:add5a81ce61f160fb6cbc0212d4fd2c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7daa2bbd118fbf9d77a9efb61a2bff39"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a7daa2bbd118fbf9d77a9efb61a2bff39">isMaybeZeroSizedType</a> (Type *Ty)</td></tr>
<tr class="memdesc:a7daa2bbd118fbf9d77a9efb61a2bff39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type is zero-sized if it's an array or structure of zero-sized types.  <a href="ConstantFold_8cpp.html#a7daa2bbd118fbf9d77a9efb61a2bff39">More...</a><br /></td></tr>
<tr class="separator:a7daa2bbd118fbf9d77a9efb61a2bff39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5e52baf9c3773c59d6f09ef3bd4641"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a7a5e52baf9c3773c59d6f09ef3bd4641">IdxCompare</a> (Constant *C1, Constant *C2, Type *ElTy)</td></tr>
<tr class="memdesc:a7a5e52baf9c3773c59d6f09ef3bd4641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the two constants as though they were getelementptr indices.  <a href="ConstantFold_8cpp.html#a7a5e52baf9c3773c59d6f09ef3bd4641">More...</a><br /></td></tr>
<tr class="separator:a7a5e52baf9c3773c59d6f09ef3bd4641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492906941b2e0b27b8ef6cc54166103a"><td class="memItemLeft" align="right" valign="top">static FCmpInst::Predicate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a492906941b2e0b27b8ef6cc54166103a">evaluateFCmpRelation</a> (Constant *V1, Constant *V2)</td></tr>
<tr class="memdesc:a492906941b2e0b27b8ef6cc54166103a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines if there is anything we can decide about the two constants provided.  <a href="ConstantFold_8cpp.html#a492906941b2e0b27b8ef6cc54166103a">More...</a><br /></td></tr>
<tr class="separator:a492906941b2e0b27b8ef6cc54166103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc72eede9512ddb1764276cc197b4cb"><td class="memItemLeft" align="right" valign="top">static ICmpInst::Predicate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a3dc72eede9512ddb1764276cc197b4cb">areGlobalsPotentiallyEqual</a> (const GlobalValue *GV1, const GlobalValue *GV2)</td></tr>
<tr class="separator:a3dc72eede9512ddb1764276cc197b4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5dbef2b409d565ac01ea7cdde4017e"><td class="memItemLeft" align="right" valign="top">static ICmpInst::Predicate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a2c5dbef2b409d565ac01ea7cdde4017e">evaluateICmpRelation</a> (Constant *V1, Constant *V2, bool isSigned)</td></tr>
<tr class="memdesc:a2c5dbef2b409d565ac01ea7cdde4017e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines if there is anything we can decide about the two constants provided.  <a href="ConstantFold_8cpp.html#a2c5dbef2b409d565ac01ea7cdde4017e">More...</a><br /></td></tr>
<tr class="separator:a2c5dbef2b409d565ac01ea7cdde4017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1763d20509172e8577c019ee727ef1"><td class="memTemplParams" colspan="2">template&lt;typename IndexTy &gt; </td></tr>
<tr class="memitem:aaf1763d20509172e8577c019ee727ef1"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#aaf1763d20509172e8577c019ee727ef1">isInBoundsIndices</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; IndexTy &gt; Idxs)</td></tr>
<tr class="memdesc:aaf1763d20509172e8577c019ee727ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given sequence of <em>normalized</em> indices is "inbounds".  <a href="ConstantFold_8cpp.html#aaf1763d20509172e8577c019ee727ef1">More...</a><br /></td></tr>
<tr class="separator:aaf1763d20509172e8577c019ee727ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3d2d13dc400672038797a6fc50cd09"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ConstantFold_8cpp.html#a7d3d2d13dc400672038797a6fc50cd09">isIndexInRangeOfArrayType</a> (uint64_t NumElements, const ConstantInt *CI)</td></tr>
<tr class="memdesc:a7d3d2d13dc400672038797a6fc50cd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a given ConstantInt is in-range for a SequentialType.  <a href="ConstantFold_8cpp.html#a7d3d2d13dc400672038797a6fc50cd09">More...</a><br /></td></tr>
<tr class="separator:a7d3d2d13dc400672038797a6fc50cd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3dc72eede9512ddb1764276cc197b4cb" name="a3dc72eede9512ddb1764276cc197b4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc72eede9512ddb1764276cc197b4cb">&#9670;&nbsp;</a></span>areGlobalsPotentiallyEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ICmpInst::Predicate areGlobalsPotentiallyEqual </td>
          <td>(</td>
          <td class="paramtype">const GlobalValue *&#160;</td>
          <td class="paramname"><em>GV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GlobalValue *&#160;</td>
          <td class="paramname"><em>GV2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l01479">1479</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l01515">evaluateICmpRelation()</a>.</p>

</div>
</div>
<a id="ab12afb6f2b1ebcdfd5bd5609210f4eb7" name="ab12afb6f2b1ebcdfd5bd5609210f4eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12afb6f2b1ebcdfd5bd5609210f4eb7">&#9670;&nbsp;</a></span>BitCastConstantVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * BitCastConstantVector </td>
          <td>(</td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType *&#160;</td>
          <td class="paramname"><em>DstTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the specified vector Constant node to the specified vector type. </p>
<p >At this point, we know that the elements of the input vector constant are all simple integer or FP values. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00045">45</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l00101">FoldBitCast()</a>.</p>

</div>
</div>
<a id="a492906941b2e0b27b8ef6cc54166103a" name="a492906941b2e0b27b8ef6cc54166103a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492906941b2e0b27b8ef6cc54166103a">&#9670;&nbsp;</a></span>evaluateFCmpRelation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FCmpInst::Predicate evaluateFCmpRelation </td>
          <td>(</td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function determines if there is anything we can decide about the two constants provided. </p>
<p >This doesn't need to handle simple things like ConstantFP comparisons, but should instead handle ConstantExprs. If we can determine that the two constants have a particular relation to each other, we should return the corresponding FCmpInst predicate, otherwise return FCmpInst::BAD_FCMP_PREDICATE. This is used below in ConstantFoldCompareInstruction.</p>
<p >To simplify this code we canonicalize the relation so that the first operand is always the most "complex" of the two. We consider ConstantFP to be the simplest, and ConstantExprs to be the most complex. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l01426">1426</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l01426">evaluateFCmpRelation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l01765">llvm::ConstantFoldCompareInstruction()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l01426">evaluateFCmpRelation()</a>.</p>

</div>
</div>
<a id="a2c5dbef2b409d565ac01ea7cdde4017e" name="a2c5dbef2b409d565ac01ea7cdde4017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5dbef2b409d565ac01ea7cdde4017e">&#9670;&nbsp;</a></span>evaluateICmpRelation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ICmpInst::Predicate evaluateICmpRelation </td>
          <td>(</td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function determines if there is anything we can decide about the two constants provided. </p>
<p >This doesn't need to handle simple things like integer comparisons, but should instead handle ConstantExprs and GlobalValues. If we can determine that the two constants have a particular relation to each other, we should return the corresponding ICmp predicate, otherwise return ICmpInst::BAD_ICMP_PREDICATE.</p>
<p >To simplify this code we canonicalize the relation so that the first operand is always the most "complex" of the two. We consider simple constants (like ConstantInt) to be the simplest, followed by GlobalValues, followed by <a class="el" href="classConstantExpr.html">ConstantExpr</a>'s (the most complex). </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l01515">1515</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantFold_8cpp_source.html#l01479">areGlobalsPotentiallyEqual()</a>, <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ConstantFold_8cpp_source.html#l01515">evaluateICmpRelation()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l01382">IdxCompare()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l01765">llvm::ConstantFoldCompareInstruction()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l01515">evaluateICmpRelation()</a>.</p>

</div>
</div>
<a id="ad7ef7500c855e3fc78f43b7766cb9808" name="ad7ef7500c855e3fc78f43b7766cb9808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ef7500c855e3fc78f43b7766cb9808">&#9670;&nbsp;</a></span>ExtractConstantBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * ExtractConstantBytes </td>
          <td>(</td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ByteStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ByteSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>V is an integer constant which only has a subset of its bytes used. </p>
<p >The bytes used are indicated by ByteStart (which is the first byte used, counting from the least significant byte) and ByteSize, which is the number of bytes used.</p>
<p >This function analyzes the specified constant to see if the specified byte range can be returned as a simplified constant. If so, the constant is returned, otherwise null is returned. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00212">212</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l00212">ExtractConstantBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l00521">llvm::ConstantFoldCastInstruction()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l00212">ExtractConstantBytes()</a>.</p>

</div>
</div>
<a id="a79061cbffefa2eccfe0d30d1c07eed78" name="a79061cbffefa2eccfe0d30d1c07eed78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79061cbffefa2eccfe0d30d1c07eed78">&#9670;&nbsp;</a></span>FoldBitCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * FoldBitCast </td>
          <td>(</td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>DestTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00101">101</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l00045">BitCastConstantVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l00521">llvm::ConstantFoldCastInstruction()</a>.</p>

</div>
</div>
<a id="a08c03a4228af93098afb6ab60e7283f6" name="a08c03a4228af93098afb6ab60e7283f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c03a4228af93098afb6ab60e7283f6">&#9670;&nbsp;</a></span>foldConstantCastPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned foldConstantCastPair </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstantExpr.html">ConstantExpr</a> *&#160;</td>
          <td class="paramname"><em>Op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>DstTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function determines which opcode to use to fold two constant cast expressions together. </p>
<p >It uses CastInst::isEliminableCastPair to determine the opcode. Consequently its just a wrapper around that function. Determine if it is valid to fold a cast of a cast </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opc</td><td>opcode of the second cast constant expression</td></tr>
    <tr><td class="paramname">Op</td><td>the first cast constant expression</td></tr>
    <tr><td class="paramname">DstTy</td><td>destination type of the first cast </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00076">76</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l00521">llvm::ConstantFoldCastInstruction()</a>.</p>

</div>
</div>
<a id="a8bddd6917afd7678549b4c4dce0b5771" name="a8bddd6917afd7678549b4c4dce0b5771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bddd6917afd7678549b4c4dce0b5771">&#9670;&nbsp;</a></span>getFoldedAlignOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * getFoldedAlignOf </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>DestTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Folded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classConstantExpr.html">ConstantExpr</a> with type DestTy for alignof on Ty, with any known factors factored out. </p>
<p >If Folded is false, return null if no factoring was possible, to avoid endlessly bouncing an unfoldable expression back into the top-level folder. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00408">408</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantFold_8cpp_source.html#l00408">getFoldedAlignOf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l00521">llvm::ConstantFoldCastInstruction()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l00408">getFoldedAlignOf()</a>.</p>

</div>
</div>
<a id="add5a81ce61f160fb6cbc0212d4fd2c4f" name="add5a81ce61f160fb6cbc0212d4fd2c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5a81ce61f160fb6cbc0212d4fd2c4f">&#9670;&nbsp;</a></span>getFoldedOffsetOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * getFoldedOffsetOf </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>FieldNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>DestTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Folded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classConstantExpr.html">ConstantExpr</a> with type DestTy for offsetof on Ty and FieldNo, with any known factors factored out. </p>
<p >If Folded is false, return null if no factoring was possible, to avoid endlessly bouncing an unfoldable expression back into the top-level folder. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00472">472</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantFold_8cpp_source.html#l00353">getFoldedSizeOf()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l00521">llvm::ConstantFoldCastInstruction()</a>.</p>

</div>
</div>
<a id="a83475473710b8f5124ed99c5fea76c7b" name="a83475473710b8f5124ed99c5fea76c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83475473710b8f5124ed99c5fea76c7b">&#9670;&nbsp;</a></span>getFoldedSizeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * getFoldedSizeOf </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>DestTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Folded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classConstantExpr.html">ConstantExpr</a> with type DestTy for sizeof on Ty, with any known factors factored out. </p>
<p >If Folded is false, return null if no factoring was possible, to avoid endlessly bouncing an unfoldable expression back into the top-level folder. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l00353">353</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantFold_8cpp_source.html#l00353">getFoldedSizeOf()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l00521">llvm::ConstantFoldCastInstruction()</a>, <a class="el" href="ConstantFold_8cpp_source.html#l00472">getFoldedOffsetOf()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l00353">getFoldedSizeOf()</a>.</p>

</div>
</div>
<a id="a7a5e52baf9c3773c59d6f09ef3bd4641" name="a7a5e52baf9c3773c59d6f09ef3bd4641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5e52baf9c3773c59d6f09ef3bd4641">&#9670;&nbsp;</a></span>IdxCompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int IdxCompare </td>
          <td>(</td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>C1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>C2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ElTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the two constants as though they were getelementptr indices. </p>
<p >This allows coercion of the types to be the same thing.</p>
<p >If the two constants are the "same" (after coercion), return 0. If the first is less than the second, return -1, if the second is less than the first, return 1. If the constants are not integral, return -2. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l01382">1382</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantFold_8cpp_source.html#l01360">isMaybeZeroSizedType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l01515">evaluateICmpRelation()</a>.</p>

</div>
</div>
<a id="aaf1763d20509172e8577c019ee727ef1" name="aaf1763d20509172e8577c019ee727ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1763d20509172e8577c019ee727ef1">&#9670;&nbsp;</a></span>isInBoundsIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isInBoundsIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; IndexTy &gt;&#160;</td>
          <td class="paramname"><em>Idxs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the given sequence of <em>normalized</em> indices is "inbounds". </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l02102">2102</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l02144">llvm::ConstantFoldGetElementPtr()</a>.</p>

</div>
</div>
<a id="a7d3d2d13dc400672038797a6fc50cd09" name="a7d3d2d13dc400672038797a6fc50cd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3d2d13dc400672038797a6fc50cd09">&#9670;&nbsp;</a></span>isIndexInRangeOfArrayType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isIndexInRangeOfArrayType </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>NumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstantInt *&#160;</td>
          <td class="paramname"><em>CI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether a given ConstantInt is in-range for a SequentialType. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l02128">2128</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l02144">llvm::ConstantFoldGetElementPtr()</a>.</p>

</div>
</div>
<a id="a7daa2bbd118fbf9d77a9efb61a2bff39" name="a7daa2bbd118fbf9d77a9efb61a2bff39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daa2bbd118fbf9d77a9efb61a2bff39">&#9670;&nbsp;</a></span>isMaybeZeroSizedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isMaybeZeroSizedType </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>Ty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This type is zero-sized if it's an array or structure of zero-sized types. </p>
<p >The only leaf zero-sized type is an empty structure. </p>

<p class="definition">Definition at line <a class="el" href="ConstantFold_8cpp_source.html#l01360">1360</a> of file <a class="el" href="ConstantFold_8cpp_source.html">ConstantFold.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConstantFold_8cpp_source.html#l01360">isMaybeZeroSizedType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConstantFold_8cpp_source.html#l01382">IdxCompare()</a>, and <a class="el" href="ConstantFold_8cpp_source.html#l01360">isMaybeZeroSizedType()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:44:44 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
