<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::Attributor Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="structllvm_1_1Attributor.html">Attributor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structllvm_1_1Attributor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">llvm::Attributor Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>}  
 <a href="structllvm_1_1Attributor.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Attributor_8h_source.html">llvm/Transforms/IPO/Attributor.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac595913aaed3e6db98e189d05067f4a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#ac595913aaed3e6db98e189d05067f4a0">~Attributor</a> ()</td></tr>
<tr class="separator:ac595913aaed3e6db98e189d05067f4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d3babc57be041df699846f65d231c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#acd850975ae5042cacb64a9d0ea4715f3">ChangeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#af7d3babc57be041df699846f65d231c8">run</a> ()</td></tr>
<tr class="memdesc:af7d3babc57be041df699846f65d231c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the analyses until a fixpoint is reached or enforced (timeout).  <a href="structllvm_1_1Attributor.html#af7d3babc57be041df699846f65d231c8">More...</a><br /></td></tr>
<tr class="separator:af7d3babc57be041df699846f65d231c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebd42bb30b14a161af6310b126788a6"><td class="memTemplParams" colspan="2">template&lt;typename AAType &gt; </td></tr>
<tr class="memitem:aeebd42bb30b14a161af6310b126788a6"><td class="memTemplItemLeft" align="right" valign="top">const AAType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#aeebd42bb30b14a161af6310b126788a6">getAAFor</a> (<a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;QueryingAA, const <a class="el" href="classllvm_1_1Value.html">Value</a> &amp;V, int ArgNo=-1)</td></tr>
<tr class="memdesc:aeebd42bb30b14a161af6310b126788a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup an abstract attribute of type <code>AAType</code> anchored at value <code>V</code> and argument number <code>ArgNo</code>.  <a href="structllvm_1_1Attributor.html#aeebd42bb30b14a161af6310b126788a6">More...</a><br /></td></tr>
<tr class="separator:aeebd42bb30b14a161af6310b126788a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c6ec239ae38f49b9b673f8144fb2ae"><td class="memTemplParams" colspan="2">template&lt;typename AAType &gt; </td></tr>
<tr class="memitem:a29c6ec239ae38f49b9b673f8144fb2ae"><td class="memTemplItemLeft" align="right" valign="top">AAType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a29c6ec239ae38f49b9b673f8144fb2ae">registerAA</a> (AAType &amp;AA, int ArgNo=-1)</td></tr>
<tr class="memdesc:a29c6ec239ae38f49b9b673f8144fb2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduce a new abstract attribute into the fixpoint analysis.  <a href="structllvm_1_1Attributor.html#a29c6ec239ae38f49b9b673f8144fb2ae">More...</a><br /></td></tr>
<tr class="separator:a29c6ec239ae38f49b9b673f8144fb2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d25445310201118d275e6d5ffb1a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#ad7d25445310201118d275e6d5ffb1a22">identifyDefaultAbstractAttributes</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, <a class="el" href="structllvm_1_1InformationCache.html">InformationCache</a> &amp;InfoCache, DenseSet&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *Whitelist=nullptr)</td></tr>
<tr class="memdesc:ad7d25445310201118d275e6d5ffb1a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine opportunities to derive 'default' attributes in <code>F</code> and create abstract attribute objects for them.  <a href="structllvm_1_1Attributor.html#ad7d25445310201118d275e6d5ffb1a22">More...</a><br /></td></tr>
<tr class="separator:ad7d25445310201118d275e6d5ffb1a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98af3cc5303d1f17a3e458fecddc7f0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1Attributor.html#a98af3cc5303d1f17a3e458fecddc7f0d">checkForAllCallSites</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, std::function&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1CallSite.html">CallSite</a>)&gt; &amp;Pred, <a class="el" href="classbool.html">bool</a> RequireAllCallSites)</td></tr>
<tr class="memdesc:a98af3cc5303d1f17a3e458fecddc7f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all function call sites.  <a href="structllvm_1_1Attributor.html#a98af3cc5303d1f17a3e458fecddc7f0d">More...</a><br /></td></tr>
<tr class="separator:a98af3cc5303d1f17a3e458fecddc7f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >} </p>
<p >The fixpoint analysis framework that orchestrates the attribute deduction.</p>
<p >The <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a> provides a general abstract analysis framework (guided fixpoint iteration) as well as helper functions for the deduction of (LLVM-IR) attributes. However, also other code properties can be deduced, propagated, and ultimately manifested through the <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a> framework. This is particularly useful if these properties interact with attributes and a co-scheduled deduction allows to improve the solution. Even if not, thus if attributes/properties are completely isolated, they should use the <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a> framework to reduce the number of fixpoint iteration frameworks in the code base. Note that the <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a> design makes sure that isolated attributes are not impacted, in any way, by others derived at the same time if there is no cross-reasoning performed.</p>
<p >The public facing interface of the <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a> is kept simple and basically allows abstract attributes to one thing, query abstract attributes in-flight. There are two reasons to do this: a) The optimistic state of one abstract attribute can justify an optimistic state of another, allowing to framework to end up with an optimistic (=best possible) fixpoint instead of one based solely on information in the IR. b) This avoids reimplementing various kinds of lookups, e.g., to check for existing IR attributes, in favor of a single lookups interface provided by an abstract attribute subclass.</p>
<p >NOTE: The mechanics of adding a new "concrete" abstract attribute are described in the file comment. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l00150">150</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac595913aaed3e6db98e189d05067f4a0" name="ac595913aaed3e6db98e189d05067f4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac595913aaed3e6db98e189d05067f4a0">&#9670;&nbsp;</a></span>~Attributor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Attributor::~Attributor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l00151">151</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a98af3cc5303d1f17a3e458fecddc7f0d" name="a98af3cc5303d1f17a3e458fecddc7f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98af3cc5303d1f17a3e458fecddc7f0d">&#9670;&nbsp;</a></span>checkForAllCallSites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Attributor::checkForAllCallSites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1CallSite.html">CallSite</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>RequireAllCallSites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> <code>Pred</code> on all function call sites. </p>
<p >This method will evaluate <code>Pred</code> on call sites and return true if <code>Pred</code> holds in every call sites. However, this is only possible all call sites are known, hence the function has internal linkage.</p>
<hr  />
 <h2><a class="anchor" id="autotoc_md26"></a>
Attributor</h2>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01318">1318</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="CallSite_8h_source.html#l00275">llvm::CallSiteBase&lt; FunTy, BBTy, ValTy, UserTy, UseTy, InstrTy, CallTy, InvokeTy, CallBrTy, IterTy &gt;::getCaller()</a>, <a class="el" href="CallSite_8h_source.html#l00096">llvm::CallSiteBase&lt; FunTy, BBTy, ValTy, UserTy, UseTy, InstrTy, CallTy, InvokeTy, CallBrTy, IterTy &gt;::getInstruction()</a>, <a class="el" href="GlobalValue_8h_source.html#l00416">llvm::GlobalValue::hasExactDefinition()</a>, <a class="el" href="CallSite_8h_source.html#l00150">llvm::CallSiteBase&lt; FunTy, BBTy, ValTy, UserTy, UseTy, InstrTy, CallTy, InvokeTy, CallBrTy, IterTy &gt;::isCallee()</a>, and <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>.</p>

</div>
</div>
<a id="aeebd42bb30b14a161af6310b126788a6" name="aeebd42bb30b14a161af6310b126788a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebd42bb30b14a161af6310b126788a6">&#9670;&nbsp;</a></span>getAAFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const AAType * llvm::Attributor::getAAFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1AbstractAttribute.html">AbstractAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>QueryingAA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ArgNo</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup an abstract attribute of type <code>AAType</code> anchored at value <code>V</code> and argument number <code>ArgNo</code>. </p>
<p >If no attribute is found and <code>V</code> is a call base instruction, the called function is tried as a value next. Thus, the returned abstract attribute might be anchored at the callee of <code>V</code>.</p>
<p >This method is the only (supported) way an abstract attribute can retrieve information from another abstract attribute. As an example, take an abstract attribute that determines the memory access behavior for a argument (readnone, readonly, ...). It should use <code>getAAFor</code> to get the most optimistic information for other abstract attributes in-flight, e.g. the one reasoning about the "captured" state for the argument or the one reasoning on the memory access behavior of the function as a whole. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l00174">174</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="CallSite_8h_source.html#l00104">llvm::CallSiteBase&lt; FunTy, BBTy, ValTy, UserTy, UseTy, InstrTy, CallTy, InvokeTy, CallBrTy, IterTy &gt;::getCalledValue()</a>, and <a class="el" href="Attributes_8h_source.html#l00071">llvm::Attribute::None</a>.</p>

</div>
</div>
<a id="ad7d25445310201118d275e6d5ffb1a22" name="ad7d25445310201118d275e6d5ffb1a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d25445310201118d275e6d5ffb1a22">&#9670;&nbsp;</a></span>identifyDefaultAbstractAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Attributor::identifyDefaultAbstractAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1InformationCache.html">InformationCache</a> &amp;&#160;</td>
          <td class="paramname"><em>InfoCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseSet&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *&#160;</td>
          <td class="paramname"><em>Whitelist</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine opportunities to derive 'default' attributes in <code>F</code> and create abstract attribute objects for them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>The function that is checked for attribute opportunities. </td></tr>
    <tr><td class="paramname">InfoCache</td><td>A cache for information queryable by the new attributes. </td></tr>
    <tr><td class="paramname">Whitelist</td><td>If not null, a set limiting the attribute opportunities.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that abstract attribute instances are generally created even if the IR already contains the information they would deduce. The most important reason for this is the single interface, the one of the abstract attribute instance, which can be queried without the need to look at the IR in various places. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01489">1489</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Function_8h_source.html#l00722">llvm::Function::arg_size()</a>, <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Call</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="CallSite_8h_source.html#l00193">llvm::CallSiteBase&lt; FunTy, BBTy, ValTy, UserTy, UseTy, InstrTy, CallTy, InvokeTy, CallBrTy, IterTy &gt;::getArgument()</a>, <a class="el" href="CallSite_8h_source.html#l00111">llvm::CallSiteBase&lt; FunTy, BBTy, ValTy, UserTy, UseTy, InstrTy, CallTy, InvokeTy, CallBrTy, IterTy &gt;::getCalledFunction()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="InstructionCombining_8cpp_source.html#l03614">instructions</a>, <a class="el" href="Type_8h_source.html#l00223">llvm::Type::isPointerTy()</a>, <a class="el" href="Attributor_8h_source.html#l00229">registerAA()</a>, and <a class="el" href="ARMWinEH_8h_source.html#l00134">llvm::ARM::WinEH::RuntimeFunction::Ret()</a>.</p>

</div>
</div>
<a id="a29c6ec239ae38f49b9b673f8144fb2ae" name="a29c6ec239ae38f49b9b673f8144fb2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c6ec239ae38f49b9b673f8144fb2ae">&#9670;&nbsp;</a></span>registerAA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AAType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AAType &amp; llvm::Attributor::registerAA </td>
          <td>(</td>
          <td class="paramtype">AAType &amp;&#160;</td>
          <td class="paramname"><em>AA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ArgNo</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Introduce a new abstract attribute into the fixpoint analysis. </p>
<p >Note that ownership of the attribute is given to the <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a>. It will invoke delete for the <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a> on destruction of the <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a>.</p>
<p >Attributes are identified by (1) their anchored value (see AA.getAnchoredValue()), (2) their argument number (<code>ArgNo</code>, or <a class="el" href="classllvm_1_1Argument.html#ab205d366b1137026c32f5678f7cc2726" title="Return the index of this formal argument in its containing function.">Argument::getArgNo()</a>), and (3) their default attribute kind (see AAType::ID). </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8h_source.html#l00229">229</a> of file <a class="el" href="Attributor_8h_source.html">Attributor.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l01489">identifyDefaultAbstractAttributes()</a>.</p>

</div>
</div>
<a id="af7d3babc57be041df699846f65d231c8" name="af7d3babc57be041df699846f65d231c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d3babc57be041df699846f65d231c8">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacellvm.html#acd850975ae5042cacb64a9d0ea4715f3">ChangeStatus</a> Attributor::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the analyses until a fixpoint is reached or enforced (timeout). </p>
<p >The attributes registered with this <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a> can be used after as long as the <a class="el" href="structllvm_1_1Attributor.html" title="}">Attributor</a> is not destroyed (it owns the attributes now).</p>
<p >\Returns CHANGED if the IR was changed, otherwise UNCHANGED. </p>

<p class="definition">Definition at line <a class="el" href="Attributor_8cpp_source.html#l01355">1355</a> of file <a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#acd850975ae5042cacb64a9d0ea4715f3ae6b94e58bfd13b21bc786578d9f8ba4a">llvm::CHANGED</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="structllvm_1_1AbstractAttribute.html#a351334eaac25d62303653847fa199468">llvm::AbstractAttribute::getState()</a>, <a class="el" href="structllvm_1_1AbstractState.html#acfe79ea038e2c57e498d84de4b73d251">llvm::AbstractState::indicateOptimisticFixpoint()</a>, <a class="el" href="structllvm_1_1AbstractState.html#a0b1e7022fa9ea41f343735d6451877c9">llvm::AbstractState::indicatePessimisticFixpoint()</a>, <a class="el" href="structllvm_1_1AbstractState.html#adab11027e1a9fdc4c600bb8dba1df413">llvm::AbstractState::isAtFixpoint()</a>, <a class="el" href="structllvm_1_1AbstractState.html#ae2b42216b30b52bbb803df6884ef34d2">llvm::AbstractState::isValidState()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="ErrorHandling_8h_source.html#l00135">llvm_unreachable</a>, <a class="el" href="Attributor_8cpp.html#af7f5e067de7ed39291ead78f3cb4da80">MaxFixpointIterations</a>, <a class="el" href="Attributor_8cpp_source.html#l01355">run()</a>, <a class="el" href="namespacellvm.html#acd850975ae5042cacb64a9d0ea4715f3a46335765005ff44b1fe1e38e5d2ddfcc">llvm::UNCHANGED</a>, and <a class="el" href="Attributor_8cpp.html#a89c931fa398f913641c52c4361fb052b">VerifyAttributor</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributor_8cpp_source.html#l01355">run()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/llvm/Transforms/IPO/<a class="el" href="Attributor_8h_source.html">Attributor.h</a></li>
<li>lib/Transforms/IPO/<a class="el" href="Attributor_8cpp_source.html">Attributor.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:56:42 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
