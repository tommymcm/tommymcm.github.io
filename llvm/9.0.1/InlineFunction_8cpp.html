<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/Utils/InlineFunction.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_f75c00afeb315f44d76556a7c675e6e8.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">InlineFunction.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;llvm/ADT/DenseMap.h&quot;</code><br />
<code>#include &quot;llvm/ADT/None.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Optional.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SetVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallPtrSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/StringExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/iterator_range.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/AliasAnalysis.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/AssumptionCache.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/BlockFrequencyInfo.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/CallGraph.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/CaptureTracking.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/EHPersonalities.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/InstructionSimplify.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/ProfileSummaryInfo.h&quot;</code><br />
<code>#include &quot;llvm/Transforms/Utils/Local.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/ValueTracking.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/VectorUtils.h&quot;</code><br />
<code>#include &quot;llvm/IR/Argument.h&quot;</code><br />
<code>#include &quot;llvm/IR/BasicBlock.h&quot;</code><br />
<code>#include &quot;llvm/IR/CFG.h&quot;</code><br />
<code>#include &quot;llvm/IR/CallSite.h&quot;</code><br />
<code>#include &quot;llvm/IR/Constant.h&quot;</code><br />
<code>#include &quot;llvm/IR/Constants.h&quot;</code><br />
<code>#include &quot;llvm/IR/DIBuilder.h&quot;</code><br />
<code>#include &quot;llvm/IR/DataLayout.h&quot;</code><br />
<code>#include &quot;llvm/IR/DebugInfoMetadata.h&quot;</code><br />
<code>#include &quot;llvm/IR/DebugLoc.h&quot;</code><br />
<code>#include &quot;llvm/IR/DerivedTypes.h&quot;</code><br />
<code>#include &quot;llvm/IR/Dominators.h&quot;</code><br />
<code>#include &quot;llvm/IR/Function.h&quot;</code><br />
<code>#include &quot;llvm/IR/IRBuilder.h&quot;</code><br />
<code>#include &quot;llvm/IR/InstrTypes.h&quot;</code><br />
<code>#include &quot;llvm/IR/Instruction.h&quot;</code><br />
<code>#include &quot;llvm/IR/Instructions.h&quot;</code><br />
<code>#include &quot;llvm/IR/IntrinsicInst.h&quot;</code><br />
<code>#include &quot;llvm/IR/Intrinsics.h&quot;</code><br />
<code>#include &quot;llvm/IR/LLVMContext.h&quot;</code><br />
<code>#include &quot;llvm/IR/MDBuilder.h&quot;</code><br />
<code>#include &quot;llvm/IR/Metadata.h&quot;</code><br />
<code>#include &quot;llvm/IR/Module.h&quot;</code><br />
<code>#include &quot;llvm/IR/Type.h&quot;</code><br />
<code>#include &quot;llvm/IR/User.h&quot;</code><br />
<code>#include &quot;llvm/IR/Value.h&quot;</code><br />
<code>#include &quot;llvm/Support/Casting.h&quot;</code><br />
<code>#include &quot;llvm/Support/CommandLine.h&quot;</code><br />
<code>#include &quot;llvm/Support/ErrorHandling.h&quot;</code><br />
<code>#include &quot;llvm/Transforms/Utils/Cloning.h&quot;</code><br />
<code>#include &quot;llvm/Transforms/Utils/ValueMapper.h&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="InlineFunction_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac57dae906fe8ac64efe52571121b0fe1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#ac57dae906fe8ac64efe52571121b0fe1">ProfileCount</a> = Function::ProfileCount</td></tr>
<tr class="separator:ac57dae906fe8ac64efe52571121b0fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af37358cf937d4298f5c5198bf91d34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a2af37358cf937d4298f5c5198bf91d34">UnwindDestMemoTy</a> = DenseMap&lt; Instruction *, Value * &gt;</td></tr>
<tr class="separator:a2af37358cf937d4298f5c5198bf91d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6569a1deb77e8696421357af3dff2c5f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a6569a1deb77e8696421357af3dff2c5f">EnableNoAliasConversion</a> (&quot;enable-noalias-to-md-conversion&quot;, cl::init(<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>), cl::Hidden, cl::desc(&quot;Convert noalias <a class="el" href="Attributor_8cpp.html#ad84a22c0ca79437f4ec14e006f34e8ed">attributes</a> to metadata during inlining.&quot;))</td></tr>
<tr class="separator:a6569a1deb77e8696421357af3dff2c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef339dd6477b77cd79503e9bbf0b46a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#aaef339dd6477b77cd79503e9bbf0b46a">PreserveAlignmentAssumptions</a> (&quot;preserve-alignment-assumptions-during-inlining&quot;, cl::init(<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>), cl::Hidden, cl::desc(&quot;Convert align <a class="el" href="Attributor_8cpp.html#ad84a22c0ca79437f4ec14e006f34e8ed">attributes</a> to assumptions during inlining.&quot;))</td></tr>
<tr class="separator:aaef339dd6477b77cd79503e9bbf0b46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12dacafa8a30b2f9bfed5f3a022a612"><td class="memItemLeft" align="right" valign="top">static Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#ac12dacafa8a30b2f9bfed5f3a022a612">getParentPad</a> (Value *EHPad)</td></tr>
<tr class="memdesc:ac12dacafa8a30b2f9bfed5f3a022a612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for getUnwindDestToken/getUnwindDestTokenHelper.  <a href="InlineFunction_8cpp.html#ac12dacafa8a30b2f9bfed5f3a022a612">More...</a><br /></td></tr>
<tr class="separator:ac12dacafa8a30b2f9bfed5f3a022a612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e19285f051b80099ed8b36c5c94eaf2"><td class="memItemLeft" align="right" valign="top">static Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a4e19285f051b80099ed8b36c5c94eaf2">getUnwindDestTokenHelper</a> (Instruction *EHPad, <a class="el" href="InlineFunction_8cpp.html#a2af37358cf937d4298f5c5198bf91d34">UnwindDestMemoTy</a> &amp;MemoMap)</td></tr>
<tr class="memdesc:a4e19285f051b80099ed8b36c5c94eaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for getUnwindDestToken that does the descendant-ward part of the search.  <a href="InlineFunction_8cpp.html#a4e19285f051b80099ed8b36c5c94eaf2">More...</a><br /></td></tr>
<tr class="separator:a4e19285f051b80099ed8b36c5c94eaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc72cfbc837c8e89491b6357c358778"><td class="memItemLeft" align="right" valign="top">static Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a3cc72cfbc837c8e89491b6357c358778">getUnwindDestToken</a> (Instruction *EHPad, <a class="el" href="InlineFunction_8cpp.html#a2af37358cf937d4298f5c5198bf91d34">UnwindDestMemoTy</a> &amp;MemoMap)</td></tr>
<tr class="memdesc:a3cc72cfbc837c8e89491b6357c358778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an EH pad, find where it unwinds.  <a href="InlineFunction_8cpp.html#a3cc72cfbc837c8e89491b6357c358778">More...</a><br /></td></tr>
<tr class="separator:a3cc72cfbc837c8e89491b6357c358778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea5b2388bd9dc7e7fc902b5bd1e35e4"><td class="memItemLeft" align="right" valign="top">static BasicBlock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a4ea5b2388bd9dc7e7fc902b5bd1e35e4">HandleCallsInBlockInlinedThroughInvoke</a> (BasicBlock *BB, BasicBlock *UnwindEdge, <a class="el" href="InlineFunction_8cpp.html#a2af37358cf937d4298f5c5198bf91d34">UnwindDestMemoTy</a> *FuncletUnwindMap=nullptr)</td></tr>
<tr class="memdesc:a4ea5b2388bd9dc7e7fc902b5bd1e35e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">When we inline a basic block into an invoke, we have to turn all of the calls that can throw into invokes.  <a href="InlineFunction_8cpp.html#a4ea5b2388bd9dc7e7fc902b5bd1e35e4">More...</a><br /></td></tr>
<tr class="separator:a4ea5b2388bd9dc7e7fc902b5bd1e35e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbd6aad6f6b93f79dc435feab77550e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a4cbd6aad6f6b93f79dc435feab77550e">HandleInlinedLandingPad</a> (InvokeInst *II, BasicBlock *FirstNewBlock, ClonedCodeInfo &amp;InlinedCodeInfo)</td></tr>
<tr class="memdesc:a4cbd6aad6f6b93f79dc435feab77550e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we inlined an invoke site, we need to convert calls in the body of the inlined function into invokes.  <a href="InlineFunction_8cpp.html#a4cbd6aad6f6b93f79dc435feab77550e">More...</a><br /></td></tr>
<tr class="separator:a4cbd6aad6f6b93f79dc435feab77550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac69c9cf4e552a52d5065e94dc023f82"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#aac69c9cf4e552a52d5065e94dc023f82">HandleInlinedEHPad</a> (InvokeInst *II, BasicBlock *FirstNewBlock, ClonedCodeInfo &amp;InlinedCodeInfo)</td></tr>
<tr class="memdesc:aac69c9cf4e552a52d5065e94dc023f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we inlined an invoke site, we need to convert calls in the body of the inlined function into invokes.  <a href="InlineFunction_8cpp.html#aac69c9cf4e552a52d5065e94dc023f82">More...</a><br /></td></tr>
<tr class="separator:aac69c9cf4e552a52d5065e94dc023f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3faa7edd99cde25e2d08a0f12d2142d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a3faa7edd99cde25e2d08a0f12d2142d5">PropagateParallelLoopAccessMetadata</a> (CallSite CS, ValueToValueMapTy &amp;VMap)</td></tr>
<tr class="memdesc:a3faa7edd99cde25e2d08a0f12d2142d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">When inlining a call site that has !llvm.mem.parallel_loop_access or llvm.access.group metadata, that metadata should be propagated to all memory-accessing cloned instructions.  <a href="InlineFunction_8cpp.html#a3faa7edd99cde25e2d08a0f12d2142d5">More...</a><br /></td></tr>
<tr class="separator:a3faa7edd99cde25e2d08a0f12d2142d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba6df3e5b46d5c05a781a9828e9c41a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a9ba6df3e5b46d5c05a781a9828e9c41a">CloneAliasScopeMetadata</a> (CallSite CS, ValueToValueMapTy &amp;VMap)</td></tr>
<tr class="memdesc:a9ba6df3e5b46d5c05a781a9828e9c41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When inlining a function that contains noalias scope metadata, this metadata needs to be cloned so that the inlined blocks have different "unique scopes" at every call site.  <a href="InlineFunction_8cpp.html#a9ba6df3e5b46d5c05a781a9828e9c41a">More...</a><br /></td></tr>
<tr class="separator:a9ba6df3e5b46d5c05a781a9828e9c41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe99fcce391ce18d555daf51560765f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#afe99fcce391ce18d555daf51560765f1">AddAliasScopeMetadata</a> (CallSite CS, ValueToValueMapTy &amp;VMap, const DataLayout &amp;DL, AAResults *CalleeAAR)</td></tr>
<tr class="memdesc:afe99fcce391ce18d555daf51560765f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the inlined function has noalias arguments, then add new alias scopes for each noalias argument, tag the mapped noalias parameters with noalias metadata specifying the new scope, and tag all non-derived loads, stores and memory intrinsics with the new alias scopes.  <a href="InlineFunction_8cpp.html#afe99fcce391ce18d555daf51560765f1">More...</a><br /></td></tr>
<tr class="separator:afe99fcce391ce18d555daf51560765f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e7873bcb0f5e6d9dbe671a23d0deaa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a19e7873bcb0f5e6d9dbe671a23d0deaa">AddAlignmentAssumptions</a> (CallSite CS, InlineFunctionInfo &amp;IFI)</td></tr>
<tr class="memdesc:a19e7873bcb0f5e6d9dbe671a23d0deaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the inlined function has non-byval align arguments, then add @llvm.assume-based alignment assumptions to preserve this information.  <a href="InlineFunction_8cpp.html#a19e7873bcb0f5e6d9dbe671a23d0deaa">More...</a><br /></td></tr>
<tr class="separator:a19e7873bcb0f5e6d9dbe671a23d0deaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d19879a40bcc9f91d922869cc5938f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a1d19879a40bcc9f91d922869cc5938f1">UpdateCallGraphAfterInlining</a> (CallSite CS, Function::iterator FirstNewBlock, ValueToValueMapTy &amp;VMap, InlineFunctionInfo &amp;IFI)</td></tr>
<tr class="memdesc:a1d19879a40bcc9f91d922869cc5938f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once we have cloned code over from a callee into the caller, update the specified callgraph to reflect the changes we made.  <a href="InlineFunction_8cpp.html#a1d19879a40bcc9f91d922869cc5938f1">More...</a><br /></td></tr>
<tr class="separator:a1d19879a40bcc9f91d922869cc5938f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1d36b215eb2ed9f310afbcbe5e16a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#acf1d36b215eb2ed9f310afbcbe5e16a9">HandleByValArgumentInit</a> (Value *Dst, Value *Src, Module *M, BasicBlock *InsertBlock, InlineFunctionInfo &amp;IFI)</td></tr>
<tr class="separator:acf1d36b215eb2ed9f310afbcbe5e16a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d26307a0f26f4f9dec6b2ca28264f4d"><td class="memItemLeft" align="right" valign="top">static Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a2d26307a0f26f4f9dec6b2ca28264f4d">HandleByValArgument</a> (Value *Arg, Instruction *TheCall, const Function *CalledFunc, InlineFunctionInfo &amp;IFI, unsigned ByValAlignment)</td></tr>
<tr class="memdesc:a2d26307a0f26f4f9dec6b2ca28264f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When inlining a call site that has a byval argument, we have to make the implicit memcpy explicit by adding it.  <a href="InlineFunction_8cpp.html#a2d26307a0f26f4f9dec6b2ca28264f4d">More...</a><br /></td></tr>
<tr class="separator:a2d26307a0f26f4f9dec6b2ca28264f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21f217cd2f8044e639f13111a0b37db"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#ae21f217cd2f8044e639f13111a0b37db">isUsedByLifetimeMarker</a> (Value *V)</td></tr>
<tr class="separator:ae21f217cd2f8044e639f13111a0b37db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa78d0b3224d3175937f997dc2bc688"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#afaa78d0b3224d3175937f997dc2bc688">hasLifetimeMarkers</a> (AllocaInst *AI)</td></tr>
<tr class="separator:afaa78d0b3224d3175937f997dc2bc688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19c97a069133d179234826fc95c3bde"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#ad19c97a069133d179234826fc95c3bde">allocaWouldBeStaticInEntry</a> (const AllocaInst *AI)</td></tr>
<tr class="memdesc:ad19c97a069133d179234826fc95c3bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of AI-&gt;isStaticAlloca() if AI were moved to the entry block.  <a href="InlineFunction_8cpp.html#ad19c97a069133d179234826fc95c3bde">More...</a><br /></td></tr>
<tr class="separator:ad19c97a069133d179234826fc95c3bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5217abbfbac8873d22a2dd6cdbb0bcc1"><td class="memItemLeft" align="right" valign="top">static DebugLoc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a5217abbfbac8873d22a2dd6cdbb0bcc1">inlineDebugLoc</a> (DebugLoc OrigDL, DILocation *InlinedAt, LLVMContext &amp;Ctx, DenseMap&lt; const MDNode *, MDNode * &gt; &amp;IANodes)</td></tr>
<tr class="memdesc:a5217abbfbac8873d22a2dd6cdbb0bcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a DebugLoc for a new DILocation which is a clone of <code>OrigDL</code> inlined at <code>InlinedAt</code>.  <a href="InlineFunction_8cpp.html#a5217abbfbac8873d22a2dd6cdbb0bcc1">More...</a><br /></td></tr>
<tr class="separator:a5217abbfbac8873d22a2dd6cdbb0bcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718232bb7c0467cb727ea5d15c1f7b0"><td class="memItemLeft" align="right" valign="top">static MDNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a7718232bb7c0467cb727ea5d15c1f7b0">inlineLoopID</a> (const MDNode *OrigLoopId, DILocation *InlinedAt, LLVMContext &amp;Ctx, DenseMap&lt; const MDNode *, MDNode * &gt; &amp;IANodes)</td></tr>
<tr class="memdesc:a7718232bb7c0467cb727ea5d15c1f7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the LoopID for a loop which has has been cloned from another function for inlining with the new inlined-at start and end locs.  <a href="InlineFunction_8cpp.html#a7718232bb7c0467cb727ea5d15c1f7b0">More...</a><br /></td></tr>
<tr class="separator:a7718232bb7c0467cb727ea5d15c1f7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed4f37fbda15a9c05f333fde59e9fbb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a2ed4f37fbda15a9c05f333fde59e9fbb">fixupLineNumbers</a> (Function *Fn, Function::iterator FI, Instruction *TheCall, bool CalleeHasDebugInfo)</td></tr>
<tr class="memdesc:a2ed4f37fbda15a9c05f333fde59e9fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update inlined instructions' line numbers to to encode location where these instructions are inlined.  <a href="InlineFunction_8cpp.html#a2ed4f37fbda15a9c05f333fde59e9fbb">More...</a><br /></td></tr>
<tr class="separator:a2ed4f37fbda15a9c05f333fde59e9fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a2e4a8c4f5b3b8dee5407d55e8872d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a83a2e4a8c4f5b3b8dee5407d55e8872d">updateCallerBFI</a> (BasicBlock *CallSiteBlock, const ValueToValueMapTy &amp;VMap, BlockFrequencyInfo *CallerBFI, BlockFrequencyInfo *CalleeBFI, const BasicBlock &amp;CalleeEntryBlock)</td></tr>
<tr class="memdesc:a83a2e4a8c4f5b3b8dee5407d55e8872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the block frequencies of the caller after a callee has been inlined.  <a href="InlineFunction_8cpp.html#a83a2e4a8c4f5b3b8dee5407d55e8872d">More...</a><br /></td></tr>
<tr class="separator:a83a2e4a8c4f5b3b8dee5407d55e8872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ae07b5c8f3ce4e725bd2ee09caff7b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InlineFunction_8cpp.html#a77ae07b5c8f3ce4e725bd2ee09caff7b">updateCallProfile</a> (Function *Callee, const ValueToValueMapTy &amp;VMap, const <a class="el" href="Function_8cpp.html#ac57dae906fe8ac64efe52571121b0fe1">ProfileCount</a> &amp;CalleeEntryCount, const Instruction *TheCall, ProfileSummaryInfo *PSI, BlockFrequencyInfo *CallerBFI)</td></tr>
<tr class="memdesc:a77ae07b5c8f3ce4e725bd2ee09caff7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the branch metadata for cloned call instructions.  <a href="InlineFunction_8cpp.html#a77ae07b5c8f3ce4e725bd2ee09caff7b">More...</a><br /></td></tr>
<tr class="separator:a77ae07b5c8f3ce4e725bd2ee09caff7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac57dae906fe8ac64efe52571121b0fe1" name="ac57dae906fe8ac64efe52571121b0fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57dae906fe8ac64efe52571121b0fe1">&#9670;&nbsp;</a></span>ProfileCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="Function_8cpp.html#ac57dae906fe8ac64efe52571121b0fe1">ProfileCount</a> =  Function::ProfileCount</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00075">75</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

</div>
</div>
<a id="a2af37358cf937d4298f5c5198bf91d34" name="a2af37358cf937d4298f5c5198bf91d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af37358cf937d4298f5c5198bf91d34">&#9670;&nbsp;</a></span>UnwindDestMemoTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="InlineFunction_8cpp.html#a2af37358cf937d4298f5c5198bf91d34">UnwindDestMemoTy</a> =  DenseMap&lt;Instruction *, Value *&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00224">224</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afe99fcce391ce18d555daf51560765f1" name="afe99fcce391ce18d555daf51560765f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe99fcce391ce18d555daf51560765f1">&#9670;&nbsp;</a></span>AddAliasScopeMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AddAliasScopeMetadata </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueToValueMapTy &amp;&#160;</td>
          <td class="paramname"><em>VMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataLayout &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AAResults *&#160;</td>
          <td class="paramname"><em>CalleeAAR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the inlined function has noalias arguments, then add new alias scopes for each noalias argument, tag the mapped noalias parameters with noalias metadata specifying the new scope, and tag all non-derived loads, stores and memory intrinsics with the new alias scopes. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00919">919</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlineFunction_8cpp.html#a6569a1deb77e8696421357af3dff2c5f">EnableNoAliasConversion()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a19e7873bcb0f5e6d9dbe671a23d0deaa" name="a19e7873bcb0f5e6d9dbe671a23d0deaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e7873bcb0f5e6d9dbe671a23d0deaa">&#9670;&nbsp;</a></span>AddAlignmentAssumptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AddAlignmentAssumptions </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InlineFunctionInfo &amp;&#160;</td>
          <td class="paramname"><em>IFI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the inlined function has non-byval align arguments, then add @llvm.assume-based alignment assumptions to preserve this information. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01141">1141</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlineFunction_8cpp.html#aaef339dd6477b77cd79503e9bbf0b46a">PreserveAlignmentAssumptions()</a>.</p>

</div>
</div>
<a id="ad19c97a069133d179234826fc95c3bde" name="ad19c97a069133d179234826fc95c3bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19c97a069133d179234826fc95c3bde">&#9670;&nbsp;</a></span>allocaWouldBeStaticInEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool allocaWouldBeStaticInEntry </td>
          <td>(</td>
          <td class="paramtype">const AllocaInst *&#160;</td>
          <td class="paramname"><em>AI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of AI-&gt;isStaticAlloca() if AI were moved to the entry block. </p>
<p >Allocas used in inalloca calls and allocas of dynamic array size cannot be static. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01344">1344</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l01388">fixupLineNumbers()</a>.</p>

</div>
</div>
<a id="a9ba6df3e5b46d5c05a781a9828e9c41a" name="a9ba6df3e5b46d5c05a781a9828e9c41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba6df3e5b46d5c05a781a9828e9c41a">&#9670;&nbsp;</a></span>CloneAliasScopeMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CloneAliasScopeMetadata </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueToValueMapTy &amp;&#160;</td>
          <td class="paramname"><em>VMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When inlining a function that contains noalias scope metadata, this metadata needs to be cloned so that the inlined blocks have different "unique scopes" at every call site. </p>
<p >Were this not done, then aliasing scopes from a function inlined into a caller multiple times could not be differentiated (and this would lead to miscompiles because the non-aliasing property communicated by the metadata could have call-site-specific control dependencies). </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00813">813</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>.</p>

</div>
</div>
<a id="a6569a1deb77e8696421357af3dff2c5f" name="a6569a1deb77e8696421357af3dff2c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6569a1deb77e8696421357af3dff2c5f">&#9670;&nbsp;</a></span>EnableNoAliasConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt; EnableNoAliasConversion </td>
          <td>(</td>
          <td class="paramtype">&quot;enable-noalias-to-md-conversion&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Convert noalias <a class="el" href="Attributor_8cpp.html#ad84a22c0ca79437f4ec14e006f34e8ed">attributes</a> to metadata during inlining.&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l00919">AddAliasScopeMetadata()</a>.</p>

</div>
</div>
<a id="a2ed4f37fbda15a9c05f333fde59e9fbb" name="a2ed4f37fbda15a9c05f333fde59e9fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed4f37fbda15a9c05f333fde59e9fbb">&#9670;&nbsp;</a></span>fixupLineNumbers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fixupLineNumbers </td>
          <td>(</td>
          <td class="paramtype">Function *&#160;</td>
          <td class="paramname"><em>Fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function::iterator&#160;</td>
          <td class="paramname"><em>FI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>TheCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>CalleeHasDebugInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update inlined instructions' line numbers to to encode location where these instructions are inlined. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01388">1388</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlineFunction_8cpp_source.html#l01344">allocaWouldBeStaticInEntry()</a>, <a class="el" href="InlineFunction_8cpp_source.html#l01350">inlineDebugLoc()</a>, and <a class="el" href="InlineFunction_8cpp_source.html#l01360">inlineLoopID()</a>.</p>

</div>
</div>
<a id="ac12dacafa8a30b2f9bfed5f3a022a612" name="ac12dacafa8a30b2f9bfed5f3a022a612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12dacafa8a30b2f9bfed5f3a022a612">&#9670;&nbsp;</a></span>getParentPad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value * getParentPad </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>EHPad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for getUnwindDestToken/getUnwindDestTokenHelper. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00218">218</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l00379">getUnwindDestToken()</a>, and <a class="el" href="InlineFunction_8cpp_source.html#l00228">getUnwindDestTokenHelper()</a>.</p>

</div>
</div>
<a id="a3cc72cfbc837c8e89491b6357c358778" name="a3cc72cfbc837c8e89491b6357c358778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc72cfbc837c8e89491b6357c358778">&#9670;&nbsp;</a></span>getUnwindDestToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value * getUnwindDestToken </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>EHPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="InlineFunction_8cpp.html#a2af37358cf937d4298f5c5198bf91d34">UnwindDestMemoTy</a> &amp;&#160;</td>
          <td class="paramname"><em>MemoMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an EH pad, find where it unwinds. </p>
<p >If it unwinds to an EH pad, return that pad instruction. If it unwinds to caller, return ConstantTokenNone. If it does not have a definitive unwind destination, return nullptr.</p>
<p >This routine gets invoked for calls in funclets in inlinees when inlining an invoke. Since many funclets don't have calls inside them, it's queried on-demand rather than building a map of pads to unwind dests up front. Determining a funclet's unwind dest may require recursively searching its descendants, and also ancestors and cousins if the descendants don't provide an answer. Since most funclets will have their unwind dest immediately available as the unwind dest of a catchswitch or cleanupret, this routine searches top-down from the given pad and then up. To avoid worst-case quadratic run-time given that approach, it uses a memo map to avoid re-processing funclet trees. The callers that rewrite the IR as they go take advantage of this, for correctness, by checking/forcing rewritten pads' entries to match the original callee view. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00379">379</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="InlineFunction_8cpp_source.html#l00218">getParentPad()</a>, and <a class="el" href="InlineFunction_8cpp_source.html#l00228">getUnwindDestTokenHelper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l00523">HandleCallsInBlockInlinedThroughInvoke()</a>, and <a class="el" href="InlineFunction_8cpp_source.html#l00641">HandleInlinedEHPad()</a>.</p>

</div>
</div>
<a id="a4e19285f051b80099ed8b36c5c94eaf2" name="a4e19285f051b80099ed8b36c5c94eaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e19285f051b80099ed8b36c5c94eaf2">&#9670;&nbsp;</a></span>getUnwindDestTokenHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value * getUnwindDestTokenHelper </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>EHPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="InlineFunction_8cpp.html#a2af37358cf937d4298f5c5198bf91d34">UnwindDestMemoTy</a> &amp;&#160;</td>
          <td class="paramname"><em>MemoMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for getUnwindDestToken that does the descendant-ward part of the search. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00228">228</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="InlineFunction_8cpp_source.html#l00218">getParentPad()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l00379">getUnwindDestToken()</a>.</p>

</div>
</div>
<a id="a2d26307a0f26f4f9dec6b2ca28264f4d" name="a2d26307a0f26f4f9dec6b2ca28264f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d26307a0f26f4f9dec6b2ca28264f4d">&#9670;&nbsp;</a></span>HandleByValArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Value * HandleByValArgument </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>Arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>TheCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function *&#160;</td>
          <td class="paramname"><em>CalledFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InlineFunctionInfo &amp;&#160;</td>
          <td class="paramname"><em>IFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ByValAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When inlining a call site that has a byval argument, we have to make the implicit memcpy explicit by adding it. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01262">1262</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

</div>
</div>
<a id="acf1d36b215eb2ed9f310afbcbe5e16a9" name="acf1d36b215eb2ed9f310afbcbe5e16a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1d36b215eb2ed9f310afbcbe5e16a9">&#9670;&nbsp;</a></span>HandleByValArgumentInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HandleByValArgumentInit </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>Dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Module *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>InsertBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InlineFunctionInfo &amp;&#160;</td>
          <td class="paramname"><em>IFI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01246">1246</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

</div>
</div>
<a id="a4ea5b2388bd9dc7e7fc902b5bd1e35e4" name="a4ea5b2388bd9dc7e7fc902b5bd1e35e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea5b2388bd9dc7e7fc902b5bd1e35e4">&#9670;&nbsp;</a></span>HandleCallsInBlockInlinedThroughInvoke()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BasicBlock * HandleCallsInBlockInlinedThroughInvoke </td>
          <td>(</td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>BB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>UnwindEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="InlineFunction_8cpp.html#a2af37358cf937d4298f5c5198bf91d34">UnwindDestMemoTy</a> *&#160;</td>
          <td class="paramname"><em>FuncletUnwindMap</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When we inline a basic block into an invoke, we have to turn all of the calls that can throw into invokes. </p>
<p >This function analyze BB to see if there are any calls, and if so, it rewrites them to be invokes that jump to InvokeDest and fills in the PHI nodes in that block with the values specified in InvokeDestPHIValues. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00523">523</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="InlineFunction_8cpp_source.html#l00379">getUnwindDestToken()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l00641">HandleInlinedEHPad()</a>, and <a class="el" href="InlineFunction_8cpp_source.html#l00584">HandleInlinedLandingPad()</a>.</p>

</div>
</div>
<a id="aac69c9cf4e552a52d5065e94dc023f82" name="aac69c9cf4e552a52d5065e94dc023f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac69c9cf4e552a52d5065e94dc023f82">&#9670;&nbsp;</a></span>HandleInlinedEHPad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HandleInlinedEHPad </td>
          <td>(</td>
          <td class="paramtype">InvokeInst *&#160;</td>
          <td class="paramname"><em>II</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>FirstNewBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClonedCodeInfo &amp;&#160;</td>
          <td class="paramname"><em>InlinedCodeInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we inlined an invoke site, we need to convert calls in the body of the inlined function into invokes. </p>
<p >II is the invoke instruction being inlined. FirstNewBlock is the first block of the inlined code (the last block is the end of the function), and InlineCodeInfo is information about the code that got inlined. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00641">641</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="InlineFunction_8cpp_source.html#l00379">getUnwindDestToken()</a>, <a class="el" href="InlineFunction_8cpp_source.html#l00523">HandleCallsInBlockInlinedThroughInvoke()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="BasicBlockUtils_8cpp_source.html#l00490">UpdatePHINodes()</a>.</p>

</div>
</div>
<a id="a4cbd6aad6f6b93f79dc435feab77550e" name="a4cbd6aad6f6b93f79dc435feab77550e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbd6aad6f6b93f79dc435feab77550e">&#9670;&nbsp;</a></span>HandleInlinedLandingPad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HandleInlinedLandingPad </td>
          <td>(</td>
          <td class="paramtype">InvokeInst *&#160;</td>
          <td class="paramname"><em>II</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>FirstNewBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClonedCodeInfo &amp;&#160;</td>
          <td class="paramname"><em>InlinedCodeInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we inlined an invoke site, we need to convert calls in the body of the inlined function into invokes. </p>
<p >II is the invoke instruction being inlined. FirstNewBlock is the first block of the inlined code (the last block is the end of the function), and InlineCodeInfo is information about the code that got inlined. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00584">584</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlineFunction_8cpp_source.html#l00523">HandleCallsInBlockInlinedThroughInvoke()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="afaa78d0b3224d3175937f997dc2bc688" name="afaa78d0b3224d3175937f997dc2bc688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa78d0b3224d3175937f997dc2bc688">&#9670;&nbsp;</a></span>hasLifetimeMarkers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasLifetimeMarkers </td>
          <td>(</td>
          <td class="paramtype">AllocaInst *&#160;</td>
          <td class="paramname"><em>AI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01324">1324</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="InlineFunction_8cpp_source.html#l01314">isUsedByLifetimeMarker()</a>.</p>

</div>
</div>
<a id="a5217abbfbac8873d22a2dd6cdbb0bcc1" name="a5217abbfbac8873d22a2dd6cdbb0bcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5217abbfbac8873d22a2dd6cdbb0bcc1">&#9670;&nbsp;</a></span>inlineDebugLoc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static DebugLoc inlineDebugLoc </td>
          <td>(</td>
          <td class="paramtype">DebugLoc&#160;</td>
          <td class="paramname"><em>OrigDL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DILocation *&#160;</td>
          <td class="paramname"><em>InlinedAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseMap&lt; const MDNode *, MDNode * &gt; &amp;&#160;</td>
          <td class="paramname"><em>IANodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a DebugLoc for a new DILocation which is a clone of <code>OrigDL</code> inlined at <code>InlinedAt</code>. </p>
<p ><code>IANodes</code> is an inlined-at cache. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01350">1350</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l01388">fixupLineNumbers()</a>, and <a class="el" href="InlineFunction_8cpp_source.html#l01360">inlineLoopID()</a>.</p>

</div>
</div>
<a id="a7718232bb7c0467cb727ea5d15c1f7b0" name="a7718232bb7c0467cb727ea5d15c1f7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7718232bb7c0467cb727ea5d15c1f7b0">&#9670;&nbsp;</a></span>inlineLoopID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MDNode * inlineLoopID </td>
          <td>(</td>
          <td class="paramtype">const MDNode *&#160;</td>
          <td class="paramname"><em>OrigLoopId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DILocation *&#160;</td>
          <td class="paramname"><em>InlinedAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseMap&lt; const MDNode *, MDNode * &gt; &amp;&#160;</td>
          <td class="paramname"><em>IANodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the LoopID for a loop which has has been cloned from another function for inlining with the new inlined-at start and end locs. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01360">1360</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="InlineFunction_8cpp_source.html#l01350">inlineDebugLoc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l01388">fixupLineNumbers()</a>.</p>

</div>
</div>
<a id="ae21f217cd2f8044e639f13111a0b37db" name="ae21f217cd2f8044e639f13111a0b37db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21f217cd2f8044e639f13111a0b37db">&#9670;&nbsp;</a></span>isUsedByLifetimeMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isUsedByLifetimeMarker </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01314">1314</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l01324">hasLifetimeMarkers()</a>.</p>

</div>
</div>
<a id="aaef339dd6477b77cd79503e9bbf0b46a" name="aaef339dd6477b77cd79503e9bbf0b46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef339dd6477b77cd79503e9bbf0b46a">&#9670;&nbsp;</a></span>PreserveAlignmentAssumptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt; PreserveAlignmentAssumptions </td>
          <td>(</td>
          <td class="paramtype">&quot;preserve-alignment-assumptions-during-inlining&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Convert align <a class="el" href="Attributor_8cpp.html#ad84a22c0ca79437f4ec14e006f34e8ed">attributes</a> to assumptions during inlining.&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="InlineFunction_8cpp_source.html#l01141">AddAlignmentAssumptions()</a>.</p>

</div>
</div>
<a id="a3faa7edd99cde25e2d08a0f12d2142d5" name="a3faa7edd99cde25e2d08a0f12d2142d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3faa7edd99cde25e2d08a0f12d2142d5">&#9670;&nbsp;</a></span>PropagateParallelLoopAccessMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PropagateParallelLoopAccessMetadata </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueToValueMapTy &amp;&#160;</td>
          <td class="paramname"><em>VMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When inlining a call site that has !llvm.mem.parallel_loop_access or llvm.access.group metadata, that metadata should be propagated to all memory-accessing cloned instructions. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l00770">770</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

</div>
</div>
<a id="a83a2e4a8c4f5b3b8dee5407d55e8872d" name="a83a2e4a8c4f5b3b8dee5407d55e8872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a2e4a8c4f5b3b8dee5407d55e8872d">&#9670;&nbsp;</a></span>updateCallerBFI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void updateCallerBFI </td>
          <td>(</td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>CallSiteBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueToValueMapTy &amp;&#160;</td>
          <td class="paramname"><em>VMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockFrequencyInfo *&#160;</td>
          <td class="paramname"><em>CallerBFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockFrequencyInfo *&#160;</td>
          <td class="paramname"><em>CalleeBFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasicBlock &amp;&#160;</td>
          <td class="paramname"><em>CalleeEntryBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the block frequencies of the caller after a callee has been inlined. </p>
<p >Each block cloned into the caller has its block frequency scaled by the ratio of CallSiteFreq/CalleeEntryFreq. This ensures that the cloned copy of callee's entry block gets the same frequency as the callsite block and the relative frequencies of all cloned blocks remain the same after cloning. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01450">1450</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

</div>
</div>
<a id="a1d19879a40bcc9f91d922869cc5938f1" name="a1d19879a40bcc9f91d922869cc5938f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d19879a40bcc9f91d922869cc5938f1">&#9670;&nbsp;</a></span>UpdateCallGraphAfterInlining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void UpdateCallGraphAfterInlining </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function::iterator&#160;</td>
          <td class="paramname"><em>FirstNewBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueToValueMapTy &amp;&#160;</td>
          <td class="paramname"><em>VMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InlineFunctionInfo &amp;&#160;</td>
          <td class="paramname"><em>IFI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Once we have cloned code over from a callee into the caller, update the specified callgraph to reflect the changes we made. </p>
<p >Note that it's possible that not all code was copied over, so only some edges of the callgraph may remain. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01179">1179</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a77ae07b5c8f3ce4e725bd2ee09caff7b" name="a77ae07b5c8f3ce4e725bd2ee09caff7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ae07b5c8f3ce4e725bd2ee09caff7b">&#9670;&nbsp;</a></span>updateCallProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void updateCallProfile </td>
          <td>(</td>
          <td class="paramtype">Function *&#160;</td>
          <td class="paramname"><em>Callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueToValueMapTy &amp;&#160;</td>
          <td class="paramname"><em>VMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Function_8cpp.html#ac57dae906fe8ac64efe52571121b0fe1">ProfileCount</a> &amp;&#160;</td>
          <td class="paramname"><em>CalleeEntryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Instruction *&#160;</td>
          <td class="paramname"><em>TheCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProfileSummaryInfo *&#160;</td>
          <td class="paramname"><em>PSI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockFrequencyInfo *&#160;</td>
          <td class="paramname"><em>CallerBFI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the branch metadata for cloned call instructions. </p>

<p class="definition">Definition at line <a class="el" href="InlineFunction_8cpp_source.html#l01479">1479</a> of file <a class="el" href="InlineFunction_8cpp_source.html">InlineFunction.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:44:45 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
