<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: include/llvm/Analysis/ValueTracking.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dcde91663b8816e1e2311938ccd8f690.html">llvm</a></li><li class="navelem"><a class="el" href="dir_97cdd6ae7e6843add574fb55e792badd.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ValueTracking.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;llvm/ADT/ArrayRef.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Optional.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallSet.h&quot;</code><br />
<code>#include &quot;<a class="el" href="CallSite_8h_source.html">llvm/IR/CallSite.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Constants_8h_source.html">llvm/IR/Constants.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DataLayout_8h_source.html">llvm/IR/DataLayout.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Instruction_8h_source.html">llvm/IR/Instruction.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Intrinsics_8h_source.html">llvm/IR/Intrinsics.h</a>&quot;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ValueTracking.h:</div>
<div class="dyncontent">
<div class="center"><img src="ValueTracking_8h__incl.png" border="0" usemap="#ainclude_2llvm_2Analysis_2ValueTracking_8h" alt=""/></div>
<map name="ainclude_2llvm_2Analysis_2ValueTracking_8h" id="ainclude_2llvm_2Analysis_2ValueTracking_8h">
<area shape="rect" title=" " alt="" coords="725,5,886,45"/>
<area shape="rect" title=" " alt="" coords="981,548,1136,573"/>
<area shape="rect" title=" " alt="" coords="817,467,970,493"/>
<area shape="rect" title=" " alt="" coords="5317,93,5473,119"/>
<area shape="rect" href="CallSite_8h.html" title=" " alt="" coords="5158,93,5293,119"/>
<area shape="rect" title=" " alt="" coords="2059,695,2128,720"/>
<area shape="rect" title=" " alt="" coords="2839,548,2905,573"/>
<area shape="rect" href="Constants_8h.html" title="This file contains the declarations for the subclasses of Constant, which represent the different fla..." alt="" coords="2571,313,2720,339"/>
<area shape="rect" href="Instruction_8h.html" title=" " alt="" coords="4069,387,4222,412"/>
<area shape="rect" href="DataLayout_8h.html" title=" " alt="" coords="1215,313,1374,339"/>
<area shape="rect" href="Intrinsics_8h.html" title=" " alt="" coords="518,387,661,412"/>
<area shape="rect" title=" " alt="" coords="6203,695,6387,720"/>
<area shape="rect" title=" " alt="" coords="5875,621,6066,647"/>
<area shape="rect" href="Attributes_8h.html" title="This file contains the simple types necessary to represent the attributes associated with functions a..." alt="" coords="3591,387,3739,412"/>
<area shape="rect" href="CallingConv_8h.html" title=" " alt="" coords="5637,387,5798,412"/>
<area shape="rect" href="Function_8h.html" title=" " alt="" coords="5012,313,5151,339"/>
<area shape="rect" href="Casting_8h.html" title=" " alt="" coords="3389,621,3560,647"/>
<area shape="rect" title=" " alt="" coords="5678,621,5749,647"/>
<area shape="rect" href="User_8h.html" title=" " alt="" coords="4981,467,5094,493"/>
<area shape="rect" href="Use_8h.html" title="This defines the Use class." alt="" coords="6091,621,6200,647"/>
<area shape="rect" href="Value_8h.html" title=" " alt="" coords="5777,548,5897,573"/>
<area shape="rect" href="InstrTypes_8h.html" title=" " alt="" coords="3301,240,3451,265"/>
<area shape="rect" href="Instructions_8h.html" title=" " alt="" coords="3907,167,4067,192"/>
<area shape="rect" title=" " alt="" coords="5779,695,5895,720"/>
<area shape="rect" title=" " alt="" coords="3390,467,3557,493"/>
<area shape="rect" title=" " alt="" coords="3005,467,3163,493"/>
<area shape="rect" title=" " alt="" coords="3795,768,3981,793"/>
<area shape="rect" href="PointerLikeTypeTraits_8h.html" title=" " alt="" coords="3581,460,3763,500"/>
<area shape="rect" title=" " alt="" coords="916,621,975,647"/>
<area shape="rect" title=" " alt="" coords="3889,467,3949,493"/>
<area shape="rect" title=" " alt="" coords="4693,467,4854,493"/>
<area shape="rect" href="DerivedTypes_8h.html" title=" " alt="" coords="2259,387,2431,412"/>
<area shape="rect" href="Compiler_8h.html" title=" " alt="" coords="3697,695,3876,720"/>
<area shape="rect" href="OperandTraits_8h.html" title=" " alt="" coords="4767,387,4942,412"/>
<area shape="rect" title=" " alt="" coords="5429,548,5499,573"/>
<area shape="rect" href="SymbolTableListTraits_8h.html" title=" " alt="" coords="5219,467,5445,493"/>
<area shape="rect" title=" " alt="" coords="1349,467,1512,493"/>
<area shape="rect" href="Type_8h.html" title=" " alt="" coords="1840,467,1955,493"/>
<area shape="rect" title=" " alt="" coords="1718,548,1866,573"/>
<area shape="rect" href="ErrorHandling_8h.html" title=" " alt="" coords="1160,548,1371,573"/>
<area shape="rect" title=" " alt="" coords="2486,467,2618,493"/>
<area shape="rect" title=" " alt="" coords="2845,467,2931,493"/>
<area shape="rect" title=" " alt="" coords="4399,467,4566,493"/>
<area shape="rect" title=" " alt="" coords="2455,387,2587,412"/>
<area shape="rect" href="Constant_8h.html" title=" " alt="" coords="4549,387,4691,412"/>
<area shape="rect" href="DebugLoc_8h.html" title=" " alt="" coords="4227,467,4375,493"/>
<area shape="rect" title=" " alt="" coords="1502,387,1677,412"/>
<area shape="rect" title=" " alt="" coords="347,387,443,412"/>
<area shape="rect" href="MathExtras_8h.html" title=" " alt="" coords="2916,387,3111,412"/>
<area shape="rect" title=" " alt="" coords="398,467,589,493"/>
</map>
</div>
</div>
<p><a href="ValueTracking_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1ConstantDataArraySlice.html">llvm::ConstantDataArraySlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents offset+length into a <a class="el" href="classllvm_1_1ConstantDataArray.html" title="An array constant whose element type is a simple 1/2/4/8-byte integer or float/double,...">ConstantDataArray</a>.  <a href="structllvm_1_1ConstantDataArraySlice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1SelectPatternResult.html">llvm::SelectPatternResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellvm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents lattice values for constants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06c60fef11885eadbda4026c83ae9a13"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13">llvm::OverflowResult</a> { <a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13ac8cc76d76703c81c16e939be370683c1">llvm::AlwaysOverflowsLow</a>
, <a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13a9ac50ff0c308dad407db9f09e418363e">llvm::AlwaysOverflowsHigh</a>
, <a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13ad4d9862eafa015a05101d9f662bb153a">llvm::MayOverflow</a>
, <a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13a56624a95592b438e05ab500a6a200a03">llvm::NeverOverflows</a>
 }</td></tr>
<tr class="separator:a06c60fef11885eadbda4026c83ae9a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf471c1030973649c2e426afc212097"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097">llvm::SelectPatternFlavor</a> { <br />
&#160;&#160;<a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097aee3dafa9fac8f6fa1e1110ef463cc452">llvm::SPF_UNKNOWN</a> = 0
, <a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097abfed1bd97e2e6b014cbe76e02930d54b">llvm::SPF_SMIN</a>
, <a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097a6afb3549f5028760be1bbf8ae7c04d73">llvm::SPF_UMIN</a>
, <a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097ac8062350ff8114c3ffe79a339f2a1ece">llvm::SPF_SMAX</a>
, <br />
&#160;&#160;<a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097a7d51d0dcfc2cc79738c77f8f5fa37138">llvm::SPF_UMAX</a>
, <a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097af8501f966f0a266e7b59b4deded487b2">llvm::SPF_FMINNUM</a>
, <a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097a116eaa2ed0eed4cedf6f4cd1a47d02c4">llvm::SPF_FMAXNUM</a>
, <a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097a07d293fd946951d9655259c5e9b93356">llvm::SPF_ABS</a>
, <br />
&#160;&#160;<a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097a08658871fecea100ad724bd8b1c3ae56">llvm::SPF_NABS</a>
<br />
 }</td></tr>
<tr class="memdesc:a6bf471c1030973649c2e426afc212097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific patterns of select instructions we can match.  <a href="namespacellvm.html#a6bf471c1030973649c2e426afc212097">More...</a><br /></td></tr>
<tr class="separator:a6bf471c1030973649c2e426afc212097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ec0705ee0a9265c1533bad94aae26f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ab1ec0705ee0a9265c1533bad94aae26f">llvm::SelectPatternNaNBehavior</a> { <a class="el" href="namespacellvm.html#ab1ec0705ee0a9265c1533bad94aae26fae6c7ef1308ad90f95d225833ec25c20a">llvm::SPNB_NA</a> = 0
, <a class="el" href="namespacellvm.html#ab1ec0705ee0a9265c1533bad94aae26fa2610effcbc2615f0fcfbe0ee747c3330">llvm::SPNB_RETURNS_NAN</a>
, <a class="el" href="namespacellvm.html#ab1ec0705ee0a9265c1533bad94aae26fa5cd1411c63760bbac408465c8d441b35">llvm::SPNB_RETURNS_OTHER</a>
, <a class="el" href="namespacellvm.html#ab1ec0705ee0a9265c1533bad94aae26fac2ebfba0cc0df319e24facde2e888726">llvm::SPNB_RETURNS_ANY</a>
 }</td></tr>
<tr class="memdesc:ab1ec0705ee0a9265c1533bad94aae26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behavior when a floating point min/max is given one NaN and one non-NaN as input.  <a href="namespacellvm.html#ab1ec0705ee0a9265c1533bad94aae26f">More...</a><br /></td></tr>
<tr class="separator:ab1ec0705ee0a9265c1533bad94aae26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa1f8f0633edd8b9a1c5ec15bb9fc5640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa1f8f0633edd8b9a1c5ec15bb9fc5640">llvm::computeKnownBits</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="structllvm_1_1KnownBits.html">KnownBits</a> &amp;Known, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classllvm_1_1OptimizationRemarkEmitter.html">OptimizationRemarkEmitter</a> *ORE=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:aa1f8f0633edd8b9a1c5ec15bb9fc5640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which bits of V are known to be either zero or one and return them in the KnownZero/KnownOne bit sets.  <a href="namespacellvm.html#aa1f8f0633edd8b9a1c5ec15bb9fc5640">More...</a><br /></td></tr>
<tr class="separator:aa1f8f0633edd8b9a1c5ec15bb9fc5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abd8efdfe0dfb749dfa324d2d52ee3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllvm_1_1KnownBits.html">KnownBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7abd8efdfe0dfb749dfa324d2d52ee3d">llvm::computeKnownBits</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classllvm_1_1OptimizationRemarkEmitter.html">OptimizationRemarkEmitter</a> *ORE=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:a7abd8efdfe0dfb749dfa324d2d52ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the known bits rather than passing by reference.  <a href="namespacellvm.html#a7abd8efdfe0dfb749dfa324d2d52ee3d">More...</a><br /></td></tr>
<tr class="separator:a7abd8efdfe0dfb749dfa324d2d52ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae277e0144afb92a90c24163fb4898f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae277e0144afb92a90c24163fb4898f02">llvm::computeKnownBitsFromRangeMetadata</a> (const <a class="el" href="classllvm_1_1MDNode.html">MDNode</a> &amp;Ranges, <a class="el" href="structllvm_1_1KnownBits.html">KnownBits</a> &amp;Known)</td></tr>
<tr class="memdesc:ae277e0144afb92a90c24163fb4898f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute known bits from the range metadata.  <a href="namespacellvm.html#ae277e0144afb92a90c24163fb4898f02">More...</a><br /></td></tr>
<tr class="separator:ae277e0144afb92a90c24163fb4898f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f28bd61d319f9fd170e9ffee1ec7ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa0f28bd61d319f9fd170e9ffee1ec7ba">llvm::haveNoCommonBitsSet</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, const <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:aa0f28bd61d319f9fd170e9ffee1ec7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if LHS and RHS have no common bits set.  <a href="namespacellvm.html#aa0f28bd61d319f9fd170e9ffee1ec7ba">More...</a><br /></td></tr>
<tr class="separator:aa0f28bd61d319f9fd170e9ffee1ec7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4036c3c75bcee1206cd199548b87f9ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4036c3c75bcee1206cd199548b87f9ae">llvm::isKnownToBeAPowerOfTwo</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classbool.html">bool</a> OrZero=false, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:a4036c3c75bcee1206cd199548b87f9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given value is known to have exactly one bit set when defined.  <a href="namespacellvm.html#a4036c3c75bcee1206cd199548b87f9ae">More...</a><br /></td></tr>
<tr class="separator:a4036c3c75bcee1206cd199548b87f9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4687f9c44e149d4893bd81b7ddce3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a1c4687f9c44e149d4893bd81b7ddce3b">llvm::isOnlyUsedInZeroEqualityComparison</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI)</td></tr>
<tr class="separator:a1c4687f9c44e149d4893bd81b7ddce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07256e6859fcb3b9d5eb02ecea9e9a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a07256e6859fcb3b9d5eb02ecea9e9a38">llvm::isKnownNonZero</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:a07256e6859fcb3b9d5eb02ecea9e9a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given value is known to be non-zero when defined.  <a href="namespacellvm.html#a07256e6859fcb3b9d5eb02ecea9e9a38">More...</a><br /></td></tr>
<tr class="separator:a07256e6859fcb3b9d5eb02ecea9e9a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15235832ef7c31b1d789987f9a656b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a15235832ef7c31b1d789987f9a656b43">llvm::isKnownNegation</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X</a>, const <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="Hello_8cpp.html#ac3d32b43305241160f8c774e4ce25824">Y</a>, <a class="el" href="classbool.html">bool</a> NeedNSW=false)</td></tr>
<tr class="memdesc:a15235832ef7c31b1d789987f9a656b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the two given values are negation.  <a href="namespacellvm.html#a15235832ef7c31b1d789987f9a656b43">More...</a><br /></td></tr>
<tr class="separator:a15235832ef7c31b1d789987f9a656b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0be0d93ccd89dac00411b3a5a8bef87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac0be0d93ccd89dac00411b3a5a8bef87">llvm::isKnownNonNegative</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:ac0be0d93ccd89dac00411b3a5a8bef87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the give value is known to be non-negative.  <a href="namespacellvm.html#ac0be0d93ccd89dac00411b3a5a8bef87">More...</a><br /></td></tr>
<tr class="separator:ac0be0d93ccd89dac00411b3a5a8bef87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02061a5619c04262c3a5f48c3ef8a033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a02061a5619c04262c3a5f48c3ef8a033">llvm::isKnownPositive</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:a02061a5619c04262c3a5f48c3ef8a033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given value is known be positive (i.e.  <a href="namespacellvm.html#a02061a5619c04262c3a5f48c3ef8a033">More...</a><br /></td></tr>
<tr class="separator:a02061a5619c04262c3a5f48c3ef8a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87505e09bfcea3ff7675e8e014745b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa87505e09bfcea3ff7675e8e014745b2">llvm::isKnownNegative</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:aa87505e09bfcea3ff7675e8e014745b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given value is known be negative (i.e.  <a href="namespacellvm.html#aa87505e09bfcea3ff7675e8e014745b2">More...</a><br /></td></tr>
<tr class="separator:aa87505e09bfcea3ff7675e8e014745b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9afd47568010f063c6ca4ed6473db03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa9afd47568010f063c6ca4ed6473db03">llvm::isKnownNonEqual</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V1, const <a class="el" href="classllvm_1_1Value.html">Value</a> *V2, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:aa9afd47568010f063c6ca4ed6473db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given values are known to be non-equal when defined.  <a href="namespacellvm.html#aa9afd47568010f063c6ca4ed6473db03">More...</a><br /></td></tr>
<tr class="separator:aa9afd47568010f063c6ca4ed6473db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbf3998b4ff72347a45cb4169d120db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aedbf3998b4ff72347a45cb4169d120db">llvm::MaskedValueIsZero</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const APInt &amp;Mask, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:aedbf3998b4ff72347a45cb4169d120db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if 'V &amp; Mask' is known to be zero.  <a href="namespacellvm.html#aedbf3998b4ff72347a45cb4169d120db">More...</a><br /></td></tr>
<tr class="separator:aedbf3998b4ff72347a45cb4169d120db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46ed333b920b20e78d948610366254c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad46ed333b920b20e78d948610366254c">llvm::ComputeNumSignBits</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *Op, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> Depth=0, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:ad46ed333b920b20e78d948610366254c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of times the sign bit of the register is replicated into the other bits.  <a href="namespacellvm.html#ad46ed333b920b20e78d948610366254c">More...</a><br /></td></tr>
<tr class="separator:ad46ed333b920b20e78d948610366254c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad8b72e67d188e6a62dac7f02779ffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9ad8b72e67d188e6a62dac7f02779ffc">llvm::ComputeMultiple</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> Base, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;Multiple, <a class="el" href="classbool.html">bool</a> LookThroughSExt=false, <a class="el" href="classunsigned.html">unsigned</a> Depth=0)</td></tr>
<tr class="memdesc:a9ad8b72e67d188e6a62dac7f02779ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the integer multiple of Base that equals V.  <a href="namespacellvm.html#a9ad8b72e67d188e6a62dac7f02779ffc">More...</a><br /></td></tr>
<tr class="separator:a9ad8b72e67d188e6a62dac7f02779ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f4c0db42b15a541875e487ab073c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm_1_1Intrinsic.html#a2bbee8c5fe6b399c136d84248090178b">Intrinsic::ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac7f4c0db42b15a541875e487ab073c51">llvm::getIntrinsicForCallSite</a> (<a class="el" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> ICS, const <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *TLI)</td></tr>
<tr class="memdesc:ac7f4c0db42b15a541875e487ab073c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a call instruction to an intrinsic ID.  <a href="namespacellvm.html#ac7f4c0db42b15a541875e487ab073c51">More...</a><br /></td></tr>
<tr class="separator:ac7f4c0db42b15a541875e487ab073c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23e16c67aeaf23c68bf86fe04df42ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae23e16c67aeaf23c68bf86fe04df42ee">llvm::CannotBeNegativeZero</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *TLI, <a class="el" href="classunsigned.html">unsigned</a> Depth=0)</td></tr>
<tr class="memdesc:ae23e16c67aeaf23c68bf86fe04df42ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can prove that the specified FP value is never equal to -0.0.  <a href="namespacellvm.html#ae23e16c67aeaf23c68bf86fe04df42ee">More...</a><br /></td></tr>
<tr class="separator:ae23e16c67aeaf23c68bf86fe04df42ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a678aed09084c04a53e1d9ebbc0534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae0a678aed09084c04a53e1d9ebbc0534">llvm::CannotBeOrderedLessThanZero</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *TLI)</td></tr>
<tr class="memdesc:ae0a678aed09084c04a53e1d9ebbc0534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can prove that the specified FP value is either NaN or never less than -0.0.  <a href="namespacellvm.html#ae0a678aed09084c04a53e1d9ebbc0534">More...</a><br /></td></tr>
<tr class="separator:ae0a678aed09084c04a53e1d9ebbc0534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c88ebe757c51044c4ad4275012e4593"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4c88ebe757c51044c4ad4275012e4593">llvm::isKnownNeverNaN</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *TLI, <a class="el" href="classunsigned.html">unsigned</a> Depth=0)</td></tr>
<tr class="memdesc:a4c88ebe757c51044c4ad4275012e4593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the floating-point scalar value is not a NaN or if the floating-point vector value has no NaN elements.  <a href="namespacellvm.html#a4c88ebe757c51044c4ad4275012e4593">More...</a><br /></td></tr>
<tr class="separator:a4c88ebe757c51044c4ad4275012e4593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a51681428d4b7e3770680a9f1ae925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad0a51681428d4b7e3770680a9f1ae925">llvm::SignBitMustBeZero</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *TLI)</td></tr>
<tr class="memdesc:ad0a51681428d4b7e3770680a9f1ae925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can prove that the specified FP value's sign bit is 0.  <a href="namespacellvm.html#ad0a51681428d4b7e3770680a9f1ae925">More...</a><br /></td></tr>
<tr class="separator:ad0a51681428d4b7e3770680a9f1ae925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab8f775ddc87695d750e4838231b3ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#acab8f775ddc87695d750e4838231b3ba">llvm::isBytewiseValue</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:acab8f775ddc87695d750e4838231b3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified value can be set by repeating the same byte in memory, return the i8 value that it is represented with.  <a href="namespacellvm.html#acab8f775ddc87695d750e4838231b3ba">More...</a><br /></td></tr>
<tr class="separator:acab8f775ddc87695d750e4838231b3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1180e486b493407122bb7dd0483c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a63c1180e486b493407122bb7dd0483c6">llvm::FindInsertedValue</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; idx_range, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *InsertBefore=nullptr)</td></tr>
<tr class="memdesc:a63c1180e486b493407122bb7dd0483c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an aggregrate and an sequence of indices, see if the scalar value indexed is already around as a register, for example if it were inserted directly into the aggregrate.  <a href="namespacellvm.html#a63c1180e486b493407122bb7dd0483c6">More...</a><br /></td></tr>
<tr class="separator:a63c1180e486b493407122bb7dd0483c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657bd921c879fe03b079e1744ad2910c"><td class="memItemLeft" align="right" valign="top">Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a657bd921c879fe03b079e1744ad2910c">llvm::GetPointerBaseWithConstantOffset</a> (Value *Ptr, int64_t &amp;Offset, const DataLayout &amp;DL)</td></tr>
<tr class="memdesc:a657bd921c879fe03b079e1744ad2910c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the specified pointer to see if it can be expressed as a base pointer plus a constant offset.  <a href="namespacellvm.html#a657bd921c879fe03b079e1744ad2910c">More...</a><br /></td></tr>
<tr class="separator:a657bd921c879fe03b079e1744ad2910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74867396c0ce1d15e3eb440ff6d91d69"><td class="memItemLeft" align="right" valign="top">const Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a74867396c0ce1d15e3eb440ff6d91d69">llvm::GetPointerBaseWithConstantOffset</a> (const Value *Ptr, int64_t &amp;Offset, const DataLayout &amp;DL)</td></tr>
<tr class="separator:a74867396c0ce1d15e3eb440ff6d91d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8f600187cb9c664701443e796111e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ade8f600187cb9c664701443e796111e7">llvm::isGEPBasedOnPointerToString</a> (const <a class="el" href="classllvm_1_1GEPOperator.html">GEPOperator</a> *GEP, <a class="el" href="classunsigned.html">unsigned</a> CharSize=8)</td></tr>
<tr class="memdesc:ade8f600187cb9c664701443e796111e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the GEP is based on a pointer to a string (array of.  <a href="namespacellvm.html#ade8f600187cb9c664701443e796111e7">More...</a><br /></td></tr>
<tr class="separator:ade8f600187cb9c664701443e796111e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b03d4697c30b32e8762cb0dfd66761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a36b03d4697c30b32e8762cb0dfd66761">llvm::getConstantDataArrayInfo</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="structllvm_1_1ConstantDataArraySlice.html">ConstantDataArraySlice</a> &amp;Slice, <a class="el" href="classunsigned.html">unsigned</a> ElementSize, uint64_t Offset=0)</td></tr>
<tr class="memdesc:a36b03d4697c30b32e8762cb0dfd66761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the value <code>V</code> is a pointer into a <a class="el" href="classllvm_1_1ConstantDataArray.html" title="An array constant whose element type is a simple 1/2/4/8-byte integer or float/double,...">ConstantDataArray</a>.  <a href="namespacellvm.html#a36b03d4697c30b32e8762cb0dfd66761">More...</a><br /></td></tr>
<tr class="separator:a36b03d4697c30b32e8762cb0dfd66761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d195fefcf9fab4b08703860991c14c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a66d195fefcf9fab4b08703860991c14c">llvm::getConstantStringInfo</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, StringRef &amp;Str, uint64_t Offset=0, <a class="el" href="classbool.html">bool</a> TrimAtNul=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:a66d195fefcf9fab4b08703860991c14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the length of a null-terminated C string pointed to by V.  <a href="namespacellvm.html#a66d195fefcf9fab4b08703860991c14c">More...</a><br /></td></tr>
<tr class="separator:a66d195fefcf9fab4b08703860991c14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ed66258951782b18db38fb510cca4d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a86ed66258951782b18db38fb510cca4d">llvm::GetStringLength</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> CharSize=8)</td></tr>
<tr class="memdesc:a86ed66258951782b18db38fb510cca4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we can compute the length of the string pointed to by the specified pointer, return 'len+1'.  <a href="namespacellvm.html#a86ed66258951782b18db38fb510cca4d">More...</a><br /></td></tr>
<tr class="separator:a86ed66258951782b18db38fb510cca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3fff5cb4ae04dd2263413741a7f868"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9b3fff5cb4ae04dd2263413741a7f868">llvm::getArgumentAliasingToReturnedPointer</a> (const <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *Call)</td></tr>
<tr class="memdesc:a9b3fff5cb4ae04dd2263413741a7f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns call pointer argument that is considered the same by aliasing rules.  <a href="namespacellvm.html#a9b3fff5cb4ae04dd2263413741a7f868">More...</a><br /></td></tr>
<tr class="separator:a9b3fff5cb4ae04dd2263413741a7f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4df499084b23f97cc9001be8bdfd03"><td class="memItemLeft" align="right" valign="top">Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2f4df499084b23f97cc9001be8bdfd03">llvm::getArgumentAliasingToReturnedPointer</a> (CallBase *Call)</td></tr>
<tr class="separator:a2f4df499084b23f97cc9001be8bdfd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ac77398c293135ac33012d15059f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a10ac77398c293135ac33012d15059f88">llvm::isIntrinsicReturningPointerAliasingArgumentWithoutCapturing</a> (const <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *Call)</td></tr>
<tr class="separator:a10ac77398c293135ac33012d15059f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8d41e9958a4ff2156f1f03f26a2eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a5a8d41e9958a4ff2156f1f03f26a2eb3">llvm::GetUnderlyingObject</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> MaxLookup=6)</td></tr>
<tr class="memdesc:a5a8d41e9958a4ff2156f1f03f26a2eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method strips off any GEP address adjustments and pointer casts from the specified value, returning the original object being addressed.  <a href="namespacellvm.html#a5a8d41e9958a4ff2156f1f03f26a2eb3">More...</a><br /></td></tr>
<tr class="separator:a5a8d41e9958a4ff2156f1f03f26a2eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb893a5fa475c76e54b4dc7a1dfc79"><td class="memItemLeft" align="right" valign="top">const Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2cbb893a5fa475c76e54b4dc7a1dfc79">llvm::GetUnderlyingObject</a> (const Value *V, const DataLayout &amp;DL, <a class="el" href="classunsigned.html">unsigned</a> MaxLookup=6)</td></tr>
<tr class="separator:a2cbb893a5fa475c76e54b4dc7a1dfc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a770cf6191aa90550541005f034c850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2a770cf6191aa90550541005f034c850">llvm::GetUnderlyingObjects</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Objects, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI=nullptr, <a class="el" href="classunsigned.html">unsigned</a> MaxLookup=6)</td></tr>
<tr class="memdesc:a2a770cf6191aa90550541005f034c850"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is similar to GetUnderlyingObject except that it can look through phi and select instructions and return multiple objects.  <a href="namespacellvm.html#a2a770cf6191aa90550541005f034c850">More...</a><br /></td></tr>
<tr class="separator:a2a770cf6191aa90550541005f034c850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760dbc3f5da8a94bc8ba571052052635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a760dbc3f5da8a94bc8ba571052052635">llvm::getUnderlyingObjectsForCodeGen</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Objects, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:a760dbc3f5da8a94bc8ba571052052635"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper around GetUnderlyingObjects and adds support for basic ptrtoint+arithmetic+inttoptr sequences.  <a href="namespacellvm.html#a760dbc3f5da8a94bc8ba571052052635">More...</a><br /></td></tr>
<tr class="separator:a760dbc3f5da8a94bc8ba571052052635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0a7040918ba81ef34046fd474cee10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9d0a7040918ba81ef34046fd474cee10">llvm::onlyUsedByLifetimeMarkers</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="memdesc:a9d0a7040918ba81ef34046fd474cee10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the only users of this pointer are lifetime markers.  <a href="namespacellvm.html#a9d0a7040918ba81ef34046fd474cee10">More...</a><br /></td></tr>
<tr class="separator:a9d0a7040918ba81ef34046fd474cee10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5ed0e8a5d5711fee0cbc3790a4ced5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7d5ed0e8a5d5711fee0cbc3790a4ced5">llvm::isSafeToSpeculativelyExecute</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CtxI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr)</td></tr>
<tr class="memdesc:a7d5ed0e8a5d5711fee0cbc3790a4ced5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the instruction does not have any effects besides calculating the result and does not have undefined behavior.  <a href="namespacellvm.html#a7d5ed0e8a5d5711fee0cbc3790a4ced5">More...</a><br /></td></tr>
<tr class="separator:a7d5ed0e8a5d5711fee0cbc3790a4ced5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11263a14b274edd513efcddabd9feb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a11263a14b274edd513efcddabd9feb27">llvm::mayBeMemoryDependent</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:a11263a14b274edd513efcddabd9feb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the result or effects of the given instructions <code>I</code> depend on or influence global memory.  <a href="namespacellvm.html#a11263a14b274edd513efcddabd9feb27">More...</a><br /></td></tr>
<tr class="separator:a11263a14b274edd513efcddabd9feb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2f83d3af349e89d62c6277ba668b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a1f2f83d3af349e89d62c6277ba668b4f">llvm::isAssumeLikeIntrinsic</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:a1f2f83d3af349e89d62c6277ba668b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is an intrinsic that cannot be speculated but also cannot trap.  <a href="namespacellvm.html#a1f2f83d3af349e89d62c6277ba668b4f">More...</a><br /></td></tr>
<tr class="separator:a1f2f83d3af349e89d62c6277ba668b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d57d70f59588a35ebfe3c4f50fecd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af1d57d70f59588a35ebfe3c4f50fecd2">llvm::isValidAssumeForContext</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr)</td></tr>
<tr class="memdesc:af1d57d70f59588a35ebfe3c4f50fecd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is valid to use the assumptions provided by an assume intrinsic, I, at the point in the control-flow identified by the context instruction, CxtI.  <a href="namespacellvm.html#af1d57d70f59588a35ebfe3c4f50fecd2">More...</a><br /></td></tr>
<tr class="separator:af1d57d70f59588a35ebfe3c4f50fecd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b63d7ba7f620e5f036b2d188393245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a24b63d7ba7f620e5f036b2d188393245">llvm::computeOverflowForUnsignedMul</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, const <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="separator:a24b63d7ba7f620e5f036b2d188393245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0844b1df9a5ba7f45716415965966e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0844b1df9a5ba7f45716415965966e63">llvm::computeOverflowForSignedMul</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, const <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="separator:a0844b1df9a5ba7f45716415965966e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a93234b99e09100376f8a8a503ca44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af4a93234b99e09100376f8a8a503ca44">llvm::computeOverflowForUnsignedAdd</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, const <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="separator:af4a93234b99e09100376f8a8a503ca44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2af9794c01bcd5e098a24c80c8410f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a1f2af9794c01bcd5e098a24c80c8410f">llvm::computeOverflowForSignedAdd</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, const <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr)</td></tr>
<tr class="separator:a1f2af9794c01bcd5e098a24c80c8410f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1dc07f82ca73685f50e3550ad12647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ada1dc07f82ca73685f50e3550ad12647">llvm::computeOverflowForSignedAdd</a> (const <a class="el" href="classllvm_1_1AddOperator.html">AddOperator</a> *Add, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC=nullptr, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=nullptr, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT=nullptr)</td></tr>
<tr class="memdesc:ada1dc07f82ca73685f50e3550ad12647"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version also leverages the sign bit of Add if known.  <a href="namespacellvm.html#ada1dc07f82ca73685f50e3550ad12647">More...</a><br /></td></tr>
<tr class="separator:ada1dc07f82ca73685f50e3550ad12647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a02293c780a5f242786686646db5130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9a02293c780a5f242786686646db5130">llvm::computeOverflowForUnsignedSub</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, const <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT)</td></tr>
<tr class="separator:a9a02293c780a5f242786686646db5130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101ff77214c2a41c0b769a81311b819a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a06c60fef11885eadbda4026c83ae9a13">OverflowResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a101ff77214c2a41c0b769a81311b819a">llvm::computeOverflowForSignedSub</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, const <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT)</td></tr>
<tr class="separator:a101ff77214c2a41c0b769a81311b819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5804b68ebc77c8751a9cb4e066735450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a5804b68ebc77c8751a9cb4e066735450">llvm::isOverflowIntrinsicNoWrap</a> (const <a class="el" href="classllvm_1_1WithOverflowInst.html">WithOverflowInst</a> *WO, const <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> &amp;DT)</td></tr>
<tr class="memdesc:a5804b68ebc77c8751a9cb4e066735450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the arithmetic part of the <code>WO</code> 's result is used only along the paths control dependent on the computation not overflowing, <code>WO</code> being an &lt;op&gt;.with.overflow intrinsic.  <a href="namespacellvm.html#a5804b68ebc77c8751a9cb4e066735450">More...</a><br /></td></tr>
<tr class="separator:a5804b68ebc77c8751a9cb4e066735450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221cdc865faa8ef2c53c73aa86659316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ConstantRange.html">ConstantRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a221cdc865faa8ef2c53c73aa86659316">llvm::computeConstantRange</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classbool.html">bool</a> UseInstrInfo=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</td></tr>
<tr class="memdesc:a221cdc865faa8ef2c53c73aa86659316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the possible constant range of an integer or vector of integer value.  <a href="namespacellvm.html#a221cdc865faa8ef2c53c73aa86659316">More...</a><br /></td></tr>
<tr class="separator:a221cdc865faa8ef2c53c73aa86659316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff5a423c1f45e23958dde8ee695c9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abff5a423c1f45e23958dde8ee695c9a9">llvm::isGuaranteedToTransferExecutionToSuccessor</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:abff5a423c1f45e23958dde8ee695c9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this function can prove that the instruction I will always transfer execution to one of its successors (including the next instruction that follows within a basic block).  <a href="namespacellvm.html#abff5a423c1f45e23958dde8ee695c9a9">More...</a><br /></td></tr>
<tr class="separator:abff5a423c1f45e23958dde8ee695c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9659b203ee34c620fb571aa13a7bed13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9659b203ee34c620fb571aa13a7bed13">llvm::isGuaranteedToTransferExecutionToSuccessor</a> (const <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *BB)</td></tr>
<tr class="memdesc:a9659b203ee34c620fb571aa13a7bed13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this block does not contain a potential implicit exit.  <a href="namespacellvm.html#a9659b203ee34c620fb571aa13a7bed13">More...</a><br /></td></tr>
<tr class="separator:a9659b203ee34c620fb571aa13a7bed13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c5c77cf4a7ffed6a6576ebebd1929a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a38c5c77cf4a7ffed6a6576ebebd1929a">llvm::isGuaranteedToExecuteForEveryIteration</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, const <a class="el" href="classllvm_1_1Loop.html">Loop</a> *L)</td></tr>
<tr class="memdesc:a38c5c77cf4a7ffed6a6576ebebd1929a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this function can prove that the instruction I is executed for every iteration of the loop L.  <a href="namespacellvm.html#a38c5c77cf4a7ffed6a6576ebebd1929a">More...</a><br /></td></tr>
<tr class="separator:a38c5c77cf4a7ffed6a6576ebebd1929a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a21b26967f4e9f6f92e4d2aff1e0fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af2a21b26967f4e9f6f92e4d2aff1e0fb">llvm::propagatesFullPoison</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:af2a21b26967f4e9f6f92e4d2aff1e0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this function can prove that I is guaranteed to yield full-poison (all bits poison) if at least one of its operands are full-poison (all bits poison).  <a href="namespacellvm.html#af2a21b26967f4e9f6f92e4d2aff1e0fb">More...</a><br /></td></tr>
<tr class="separator:af2a21b26967f4e9f6f92e4d2aff1e0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc71a983e204bf8cab8816d52e6aedc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0dc71a983e204bf8cab8816d52e6aedc">llvm::getGuaranteedNonFullPoisonOp</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:a0dc71a983e204bf8cab8816d52e6aedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return either nullptr or an operand of I such that I will trigger undefined behavior if I is executed and that operand has a full-poison value (all bits poison).  <a href="namespacellvm.html#a0dc71a983e204bf8cab8816d52e6aedc">More...</a><br /></td></tr>
<tr class="separator:a0dc71a983e204bf8cab8816d52e6aedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b587899173512a007250b3f5307441d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9b587899173512a007250b3f5307441d">llvm::mustTriggerUB</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, const SmallSet&lt; const <a class="el" href="classllvm_1_1Value.html">Value</a> *, 16 &gt; &amp;KnownPoison)</td></tr>
<tr class="memdesc:a9b587899173512a007250b3f5307441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given instruction must trigger undefined behavior.  <a href="namespacellvm.html#a9b587899173512a007250b3f5307441d">More...</a><br /></td></tr>
<tr class="separator:a9b587899173512a007250b3f5307441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8744c559b478647e026375a5157b4540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a8744c559b478647e026375a5157b4540">llvm::programUndefinedIfFullPoison</a> (const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *PoisonI)</td></tr>
<tr class="memdesc:a8744c559b478647e026375a5157b4540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this function can prove that if PoisonI is executed and yields a full-poison value (all bits poison), then that will trigger undefined behavior.  <a href="namespacellvm.html#a8744c559b478647e026375a5157b4540">More...</a><br /></td></tr>
<tr class="separator:a8744c559b478647e026375a5157b4540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aad5a0e62a54747f455651ee2dd08ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllvm_1_1SelectPatternResult.html">SelectPatternResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7aad5a0e62a54747f455651ee2dd08ed">llvm::matchSelectPattern</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;LHS, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;RHS, <a class="el" href="classllvm_1_1Instruction.html#afa0b2fa29ba074f2b6ec9ac11163f2d9">Instruction::CastOps</a> *CastOp=nullptr, <a class="el" href="classunsigned.html">unsigned</a> Depth=0)</td></tr>
<tr class="memdesc:a7aad5a0e62a54747f455651ee2dd08ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern match integer [SU]MIN, [SU]MAX and ABS idioms, returning the kind and providing the out parameter results if we successfully match.  <a href="namespacellvm.html#a7aad5a0e62a54747f455651ee2dd08ed">More...</a><br /></td></tr>
<tr class="separator:a7aad5a0e62a54747f455651ee2dd08ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31074570457fa698e440045e86ffd563"><td class="memItemLeft" align="right" valign="top">SelectPatternResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a31074570457fa698e440045e86ffd563">llvm::matchSelectPattern</a> (const Value *V, const Value *&amp;LHS, const Value *&amp;RHS, Instruction::CastOps *CastOp=nullptr)</td></tr>
<tr class="separator:a31074570457fa698e440045e86ffd563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf62ca503c047621e9b9047c548f231f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllvm_1_1SelectPatternResult.html">SelectPatternResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abf62ca503c047621e9b9047c548f231f">llvm::matchDecomposedSelectPattern</a> (<a class="el" href="classllvm_1_1CmpInst.html">CmpInst</a> *CmpI, <a class="el" href="classllvm_1_1Value.html">Value</a> *TrueVal, <a class="el" href="classllvm_1_1Value.html">Value</a> *FalseVal, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;LHS, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;RHS, <a class="el" href="classllvm_1_1Instruction.html#afa0b2fa29ba074f2b6ec9ac11163f2d9">Instruction::CastOps</a> *CastOp=nullptr, <a class="el" href="classunsigned.html">unsigned</a> Depth=0)</td></tr>
<tr class="memdesc:abf62ca503c047621e9b9047c548f231f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the pattern that a select with the given compare as its predicate and given values as its true/false operands would match.  <a href="namespacellvm.html#abf62ca503c047621e9b9047c548f231f">More...</a><br /></td></tr>
<tr class="separator:abf62ca503c047621e9b9047c548f231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493bd393688f22538e5de34117e70236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a493bd393688f22538e5de34117e70236">llvm::getMinMaxPred</a> (<a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097">SelectPatternFlavor</a> SPF, <a class="el" href="classbool.html">bool</a> Ordered=false)</td></tr>
<tr class="memdesc:a493bd393688f22538e5de34117e70236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the canonical comparison predicate for the specified minimum/maximum flavor.  <a href="namespacellvm.html#a493bd393688f22538e5de34117e70236">More...</a><br /></td></tr>
<tr class="separator:a493bd393688f22538e5de34117e70236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6626b9250a7ec4cc54a9e8ce78bc0cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097">SelectPatternFlavor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a6626b9250a7ec4cc54a9e8ce78bc0cc3">llvm::getInverseMinMaxFlavor</a> (<a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097">SelectPatternFlavor</a> SPF)</td></tr>
<tr class="memdesc:a6626b9250a7ec4cc54a9e8ce78bc0cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse minimum/maximum flavor of the specified flavor.  <a href="namespacellvm.html#a6626b9250a7ec4cc54a9e8ce78bc0cc3">More...</a><br /></td></tr>
<tr class="separator:a6626b9250a7ec4cc54a9e8ce78bc0cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7070df4a80b1c2a8e9b9f7c56ea92b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">CmpInst::Predicate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7070df4a80b1c2a8e9b9f7c56ea92b44">llvm::getInverseMinMaxPred</a> (<a class="el" href="namespacellvm.html#a6bf471c1030973649c2e426afc212097">SelectPatternFlavor</a> SPF)</td></tr>
<tr class="memdesc:a7070df4a80b1c2a8e9b9f7c56ea92b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the canonical inverse comparison predicate for the specified minimum/maximum flavor.  <a href="namespacellvm.html#a7070df4a80b1c2a8e9b9f7c56ea92b44">More...</a><br /></td></tr>
<tr class="separator:a7070df4a80b1c2a8e9b9f7c56ea92b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a303805dba0dd581a5daf9fd96002b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af6a303805dba0dd581a5daf9fd96002b">llvm::isImpliedCondition</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, const <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classbool.html">bool</a> LHSIsTrue=<a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>, <a class="el" href="classunsigned.html">unsigned</a> Depth=0)</td></tr>
<tr class="memdesc:af6a303805dba0dd581a5daf9fd96002b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if RHS is known to be implied true by LHS.  <a href="namespacellvm.html#af6a303805dba0dd581a5daf9fd96002b">More...</a><br /></td></tr>
<tr class="separator:af6a303805dba0dd581a5daf9fd96002b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60469dc68c780a4236148f6efe284e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa60469dc68c780a4236148f6efe284e2">llvm::isImpliedByDomCondition</a> (const <a class="el" href="classllvm_1_1Value.html">Value</a> *Cond, const <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *ContextI, const <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:aa60469dc68c780a4236148f6efe284e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the boolean condition value in the context of the given instruction if it is known based on dominating conditions.  <a href="namespacellvm.html#aa60469dc68c780a4236148f6efe284e2">More...</a><br /></td></tr>
<tr class="separator:aa60469dc68c780a4236148f6efe284e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:56:35 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
