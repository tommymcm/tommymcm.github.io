<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Analysis/ScalarEvolution.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a25db018342d3ae6c7e6779086c18378.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ScalarEvolution.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;llvm/Analysis/ScalarEvolution.h&quot;</code><br />
<code>#include &quot;llvm/ADT/APInt.h&quot;</code><br />
<code>#include &quot;llvm/ADT/ArrayRef.h&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseMap.h&quot;</code><br />
<code>#include &quot;llvm/ADT/DepthFirstIterator.h&quot;</code><br />
<code>#include &quot;llvm/ADT/EquivalenceClasses.h&quot;</code><br />
<code>#include &quot;llvm/ADT/FoldingSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/None.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Optional.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/ScopeExit.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Sequence.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SetVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallPtrSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Statistic.h&quot;</code><br />
<code>#include &quot;llvm/ADT/StringRef.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/AssumptionCache.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/ConstantFolding.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/InstructionSimplify.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/LoopInfo.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/ScalarEvolutionExpressions.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/TargetLibraryInfo.h&quot;</code><br />
<code>#include &quot;llvm/Analysis/ValueTracking.h&quot;</code><br />
<code>#include &quot;llvm/Config/llvm-config.h&quot;</code><br />
<code>#include &quot;llvm/IR/Argument.h&quot;</code><br />
<code>#include &quot;llvm/IR/BasicBlock.h&quot;</code><br />
<code>#include &quot;llvm/IR/CFG.h&quot;</code><br />
<code>#include &quot;llvm/IR/CallSite.h&quot;</code><br />
<code>#include &quot;llvm/IR/Constant.h&quot;</code><br />
<code>#include &quot;llvm/IR/ConstantRange.h&quot;</code><br />
<code>#include &quot;llvm/IR/Constants.h&quot;</code><br />
<code>#include &quot;llvm/IR/DataLayout.h&quot;</code><br />
<code>#include &quot;llvm/IR/DerivedTypes.h&quot;</code><br />
<code>#include &quot;llvm/IR/Dominators.h&quot;</code><br />
<code>#include &quot;llvm/IR/Function.h&quot;</code><br />
<code>#include &quot;llvm/IR/GlobalAlias.h&quot;</code><br />
<code>#include &quot;llvm/IR/GlobalValue.h&quot;</code><br />
<code>#include &quot;llvm/IR/GlobalVariable.h&quot;</code><br />
<code>#include &quot;llvm/IR/InstIterator.h&quot;</code><br />
<code>#include &quot;llvm/IR/InstrTypes.h&quot;</code><br />
<code>#include &quot;llvm/IR/Instruction.h&quot;</code><br />
<code>#include &quot;llvm/IR/Instructions.h&quot;</code><br />
<code>#include &quot;llvm/IR/IntrinsicInst.h&quot;</code><br />
<code>#include &quot;llvm/IR/Intrinsics.h&quot;</code><br />
<code>#include &quot;llvm/IR/LLVMContext.h&quot;</code><br />
<code>#include &quot;llvm/IR/Metadata.h&quot;</code><br />
<code>#include &quot;llvm/IR/Operator.h&quot;</code><br />
<code>#include &quot;llvm/IR/PatternMatch.h&quot;</code><br />
<code>#include &quot;llvm/IR/Type.h&quot;</code><br />
<code>#include &quot;llvm/IR/Use.h&quot;</code><br />
<code>#include &quot;llvm/IR/User.h&quot;</code><br />
<code>#include &quot;llvm/IR/Value.h&quot;</code><br />
<code>#include &quot;llvm/IR/Verifier.h&quot;</code><br />
<code>#include &quot;llvm/Pass.h&quot;</code><br />
<code>#include &quot;llvm/Support/Casting.h&quot;</code><br />
<code>#include &quot;llvm/Support/CommandLine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Compiler.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/ErrorHandling.h&quot;</code><br />
<code>#include &quot;llvm/Support/KnownBits.h&quot;</code><br />
<code>#include &quot;llvm/Support/SaveAndRestore.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;climits&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="ScalarEvolution_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;scalar-evolution&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8a5a920ebf3ac959a50b6616062ff81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#af8a5a920ebf3ac959a50b6616062ff81">STATISTIC</a> (NumArrayLenItCounts, &quot;Number of trip counts computed with array length&quot;)</td></tr>
<tr class="separator:af8a5a920ebf3ac959a50b6616062ff81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649b6bfcbe6c4e440b148e1acb606df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a649b6bfcbe6c4e440b148e1acb606df5">STATISTIC</a> (NumTripCountsComputed, &quot;Number of <a class="el" href="LoopInfo_8cpp.html#a49ae40a9c91d665793aaed656c26ca30">loops</a> with predictable loop counts&quot;)</td></tr>
<tr class="separator:a649b6bfcbe6c4e440b148e1acb606df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75749936481a8d4a33b815468d0914ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a75749936481a8d4a33b815468d0914ce">STATISTIC</a> (NumTripCountsNotComputed, &quot;Number of <a class="el" href="LoopInfo_8cpp.html#a49ae40a9c91d665793aaed656c26ca30">loops</a> without predictable loop counts&quot;)</td></tr>
<tr class="separator:a75749936481a8d4a33b815468d0914ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f52513f38d05cfd467fc8836aee852"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ac8f52513f38d05cfd467fc8836aee852">STATISTIC</a> (NumBruteForceTripCountsComputed, &quot;Number of <a class="el" href="LoopInfo_8cpp.html#a49ae40a9c91d665793aaed656c26ca30">loops</a> with trip counts computed by force&quot;)</td></tr>
<tr class="separator:ac8f52513f38d05cfd467fc8836aee852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f137765452a0490e5b8e07b718ef95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ab3f137765452a0490e5b8e07b718ef95">MaxBruteForceIterations</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-iterations&quot;, cl::ReallyHidden, cl::desc(&quot;Maximum number of iterations SCEV will &quot; &quot;symbolically execute a constant &quot; &quot;derived loop&quot;), cl::init(100))</td></tr>
<tr class="separator:ab3f137765452a0490e5b8e07b718ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f51ce4c960db9eea00624233ccd2f70"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a9f51ce4c960db9eea00624233ccd2f70">VerifySCEV</a> (&quot;verify-scev&quot;, cl::Hidden, cl::desc(&quot;Verify ScalarEvolution's backedge taken counts (slow)&quot;))</td></tr>
<tr class="separator:a9f51ce4c960db9eea00624233ccd2f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df932adc2cfcb32157885ffa5077eb6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a8df932adc2cfcb32157885ffa5077eb6">VerifySCEVMap</a> (&quot;verify-scev-maps&quot;, cl::Hidden, cl::desc(&quot;Verify no dangling value in ScalarEvolution's &quot; &quot;ExprValueMap (slow)&quot;))</td></tr>
<tr class="separator:a8df932adc2cfcb32157885ffa5077eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ce4b18b9a3b338f4bc0755a4a8ce09"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ae1ce4b18b9a3b338f4bc0755a4a8ce09">VerifyIR</a> (&quot;scev-verify-ir&quot;, cl::Hidden, cl::desc(&quot;Verify <a class="el" href="Lint_8cpp.html#a7fb3c9caadeb0f7fe4828d380158d0f9">IR</a> correctness when making sensitive SCEV queries (slow)&quot;), cl::init(false))</td></tr>
<tr class="separator:ae1ce4b18b9a3b338f4bc0755a4a8ce09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e7f9ca744365f5223b0cf104d47c2c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ac1e7f9ca744365f5223b0cf104d47c2c">MulOpsInlineThreshold</a> (&quot;scev-mulops-<a class="el" href="AlwaysInliner_8cpp.html#a46ccdc20c42bb5ae5b9d313e12a68421">inline</a>-threshold&quot;, cl::Hidden, cl::desc(&quot;Threshold for inlining multiplication operands into a SCEV&quot;), cl::init(32))</td></tr>
<tr class="separator:ac1e7f9ca744365f5223b0cf104d47c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60270bb9ecd3c390f2acbb4a8dee5f7c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a60270bb9ecd3c390f2acbb4a8dee5f7c">AddOpsInlineThreshold</a> (&quot;scev-addops-<a class="el" href="AlwaysInliner_8cpp.html#a46ccdc20c42bb5ae5b9d313e12a68421">inline</a>-threshold&quot;, cl::Hidden, cl::desc(&quot;Threshold for inlining addition operands into a SCEV&quot;), cl::init(500))</td></tr>
<tr class="separator:a60270bb9ecd3c390f2acbb4a8dee5f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e72a43694f4179f607493b1f7d2c59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#aa9e72a43694f4179f607493b1f7d2c59">MaxSCEVCompareDepth</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-scev-compare-depth&quot;, cl::Hidden, cl::desc(&quot;Maximum depth of recursive SCEV complexity comparisons&quot;), cl::init(32))</td></tr>
<tr class="separator:aa9e72a43694f4179f607493b1f7d2c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632ff5198de03696a428d04d0a3751f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a632ff5198de03696a428d04d0a3751f1">MaxSCEVOperationsImplicationDepth</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-scev-<a class="el" href="Scalarizer_8cpp.html#a16225fc97f8d45afdbb29637c6750d89">operations</a>-implication-depth&quot;, cl::Hidden, cl::desc(&quot;Maximum depth of recursive SCEV <a class="el" href="Scalarizer_8cpp.html#a16225fc97f8d45afdbb29637c6750d89">operations</a> implication analysis&quot;), cl::init(2))</td></tr>
<tr class="separator:a632ff5198de03696a428d04d0a3751f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd04c7d9c924e7c3685e82ca1fadfef4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#afd04c7d9c924e7c3685e82ca1fadfef4">MaxValueCompareDepth</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-value-compare-depth&quot;, cl::Hidden, cl::desc(&quot;Maximum depth of recursive value complexity comparisons&quot;), cl::init(2))</td></tr>
<tr class="separator:afd04c7d9c924e7c3685e82ca1fadfef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4e035e66d591e105444d5861d772c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#afe4e035e66d591e105444d5861d772c5">MaxArithDepth</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-arith-depth&quot;, cl::Hidden, cl::desc(&quot;Maximum depth of recursive arithmetics&quot;), cl::init(32))</td></tr>
<tr class="separator:afe4e035e66d591e105444d5861d772c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fa405974f8587085c789435a5b6129"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a75fa405974f8587085c789435a5b6129">MaxConstantEvolvingDepth</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-constant-evolving-depth&quot;, cl::Hidden, cl::desc(&quot;Maximum depth of recursive constant evolving&quot;), cl::init(32))</td></tr>
<tr class="separator:a75fa405974f8587085c789435a5b6129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e002462df1247cb9c4374d39dda895"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a73e002462df1247cb9c4374d39dda895">MaxCastDepth</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-cast-depth&quot;, cl::Hidden, cl::desc(&quot;Maximum depth of recursive SExt/ZExt/Trunc&quot;), cl::init(8))</td></tr>
<tr class="separator:a73e002462df1247cb9c4374d39dda895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1744890ecac75bc8d67772462fad7115"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a1744890ecac75bc8d67772462fad7115">MaxAddRecSize</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-<a class="el" href="FileCheck_8cpp.html#a1e23cc505a17287914489e2d7f7093ba">add</a>-rec-size&quot;, cl::Hidden, cl::desc(&quot;Max coefficients in AddRec during evolving&quot;), cl::init(8))</td></tr>
<tr class="separator:a1744890ecac75bc8d67772462fad7115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7254e838e5ffd28362ae8157e53674"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a9d7254e838e5ffd28362ae8157e53674">HugeExprThreshold</a> (&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-huge-expr-threshold&quot;, cl::Hidden, cl::desc(&quot;Size of the expression which is considered huge&quot;), cl::init(4096))</td></tr>
<tr class="separator:a9d7254e838e5ffd28362ae8157e53674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ea59154b2de6dc273eb071b3f16265"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a87ea59154b2de6dc273eb071b3f16265">CompareValueComplexity</a> (EquivalenceClasses&lt; const Value * &gt; &amp;EqCacheValue, const LoopInfo *const LI, Value *LV, Value *RV, unsigned Depth)</td></tr>
<tr class="memdesc:a87ea59154b2de6dc273eb071b3f16265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the two values <code>LV</code> and <code>RV</code> in terms of their "complexity" where "complexity" is a partial (and somewhat ad-hoc) relation used to order operands in SCEV expressions.  <a href="ScalarEvolution_8cpp.html#a87ea59154b2de6dc273eb071b3f16265">More...</a><br /></td></tr>
<tr class="separator:a87ea59154b2de6dc273eb071b3f16265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d4155b10ad0de9333f03e28d80062d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ae9d4155b10ad0de9333f03e28d80062d">CompareSCEVComplexity</a> (EquivalenceClasses&lt; const SCEV * &gt; &amp;EqCacheSCEV, EquivalenceClasses&lt; const Value * &gt; &amp;EqCacheValue, const LoopInfo *const LI, const SCEV *LHS, const SCEV *RHS, DominatorTree &amp;DT, unsigned Depth=0)</td></tr>
<tr class="separator:ae9d4155b10ad0de9333f03e28d80062d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d43163acfcdefe57d402dab3640d8be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a4d43163acfcdefe57d402dab3640d8be">GroupByComplexity</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;Ops, LoopInfo *LI, DominatorTree &amp;DT)</td></tr>
<tr class="memdesc:a4d43163acfcdefe57d402dab3640d8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of SCEV objects, order them by their complexity, and group objects of the same complexity together by value.  <a href="ScalarEvolution_8cpp.html#a4d43163acfcdefe57d402dab3640d8be">More...</a><br /></td></tr>
<tr class="separator:a4d43163acfcdefe57d402dab3640d8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f034bf5597953817366d130081d65e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a02f034bf5597953817366d130081d65e">sizeOfSCEV</a> (const SCEV *S)</td></tr>
<tr class="separator:a02f034bf5597953817366d130081d65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeb2b6b40e731d47df632839fa3deca"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#abaeb2b6b40e731d47df632839fa3deca">isHugeExpression</a> (const SCEV *S)</td></tr>
<tr class="memdesc:abaeb2b6b40e731d47df632839fa3deca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the subtree of <code>S</code> contains at least HugeExprThreshold nodes.  <a href="ScalarEvolution_8cpp.html#abaeb2b6b40e731d47df632839fa3deca">More...</a><br /></td></tr>
<tr class="separator:abaeb2b6b40e731d47df632839fa3deca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a7153270eb1fafa4502adc85f49adf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a81a7153270eb1fafa4502adc85f49adf">hasHugeExpression</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const SCEV * &gt; Ops)</td></tr>
<tr class="memdesc:a81a7153270eb1fafa4502adc85f49adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of <code>Ops</code> contains a huge SCEV (see definition above).  <a href="ScalarEvolution_8cpp.html#a81a7153270eb1fafa4502adc85f49adf">More...</a><br /></td></tr>
<tr class="separator:a81a7153270eb1fafa4502adc85f49adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55aceb0318074f694f763d011f71cd90"><td class="memItemLeft" align="right" valign="top">static const SCEV *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a55aceb0318074f694f763d011f71cd90">BinomialCoefficient</a> (const SCEV *It, unsigned K, ScalarEvolution &amp;SE, Type *ResultTy)</td></tr>
<tr class="memdesc:a55aceb0318074f694f763d011f71cd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute BC(It, K). The result has width W. Assume, K &gt; 0.  <a href="ScalarEvolution_8cpp.html#a55aceb0318074f694f763d011f71cd90">More...</a><br /></td></tr>
<tr class="separator:a55aceb0318074f694f763d011f71cd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a19e1b12d26ad87bc379e576ff5a7f"><td class="memItemLeft" align="right" valign="top">static const SCEV *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ae8a19e1b12d26ad87bc379e576ff5a7f">getSignedOverflowLimitForStep</a> (const SCEV *Step, ICmpInst::Predicate *Pred, ScalarEvolution *SE)</td></tr>
<tr class="separator:ae8a19e1b12d26ad87bc379e576ff5a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0515f214b4d4e5d5a3197b11d5eacc"><td class="memItemLeft" align="right" valign="top">static const SCEV *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#aff0515f214b4d4e5d5a3197b11d5eacc">getUnsignedOverflowLimitForStep</a> (const SCEV *Step, ICmpInst::Predicate *Pred, ScalarEvolution *SE)</td></tr>
<tr class="separator:aff0515f214b4d4e5d5a3197b11d5eacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359235e468f7ab6f4dccbed37c17dee1"><td class="memTemplParams" colspan="2">template&lt;typename ExtendOpTy &gt; </td></tr>
<tr class="memitem:a359235e468f7ab6f4dccbed37c17dee1"><td class="memTemplItemLeft" align="right" valign="top">static const SCEV *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a359235e468f7ab6f4dccbed37c17dee1">getPreStartForExtend</a> (const SCEVAddRecExpr *AR, Type *Ty, ScalarEvolution *SE, unsigned Depth)</td></tr>
<tr class="separator:a359235e468f7ab6f4dccbed37c17dee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7762f1d99f297ecb6ccb4375e715c2ea"><td class="memTemplParams" colspan="2">template&lt;typename ExtendOpTy &gt; </td></tr>
<tr class="memitem:a7762f1d99f297ecb6ccb4375e715c2ea"><td class="memTemplItemLeft" align="right" valign="top">static const SCEV *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a7762f1d99f297ecb6ccb4375e715c2ea">getExtendAddRecStart</a> (const SCEVAddRecExpr *AR, Type *Ty, ScalarEvolution *SE, unsigned Depth)</td></tr>
<tr class="separator:a7762f1d99f297ecb6ccb4375e715c2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ecca94c1ac1a616d83f565a4aeaeae"><td class="memItemLeft" align="right" valign="top">static APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ab1ecca94c1ac1a616d83f565a4aeaeae">extractConstantWithoutWrapping</a> (ScalarEvolution &amp;SE, const SCEVConstant *ConstantTerm, const SCEVAddExpr *WholeAddExpr)</td></tr>
<tr class="separator:ab1ecca94c1ac1a616d83f565a4aeaeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5589e186b84c92aaeecbaeaf6253ebc8"><td class="memItemLeft" align="right" valign="top">static APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a5589e186b84c92aaeecbaeaf6253ebc8">extractConstantWithoutWrapping</a> (ScalarEvolution &amp;SE, const APInt &amp;ConstantStart, const SCEV *Step)</td></tr>
<tr class="separator:a5589e186b84c92aaeecbaeaf6253ebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd878be03640c9f0c9cc90aa77b05225"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#afd878be03640c9f0c9cc90aa77b05225">CollectAddOperandsWithScales</a> (DenseMap&lt; const SCEV *, APInt &gt; &amp;M, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;NewOps, APInt &amp;AccumulatedConstant, const SCEV *const *Ops, size_t NumOperands, const APInt &amp;Scale, ScalarEvolution &amp;SE)</td></tr>
<tr class="memdesc:afd878be03640c9f0c9cc90aa77b05225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the given Ops list, which is a list of operands to be added under the given scale, update the given map.  <a href="ScalarEvolution_8cpp.html#afd878be03640c9f0c9cc90aa77b05225">More...</a><br /></td></tr>
<tr class="separator:afd878be03640c9f0c9cc90aa77b05225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99f51fb7f4e120a8ebeb76e3c53cf2b"><td class="memItemLeft" align="right" valign="top">static SCEV::NoWrapFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ae99f51fb7f4e120a8ebeb76e3c53cf2b">StrengthenNoWrapFlags</a> (ScalarEvolution *SE, SCEVTypes Type, const <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const SCEV * &gt; Ops, SCEV::NoWrapFlags Flags)</td></tr>
<tr class="separator:ae99f51fb7f4e120a8ebeb76e3c53cf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c073d72f1aa69d68ffb88bf12a9c1b0"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a6c073d72f1aa69d68ffb88bf12a9c1b0">umul_ov</a> (uint64_t i, uint64_t j, bool &amp;Overflow)</td></tr>
<tr class="separator:a6c073d72f1aa69d68ffb88bf12a9c1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab53b73cc54e312fd1745ebffccc7dc"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#aeab53b73cc54e312fd1745ebffccc7dc">Choose</a> (uint64_t n, uint64_t k, bool &amp;Overflow)</td></tr>
<tr class="memdesc:aeab53b73cc54e312fd1745ebffccc7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the result of "n choose k", the binomial coefficient.  <a href="ScalarEvolution_8cpp.html#aeab53b73cc54e312fd1745ebffccc7dc">More...</a><br /></td></tr>
<tr class="separator:aeab53b73cc54e312fd1745ebffccc7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a63c2d772bc6e774e216072117b95a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a75a63c2d772bc6e774e216072117b95a">containsConstantInAddMulChain</a> (const SCEV *StartExpr)</td></tr>
<tr class="memdesc:a75a63c2d772bc6e774e216072117b95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if any of the operands in this SCEV are a constant or if any of the add or multiply expressions in this SCEV contain a constant.  <a href="ScalarEvolution_8cpp.html#a75a63c2d772bc6e774e216072117b95a">More...</a><br /></td></tr>
<tr class="separator:a75a63c2d772bc6e774e216072117b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139eacd669113b3a982b9c3a6240b3bd"><td class="memItemLeft" align="right" valign="top">static const APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a139eacd669113b3a982b9c3a6240b3bd">gcd</a> (const SCEVConstant *C1, const SCEVConstant *C2)</td></tr>
<tr class="separator:a139eacd669113b3a982b9c3a6240b3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cdae21b048b79d4bf76840307e5ec1"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; const SCEV *, ConstantInt * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a58cdae21b048b79d4bf76840307e5ec1">splitAddExpr</a> (const SCEV *S)</td></tr>
<tr class="memdesc:a58cdae21b048b79d4bf76840307e5ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to split a SCEVAddExpr into a pair of {SCEV, ConstantInt}.  <a href="ScalarEvolution_8cpp.html#a58cdae21b048b79d4bf76840307e5ec1">More...</a><br /></td></tr>
<tr class="separator:a58cdae21b048b79d4bf76840307e5ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09483c84fbbf3fb99c11f787a41d4282"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a09483c84fbbf3fb99c11f787a41d4282">SCEVLostPoisonFlags</a> (const SCEV *S, const Value *V)</td></tr>
<tr class="memdesc:a09483c84fbbf3fb99c11f787a41d4282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether value has nuw/nsw/exact set but SCEV does not.  <a href="ScalarEvolution_8cpp.html#a09483c84fbbf3fb99c11f787a41d4282">More...</a><br /></td></tr>
<tr class="separator:a09483c84fbbf3fb99c11f787a41d4282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa8fd1f2af30380d7080ef96b976209"><td class="memItemLeft" align="right" valign="top">static const SCEV *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#adaa8fd1f2af30380d7080ef96b976209">MatchNotExpr</a> (const SCEV *Expr)</td></tr>
<tr class="memdesc:adaa8fd1f2af30380d7080ef96b976209"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Expr computes ~A, return A else return nullptr.  <a href="ScalarEvolution_8cpp.html#adaa8fd1f2af30380d7080ef96b976209">More...</a><br /></td></tr>
<tr class="separator:adaa8fd1f2af30380d7080ef96b976209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50d189708d19a31f6c189c947c45dcc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#af50d189708d19a31f6c189c947c45dcc">PushDefUseChildren</a> (Instruction *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Instruction * &gt; &amp;Worklist)</td></tr>
<tr class="memdesc:af50d189708d19a31f6c189c947c45dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push users of the given Instruction onto the given Worklist.  <a href="ScalarEvolution_8cpp.html#af50d189708d19a31f6c189c947c45dcc">More...</a><br /></td></tr>
<tr class="separator:af50d189708d19a31f6c189c947c45dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad468036d72843ee38e6c61dc62673865"><td class="memItemLeft" align="right" valign="top">static Optional&lt; BinaryOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ad468036d72843ee38e6c61dc62673865">MatchBinaryOp</a> (Value *V, DominatorTree &amp;DT)</td></tr>
<tr class="memdesc:ad468036d72843ee38e6c61dc62673865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to map <code>V</code> into a BinaryOp, and return <code>None</code> on failure.  <a href="ScalarEvolution_8cpp.html#ad468036d72843ee38e6c61dc62673865">More...</a><br /></td></tr>
<tr class="separator:ad468036d72843ee38e6c61dc62673865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a0854a75b9e8d760fd95387759569c"><td class="memItemLeft" align="right" valign="top">static Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ad5a0854a75b9e8d760fd95387759569c">isSimpleCastedPHI</a> (const SCEV *Op, const SCEVUnknown *SymbolicPHI, bool &amp;Signed, ScalarEvolution &amp;SE)</td></tr>
<tr class="memdesc:ad5a0854a75b9e8d760fd95387759569c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to createAddRecFromPHIWithCasts.  <a href="ScalarEvolution_8cpp.html#ad5a0854a75b9e8d760fd95387759569c">More...</a><br /></td></tr>
<tr class="separator:ad5a0854a75b9e8d760fd95387759569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08188d419e040050ef28ea516afebf98"><td class="memItemLeft" align="right" valign="top">static const Loop *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a08188d419e040050ef28ea516afebf98">isIntegerLoopHeaderPHI</a> (const PHINode *PN, LoopInfo &amp;LI)</td></tr>
<tr class="separator:a08188d419e040050ef28ea516afebf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99b948bcde1ca2925452cc91317656b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ac99b948bcde1ca2925452cc91317656b">IsAvailableOnEntry</a> (const Loop *L, DominatorTree &amp;DT, const SCEV *S, BasicBlock *BB)</td></tr>
<tr class="separator:ac99b948bcde1ca2925452cc91317656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341358b4e9c3ffb463182ea3280b2016"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a341358b4e9c3ffb463182ea3280b2016">BrPHIToSelect</a> (DominatorTree &amp;DT, BranchInst *BI, PHINode *Merge, Value *&amp;C, Value *&amp;LHS, Value *&amp;RHS)</td></tr>
<tr class="separator:a341358b4e9c3ffb463182ea3280b2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833702f8d0f629818b2b04031677b0d1"><td class="memItemLeft" align="right" valign="top">static Optional&lt; ConstantRange &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a833702f8d0f629818b2b04031677b0d1">GetRangeFromMetadata</a> (Value *V)</td></tr>
<tr class="memdesc:a833702f8d0f629818b2b04031677b0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to assign a range to V from metadata present in the IR.  <a href="ScalarEvolution_8cpp.html#a833702f8d0f629818b2b04031677b0d1">More...</a><br /></td></tr>
<tr class="separator:a833702f8d0f629818b2b04031677b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffe1c5730168a86a46e690447dd6d97"><td class="memItemLeft" align="right" valign="top">static ConstantRange&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#abffe1c5730168a86a46e690447dd6d97">getRangeForAffineARHelper</a> (APInt Step, const ConstantRange &amp;StartRange, const APInt &amp;MaxBECount, unsigned BitWidth, bool Signed)</td></tr>
<tr class="separator:abffe1c5730168a86a46e690447dd6d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf0cf316748d2fb01a45268ffc10a02"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a0bf0cf316748d2fb01a45268ffc10a02">getConstantTripCount</a> (const SCEVConstant *ExitCount)</td></tr>
<tr class="separator:a0bf0cf316748d2fb01a45268ffc10a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649011f27bb212ab1bdd0ec7e041da79"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a649011f27bb212ab1bdd0ec7e041da79">PushLoopPHIs</a> (const Loop *L, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Instruction * &gt; &amp;Worklist)</td></tr>
<tr class="memdesc:a649011f27bb212ab1bdd0ec7e041da79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push PHI nodes in the header of the given loop onto the given Worklist.  <a href="ScalarEvolution_8cpp.html#a649011f27bb212ab1bdd0ec7e041da79">More...</a><br /></td></tr>
<tr class="separator:a649011f27bb212ab1bdd0ec7e041da79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dedd456f8ee5d9877d13c9717ef94b"><td class="memItemLeft" align="right" valign="top">static ConstantInt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a54dedd456f8ee5d9877d13c9717ef94b">EvaluateConstantChrecAtConstant</a> (const SCEVAddRecExpr *AddRec, ConstantInt *C, ScalarEvolution &amp;SE)</td></tr>
<tr class="separator:a54dedd456f8ee5d9877d13c9717ef94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250f5c0dbc15e78bded9c6bbd4354185"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a250f5c0dbc15e78bded9c6bbd4354185">CanConstantFold</a> (const Instruction *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:a250f5c0dbc15e78bded9c6bbd4354185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can constant fold an instruction of the specified type, assuming that all operands were constants.  <a href="ScalarEvolution_8cpp.html#a250f5c0dbc15e78bded9c6bbd4354185">More...</a><br /></td></tr>
<tr class="separator:a250f5c0dbc15e78bded9c6bbd4354185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1691ba36ec490f734755ccc9c0d4c95"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#af1691ba36ec490f734755ccc9c0d4c95">canConstantEvolve</a> (Instruction *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, const Loop *L)</td></tr>
<tr class="memdesc:af1691ba36ec490f734755ccc9c0d4c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this instruction can constant evolve within this loop assuming its operands can all constant evolve.  <a href="ScalarEvolution_8cpp.html#af1691ba36ec490f734755ccc9c0d4c95">More...</a><br /></td></tr>
<tr class="separator:af1691ba36ec490f734755ccc9c0d4c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af278ae155bd811822054e98b8f056c56"><td class="memItemLeft" align="right" valign="top">static PHINode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#af278ae155bd811822054e98b8f056c56">getConstantEvolvingPHIOperands</a> (Instruction *UseInst, const Loop *L, DenseMap&lt; Instruction *, PHINode * &gt; &amp;PHIMap, unsigned Depth)</td></tr>
<tr class="memdesc:af278ae155bd811822054e98b8f056c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">getConstantEvolvingPHIOperands - Implement getConstantEvolvingPHI by recursing through each instruction operand until reaching a loop header phi.  <a href="ScalarEvolution_8cpp.html#af278ae155bd811822054e98b8f056c56">More...</a><br /></td></tr>
<tr class="separator:af278ae155bd811822054e98b8f056c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c77277af6c3f267a47374301462096e"><td class="memItemLeft" align="right" valign="top">static PHINode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a5c77277af6c3f267a47374301462096e">getConstantEvolvingPHI</a> (Value *V, const Loop *L)</td></tr>
<tr class="memdesc:a5c77277af6c3f267a47374301462096e"><td class="mdescLeft">&#160;</td><td class="mdescRight">getConstantEvolvingPHI - Given an LLVM value and a loop, return a PHI node in the loop that V is derived from.  <a href="ScalarEvolution_8cpp.html#a5c77277af6c3f267a47374301462096e">More...</a><br /></td></tr>
<tr class="separator:a5c77277af6c3f267a47374301462096e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d5df272037a3079a05b96be49cc44"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ad62d5df272037a3079a05b96be49cc44">EvaluateExpression</a> (Value *V, const Loop *L, DenseMap&lt; Instruction *, Constant * &gt; &amp;Vals, const DataLayout &amp;DL, const TargetLibraryInfo *TLI)</td></tr>
<tr class="memdesc:ad62d5df272037a3079a05b96be49cc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">EvaluateExpression - Given an expression that passes the getConstantEvolvingPHI predicate, evaluate its value assuming the PHI node in the loop has the value PHIVal.  <a href="ScalarEvolution_8cpp.html#ad62d5df272037a3079a05b96be49cc44">More...</a><br /></td></tr>
<tr class="separator:ad62d5df272037a3079a05b96be49cc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8996f55e648de5006cb39d80c65d60e"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#af8996f55e648de5006cb39d80c65d60e">getOtherIncomingValue</a> (PHINode *PN, BasicBlock *BB)</td></tr>
<tr class="separator:af8996f55e648de5006cb39d80c65d60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c5a810b1d6fbe75255674e7e9c40ba"><td class="memItemLeft" align="right" valign="top">static Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a54c5a810b1d6fbe75255674e7e9c40ba">BuildConstantFromSCEV</a> (const SCEV *V)</td></tr>
<tr class="memdesc:a54c5a810b1d6fbe75255674e7e9c40ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This builds up a Constant using the <a class="el" href="classConstantExpr.html">ConstantExpr</a> interface.  <a href="ScalarEvolution_8cpp.html#a54c5a810b1d6fbe75255674e7e9c40ba">More...</a><br /></td></tr>
<tr class="separator:a54c5a810b1d6fbe75255674e7e9c40ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecc30e106f1f2c10a9f338d96849ead"><td class="memItemLeft" align="right" valign="top">static const SCEV *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#abecc30e106f1f2c10a9f338d96849ead">SolveLinEquationWithOverflow</a> (const APInt &amp;A, const SCEV *B, ScalarEvolution &amp;SE)</td></tr>
<tr class="memdesc:abecc30e106f1f2c10a9f338d96849ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum unsigned root of the following equation:  <a href="ScalarEvolution_8cpp.html#abecc30e106f1f2c10a9f338d96849ead">More...</a><br /></td></tr>
<tr class="separator:abecc30e106f1f2c10a9f338d96849ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e217ca9d64187d9ea2bfbe8213b4767"><td class="memItemLeft" align="right" valign="top">static Optional&lt; std::tuple&lt; APInt, APInt, APInt, APInt, unsigned &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a8e217ca9d64187d9ea2bfbe8213b4767">GetQuadraticEquation</a> (const SCEVAddRecExpr *AddRec)</td></tr>
<tr class="memdesc:a8e217ca9d64187d9ea2bfbe8213b4767"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given quadratic addrec, generate coefficients of the corresponding quadratic equation, multiplied by a common value to ensure that they are integers.  <a href="ScalarEvolution_8cpp.html#a8e217ca9d64187d9ea2bfbe8213b4767">More...</a><br /></td></tr>
<tr class="separator:a8e217ca9d64187d9ea2bfbe8213b4767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb949d24a9865adbdc717af178e35d8f"><td class="memItemLeft" align="right" valign="top">static Optional&lt; APInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#afb949d24a9865adbdc717af178e35d8f">MinOptional</a> (Optional&lt; APInt &gt; <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X</a>, Optional&lt; APInt &gt; <a class="el" href="Hello_8cpp.html#ac3d32b43305241160f8c774e4ce25824">Y</a>)</td></tr>
<tr class="memdesc:afb949d24a9865adbdc717af178e35d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compare optional APInts: (a) if X and Y both exist, return min(X, Y), (b) if neither X nor Y exist, return None, (c) if exactly one of X and Y exists, return that value.  <a href="ScalarEvolution_8cpp.html#afb949d24a9865adbdc717af178e35d8f">More...</a><br /></td></tr>
<tr class="separator:afb949d24a9865adbdc717af178e35d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80784b9f8579f525377a26d5f9e5cd63"><td class="memItemLeft" align="right" valign="top">static Optional&lt; APInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a80784b9f8579f525377a26d5f9e5cd63">TruncIfPossible</a> (Optional&lt; APInt &gt; <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X</a>, unsigned BitWidth)</td></tr>
<tr class="memdesc:a80784b9f8579f525377a26d5f9e5cd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to truncate an optional APInt to a given BitWidth.  <a href="ScalarEvolution_8cpp.html#a80784b9f8579f525377a26d5f9e5cd63">More...</a><br /></td></tr>
<tr class="separator:a80784b9f8579f525377a26d5f9e5cd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60573ada7a8a58e0806db0a02c54034c"><td class="memItemLeft" align="right" valign="top">static Optional&lt; APInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a60573ada7a8a58e0806db0a02c54034c">SolveQuadraticAddRecExact</a> (const SCEVAddRecExpr *AddRec, ScalarEvolution &amp;SE)</td></tr>
<tr class="memdesc:a60573ada7a8a58e0806db0a02c54034c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let c(n) be the value of the quadratic chrec {L,+,M,+,N} after n iterations.  <a href="ScalarEvolution_8cpp.html#a60573ada7a8a58e0806db0a02c54034c">More...</a><br /></td></tr>
<tr class="separator:a60573ada7a8a58e0806db0a02c54034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f6706b3d1f2cecb7bc63c575730c3a"><td class="memItemLeft" align="right" valign="top">static Optional&lt; APInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a46f6706b3d1f2cecb7bc63c575730c3a">SolveQuadraticAddRecRange</a> (const SCEVAddRecExpr *AddRec, const ConstantRange &amp;Range, ScalarEvolution &amp;SE)</td></tr>
<tr class="memdesc:a46f6706b3d1f2cecb7bc63c575730c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let c(n) be the value of the quadratic chrec {0,+,M,+,N} after n iterations.  <a href="ScalarEvolution_8cpp.html#a46f6706b3d1f2cecb7bc63c575730c3a">More...</a><br /></td></tr>
<tr class="separator:a46f6706b3d1f2cecb7bc63c575730c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8979aa7e40386835642f9f5f9f36d2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#aea8979aa7e40386835642f9f5f9f36d2">HasSameValue</a> (const SCEV *A, const SCEV *B)</td></tr>
<tr class="memdesc:aea8979aa7e40386835642f9f5f9f36d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCEV structural equivalence is usually sufficient for testing whether two expressions are equal, however for the purposes of looking for a condition guarding a loop, it can be useful to be a little more general, since a front-end may have replicated the controlling expression.  <a href="ScalarEvolution_8cpp.html#aea8979aa7e40386835642f9f5f9f36d2">More...</a><br /></td></tr>
<tr class="separator:aea8979aa7e40386835642f9f5f9f36d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fcf5b90a1e31b126ee5d8a80275654"><td class="memTemplParams" colspan="2">template&lt;typename MinMaxExprType &gt; </td></tr>
<tr class="memitem:a59fcf5b90a1e31b126ee5d8a80275654"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a59fcf5b90a1e31b126ee5d8a80275654">IsMinMaxConsistingOf</a> (const SCEV *MaybeMinMaxExpr, const SCEV *Candidate)</td></tr>
<tr class="memdesc:a59fcf5b90a1e31b126ee5d8a80275654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is MaybeMinMaxExpr an (U|S)(Min|Max) of Candidate and some other values?  <a href="ScalarEvolution_8cpp.html#a59fcf5b90a1e31b126ee5d8a80275654">More...</a><br /></td></tr>
<tr class="separator:a59fcf5b90a1e31b126ee5d8a80275654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9da73da463d6ed62b1d24df36fac961"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#aa9da73da463d6ed62b1d24df36fac961">IsKnownPredicateViaAddRecStart</a> (ScalarEvolution &amp;SE, ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS)</td></tr>
<tr class="separator:aa9da73da463d6ed62b1d24df36fac961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a7c6b9fe0d5ef6694bf8a5183d8a69"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a23a7c6b9fe0d5ef6694bf8a5183d8a69">IsKnownPredicateViaMinOrMax</a> (ScalarEvolution &amp;SE, ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS)</td></tr>
<tr class="memdesc:a23a7c6b9fe0d5ef6694bf8a5183d8a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is LHS <code>Pred</code> RHS true on the virtue of LHS or RHS being a Min or Max expression?  <a href="ScalarEvolution_8cpp.html#a23a7c6b9fe0d5ef6694bf8a5183d8a69">More...</a><br /></td></tr>
<tr class="separator:a23a7c6b9fe0d5ef6694bf8a5183d8a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9649394e7b50e4ae2d6bf3673de5d94d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a9649394e7b50e4ae2d6bf3673de5d94d">containsUndefs</a> (const SCEV *S)</td></tr>
<tr class="separator:a9649394e7b50e4ae2d6bf3673de5d94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f3984cb81d6b8e7810c8b313739043"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a80f3984cb81d6b8e7810c8b313739043">findArrayDimensionsRec</a> (ScalarEvolution &amp;SE, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;Terms, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;Sizes)</td></tr>
<tr class="separator:a80f3984cb81d6b8e7810c8b313739043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad178fa857aa5165e7807333157652e05"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ad178fa857aa5165e7807333157652e05">containsParameters</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;Terms)</td></tr>
<tr class="separator:ad178fa857aa5165e7807333157652e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca18fd87fe200f89b539ad52ee46421"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#adca18fd87fe200f89b539ad52ee46421">numberOfTerms</a> (const SCEV *S)</td></tr>
<tr class="separator:adca18fd87fe200f89b539ad52ee46421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161de17b2db4a6bdb9b4ce1ea13da113"><td class="memItemLeft" align="right" valign="top">static const SCEV *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a161de17b2db4a6bdb9b4ce1ea13da113">removeConstantFactors</a> (ScalarEvolution &amp;SE, const SCEV *T)</td></tr>
<tr class="separator:a161de17b2db4a6bdb9b4ce1ea13da113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7170e1b99a9c472642f756b8cf098afa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a7170e1b99a9c472642f756b8cf098afa">PrintLoopInfo</a> (raw_ostream &amp;OS, ScalarEvolution *SE, const Loop *L)</td></tr>
<tr class="separator:a7170e1b99a9c472642f756b8cf098afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd00c5af76d76d690df3147ac7c6aa3e"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#abd00c5af76d76d690df3147ac7c6aa3e">loopDispositionToStr</a> (ScalarEvolution::LoopDisposition LD)</td></tr>
<tr class="separator:abd00c5af76d76d690df3147ac7c6aa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e24c91db8604ae3ee873162c89749d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a3e24c91db8604ae3ee873162c89749d3">INITIALIZE_PASS_BEGIN</a> (ScalarEvolutionWrapperPass, &quot;scalar-evolution&quot;, &quot;Scalar Evolution Analysis&quot;, false, <a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>) INITIALIZE_PASS_END(ScalarEvolutionWrapperPass</td></tr>
<tr class="separator:a3e24c91db8604ae3ee873162c89749d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afa04c31b8a224e9f4e66ba448f05e9d0"><td class="memItemLeft" align="right" valign="top">scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a></td></tr>
<tr class="separator:afa04c31b8a224e9f4e66ba448f05e9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503499d4ac1af5de3ac8a7e4805e14aa"><td class="memItemLeft" align="right" valign="top">scalar Scalar Evolution&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#a503499d4ac1af5de3ac8a7e4805e14aa">Analysis</a></td></tr>
<tr class="separator:a503499d4ac1af5de3ac8a7e4805e14aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98634f319efc49e653ccb25caaf4090"><td class="memItemLeft" align="right" valign="top">scalar Scalar Evolution&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ScalarEvolution_8cpp.html#ab98634f319efc49e653ccb25caaf4090">false</a></td></tr>
<tr class="separator:ab98634f319efc49e653ccb25caaf4090"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;scalar-evolution&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l00138">138</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a60270bb9ecd3c390f2acbb4a8dee5f7c" name="a60270bb9ecd3c390f2acbb4a8dee5f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60270bb9ecd3c390f2acbb4a8dee5f7c">&#9670;&nbsp;</a></span>AddOpsInlineThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; AddOpsInlineThreshold </td>
          <td>(</td>
          <td class="paramtype">&quot;scev-addops-<a class="el" href="AlwaysInliner_8cpp.html#a46ccdc20c42bb5ae5b9d313e12a68421">inline</a>-threshold&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Threshold for inlining addition operands into a SCEV&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(500)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55aceb0318074f694f763d011f71cd90" name="a55aceb0318074f694f763d011f71cd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55aceb0318074f694f763d011f71cd90">&#9670;&nbsp;</a></span>BinomialCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SCEV * BinomialCoefficient </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>It</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ResultTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute BC(It, K). The result has width W. Assume, K &gt; 0. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l01112">1112</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a341358b4e9c3ffb463182ea3280b2016" name="a341358b4e9c3ffb463182ea3280b2016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341358b4e9c3ffb463182ea3280b2016">&#9670;&nbsp;</a></span>BrPHIToSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool BrPHIToSelect </td>
          <td>(</td>
          <td class="paramtype">DominatorTree &amp;&#160;</td>
          <td class="paramname"><em>DT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BranchInst *&#160;</td>
          <td class="paramname"><em>BI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PHINode *&#160;</td>
          <td class="paramname"><em>Merge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&amp;&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l05234">5234</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>.</p>

</div>
</div>
<a id="a54c5a810b1d6fbe75255674e7e9c40ba" name="a54c5a810b1d6fbe75255674e7e9c40ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c5a810b1d6fbe75255674e7e9c40ba">&#9670;&nbsp;</a></span>BuildConstantFromSCEV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * BuildConstantFromSCEV </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This builds up a Constant using the <a class="el" href="classConstantExpr.html">ConstantExpr</a> interface. </p>
<p >That way, we will return Constants for objects which aren't represented by a SCEVConstant, because SCEVConstant is restricted to ConstantInt. Returns NULL if the SCEV isn't representable as a Constant. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l08011">8011</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l08011">BuildConstantFromSCEV()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l08011">BuildConstantFromSCEV()</a>.</p>

</div>
</div>
<a id="af1691ba36ec490f734755ccc9c0d4c95" name="af1691ba36ec490f734755ccc9c0d4c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1691ba36ec490f734755ccc9c0d4c95">&#9670;&nbsp;</a></span>canConstantEvolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool canConstantEvolve </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Loop *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether this instruction can constant evolve within this loop assuming its operands can all constant evolve. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07688">7688</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l07674">CanConstantFold()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07764">EvaluateExpression()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07748">getConstantEvolvingPHI()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l07706">getConstantEvolvingPHIOperands()</a>.</p>

</div>
</div>
<a id="a250f5c0dbc15e78bded9c6bbd4354185" name="a250f5c0dbc15e78bded9c6bbd4354185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250f5c0dbc15e78bded9c6bbd4354185">&#9670;&nbsp;</a></span>CanConstantFold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool CanConstantFold </td>
          <td>(</td>
          <td class="paramtype">const Instruction *&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if we can constant fold an instruction of the specified type, assuming that all operands were constants. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07674">7674</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07688">canConstantEvolve()</a>.</p>

</div>
</div>
<a id="aeab53b73cc54e312fd1745ebffccc7dc" name="aeab53b73cc54e312fd1745ebffccc7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab53b73cc54e312fd1745ebffccc7dc">&#9670;&nbsp;</a></span>Choose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t Choose </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>Overflow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the result of "n choose k", the binomial coefficient. </p>
<p >If an intermediate computation overflows, Overflow will be set and the return will be garbage. Overflow is not cleared on absence of overflow. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l02857">2857</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l02848">umul_ov()</a>.</p>

</div>
</div>
<a id="afd878be03640c9f0c9cc90aa77b05225" name="afd878be03640c9f0c9cc90aa77b05225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd878be03640c9f0c9cc90aa77b05225">&#9670;&nbsp;</a></span>CollectAddOperandsWithScales()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool CollectAddOperandsWithScales </td>
          <td>(</td>
          <td class="paramtype">DenseMap&lt; const SCEV *, APInt &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;&#160;</td>
          <td class="paramname"><em>NewOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">APInt &amp;&#160;</td>
          <td class="paramname"><em>AccumulatedConstant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *const *&#160;</td>
          <td class="paramname"><em>Ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>Scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the given Ops list, which is a list of operands to be added under the given scale, update the given map. </p>
<p >This is a helper function for getAddRecExpr. As an example of what it does, given a sequence of operands that would form an add expression like this:</p>
<p >m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r)</p>
<p >where A and B are constants, update the map with these values:</p>
<p >(m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0)</p>
<p >and add 13 + A*B*29 to AccumulatedConstant. This will allow getAddRecExpr to produce this:</p>
<p >13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B)</p>
<p >This form often exposes folding opportunities that are hidden in the original operand list.</p>
<p >Return true iff it appears that any interesting folding opportunities may be exposed. This helps getAddRecExpr short-circuit extra work in the common case where no interesting opportunities are present, and is also used as a check to avoid infinite recursion. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l02264">2264</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l02264">CollectAddOperandsWithScales()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l02264">CollectAddOperandsWithScales()</a>.</p>

</div>
</div>
<a id="ae9d4155b10ad0de9333f03e28d80062d" name="ae9d4155b10ad0de9333f03e28d80062d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d4155b10ad0de9333f03e28d80062d">&#9670;&nbsp;</a></span>CompareSCEVComplexity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int CompareSCEVComplexity </td>
          <td>(</td>
          <td class="paramtype">EquivalenceClasses&lt; const SCEV * &gt; &amp;&#160;</td>
          <td class="paramname"><em>EqCacheSCEV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EquivalenceClasses&lt; const Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>EqCacheValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoopInfo *const&#160;</td>
          <td class="paramname"><em>LI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DominatorTree &amp;&#160;</td>
          <td class="paramname"><em>DT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l00647">647</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l00647">CompareSCEVComplexity()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l00570">CompareValueComplexity()</a>, <a class="el" href="ScalarEvolution_8cpp.html#aa9e72a43694f4179f607493b1f7d2c59">MaxSCEVCompareDepth()</a>, and <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l00647">CompareSCEVComplexity()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l00798">GroupByComplexity()</a>.</p>

</div>
</div>
<a id="a87ea59154b2de6dc273eb071b3f16265" name="a87ea59154b2de6dc273eb071b3f16265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ea59154b2de6dc273eb071b3f16265">&#9670;&nbsp;</a></span>CompareValueComplexity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int CompareValueComplexity </td>
          <td>(</td>
          <td class="paramtype">EquivalenceClasses&lt; const Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>EqCacheValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoopInfo *const&#160;</td>
          <td class="paramname"><em>LI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>LV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>RV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the two values <code>LV</code> and <code>RV</code> in terms of their "complexity" where "complexity" is a partial (and somewhat ad-hoc) relation used to order operands in SCEV expressions. </p>
<p ><code>EqCache</code> is a set of pairs of values that have been previously deemed to be "equally complex" by this routine. It is intended to avoid exponential time complexity in cases like:</p>
<p >a = f(x, y) b = f(a, a) c = f(b, b)</p>
<p >d = f(x, y) e = f(d, d) f = f(e, e)</p>
<p >CompareValueComplexity(f, c)</p>
<p >Since we do not continue running this routine on expression trees once we have seen unequal values, there is no need to track them in the cache. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l00570">570</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l00570">CompareValueComplexity()</a>, <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00342">Idx</a>, and <a class="el" href="ScalarEvolution_8cpp.html#afd04c7d9c924e7c3685e82ca1fadfef4">MaxValueCompareDepth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l00647">CompareSCEVComplexity()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l00570">CompareValueComplexity()</a>.</p>

</div>
</div>
<a id="a75a63c2d772bc6e774e216072117b95a" name="a75a63c2d772bc6e774e216072117b95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a63c2d772bc6e774e216072117b95a">&#9670;&nbsp;</a></span>containsConstantInAddMulChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool containsConstantInAddMulChain </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>StartExpr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if any of the operands in this SCEV are a constant or if any of the add or multiply expressions in this SCEV contain a constant. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l02882">2882</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>.</p>

</div>
</div>
<a id="ad178fa857aa5165e7807333157652e05" name="ad178fa857aa5165e7807333157652e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad178fa857aa5165e7807333157652e05">&#9670;&nbsp;</a></span>containsParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool containsParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Terms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l11026">11026</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a9649394e7b50e4ae2d6bf3673de5d94d" name="a9649394e7b50e4ae2d6bf3673de5d94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9649394e7b50e4ae2d6bf3673de5d94d">&#9670;&nbsp;</a></span>containsUndefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool containsUndefs </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l10819">10819</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a54dedd456f8ee5d9877d13c9717ef94b" name="a54dedd456f8ee5d9877d13c9717ef94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dedd456f8ee5d9877d13c9717ef94b">&#9670;&nbsp;</a></span>EvaluateConstantChrecAtConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ConstantInt * EvaluateConstantChrecAtConstant </td>
          <td>(</td>
          <td class="paramtype">const SCEVAddRecExpr *&#160;</td>
          <td class="paramname"><em>AddRec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstantInt *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07442">7442</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l08505">SolveQuadraticAddRecExact()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l08537">SolveQuadraticAddRecRange()</a>.</p>

</div>
</div>
<a id="ad62d5df272037a3079a05b96be49cc44" name="ad62d5df272037a3079a05b96be49cc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62d5df272037a3079a05b96be49cc44">&#9670;&nbsp;</a></span>EvaluateExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * EvaluateExpression </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Loop *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseMap&lt; Instruction *, Constant * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataLayout &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetLibraryInfo *&#160;</td>
          <td class="paramname"><em>TLI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>EvaluateExpression - Given an expression that passes the getConstantEvolvingPHI predicate, evaluate its value assuming the PHI node in the loop has the value PHIVal. </p>
<p >If we can't fold this expression for some reason, return null. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07764">7764</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l07688">canConstantEvolve()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07764">EvaluateExpression()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07764">EvaluateExpression()</a>.</p>

</div>
</div>
<a id="a5589e186b84c92aaeecbaeaf6253ebc8" name="a5589e186b84c92aaeecbaeaf6253ebc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5589e186b84c92aaeecbaeaf6253ebc8">&#9670;&nbsp;</a></span>extractConstantWithoutWrapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static APInt extractConstantWithoutWrapping </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>ConstantStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>Step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l01622">1622</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="ab1ecca94c1ac1a616d83f565a4aeaeae" name="ab1ecca94c1ac1a616d83f565a4aeaeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ecca94c1ac1a616d83f565a4aeaeae">&#9670;&nbsp;</a></span>extractConstantWithoutWrapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static APInt extractConstantWithoutWrapping </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEVConstant *&#160;</td>
          <td class="paramname"><em>ConstantTerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEVAddExpr *&#160;</td>
          <td class="paramname"><em>WholeAddExpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l01601">1601</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a80f3984cb81d6b8e7810c8b313739043" name="a80f3984cb81d6b8e7810c8b313739043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f3984cb81d6b8e7810c8b313739043">&#9670;&nbsp;</a></span>findArrayDimensionsRec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool findArrayDimensionsRec </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Terms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l10979">10979</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l10979">findArrayDimensionsRec()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l10979">findArrayDimensionsRec()</a>.</p>

</div>
</div>
<a id="a139eacd669113b3a982b9c3a6240b3bd" name="a139eacd669113b3a982b9c3a6240b3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139eacd669113b3a982b9c3a6240b3bd">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const APInt gcd </td>
          <td>(</td>
          <td class="paramtype">const SCEVConstant *&#160;</td>
          <td class="paramname"><em>C1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEVConstant *&#160;</td>
          <td class="paramname"><em>C2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l03315">3315</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a5c77277af6c3f267a47374301462096e" name="a5c77277af6c3f267a47374301462096e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c77277af6c3f267a47374301462096e">&#9670;&nbsp;</a></span>getConstantEvolvingPHI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PHINode * getConstantEvolvingPHI </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Loop *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getConstantEvolvingPHI - Given an LLVM value and a loop, return a PHI node in the loop that V is derived from. </p>
<p >We allow arbitrary operations along the way, but the operands of an operation must either be constants or a value derived from a constant PHI. If this expression does not fit with these constraints, return null. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07748">7748</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l07688">canConstantEvolve()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07706">getConstantEvolvingPHIOperands()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="af278ae155bd811822054e98b8f056c56" name="af278ae155bd811822054e98b8f056c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af278ae155bd811822054e98b8f056c56">&#9670;&nbsp;</a></span>getConstantEvolvingPHIOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PHINode * getConstantEvolvingPHIOperands </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>UseInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Loop *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseMap&lt; Instruction *, PHINode * &gt; &amp;&#160;</td>
          <td class="paramname"><em>PHIMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getConstantEvolvingPHIOperands - Implement getConstantEvolvingPHI by recursing through each instruction operand until reaching a loop header phi. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07706">7706</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l07688">canConstantEvolve()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07706">getConstantEvolvingPHIOperands()</a>, <a class="el" href="ScalarEvolution_8cpp.html#a75fa405974f8587085c789435a5b6129">MaxConstantEvolvingDepth()</a>, and <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07748">getConstantEvolvingPHI()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l07706">getConstantEvolvingPHIOperands()</a>.</p>

</div>
</div>
<a id="a0bf0cf316748d2fb01a45268ffc10a02" name="a0bf0cf316748d2fb01a45268ffc10a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf0cf316748d2fb01a45268ffc10a02">&#9670;&nbsp;</a></span>getConstantTripCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned getConstantTripCount </td>
          <td>(</td>
          <td class="paramtype">const SCEVConstant *&#160;</td>
          <td class="paramname"><em>ExitCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l06492">6492</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a7762f1d99f297ecb6ccb4375e715c2ea" name="a7762f1d99f297ecb6ccb4375e715c2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7762f1d99f297ecb6ccb4375e715c2ea">&#9670;&nbsp;</a></span>getExtendAddRecStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExtendOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SCEV * getExtendAddRecStart </td>
          <td>(</td>
          <td class="paramtype">const SCEVAddRecExpr *&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution *&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l01507">1507</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="af8996f55e648de5006cb39d80c65d60e" name="af8996f55e648de5006cb39d80c65d60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8996f55e648de5006cb39d80c65d60e">&#9670;&nbsp;</a></span>getOtherIncomingValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Constant * getOtherIncomingValue </td>
          <td>(</td>
          <td class="paramtype">PHINode *&#160;</td>
          <td class="paramname"><em>PN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>BB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l07812">7812</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a359235e468f7ab6f4dccbed37c17dee1" name="a359235e468f7ab6f4dccbed37c17dee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359235e468f7ab6f4dccbed37c17dee1">&#9670;&nbsp;</a></span>getPreStartForExtend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExtendOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SCEV * getPreStartForExtend </td>
          <td>(</td>
          <td class="paramtype">const SCEVAddRecExpr *&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution *&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l01433">1433</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a8e217ca9d64187d9ea2bfbe8213b4767" name="a8e217ca9d64187d9ea2bfbe8213b4767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e217ca9d64187d9ea2bfbe8213b4767">&#9670;&nbsp;</a></span>GetQuadraticEquation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; std::tuple&lt; APInt, APInt, APInt, APInt, unsigned &gt; &gt; GetQuadraticEquation </td>
          <td>(</td>
          <td class="paramtype">const SCEVAddRecExpr *&#160;</td>
          <td class="paramname"><em>AddRec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given quadratic addrec, generate coefficients of the corresponding quadratic equation, multiplied by a common value to ensure that they are integers. </p>
<p >The returned value is a tuple { A, B, C, M, BitWidth }, where Ax^2 + Bx + C is the quadratic function, M is the value that A, B and C were multiplied by, and BitWidth is the bit width of the original addrec coefficients. This function returns None if the addrec coefficients are not compile- time constants. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l08405">8405</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="regutils_8h_source.html#l00042">NC</a>, and <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l08505">SolveQuadraticAddRecExact()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l08537">SolveQuadraticAddRecRange()</a>.</p>

</div>
</div>
<a id="abffe1c5730168a86a46e690447dd6d97" name="abffe1c5730168a86a46e690447dd6d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffe1c5730168a86a46e690447dd6d97">&#9670;&nbsp;</a></span>getRangeForAffineARHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ConstantRange getRangeForAffineARHelper </td>
          <td>(</td>
          <td class="paramtype">APInt&#160;</td>
          <td class="paramname"><em>Step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstantRange &amp;&#160;</td>
          <td class="paramname"><em>StartRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>MaxBECount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>BitWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Signed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l05738">5738</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a833702f8d0f629818b2b04031677b0d1" name="a833702f8d0f629818b2b04031677b0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833702f8d0f629818b2b04031677b0d1">&#9670;&nbsp;</a></span>GetRangeFromMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; ConstantRange &gt; GetRangeFromMetadata </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to assign a range to V from metadata present in the IR. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l05521">5521</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>.</p>

</div>
</div>
<a id="ae8a19e1b12d26ad87bc379e576ff5a7f" name="ae8a19e1b12d26ad87bc379e576ff5a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a19e1b12d26ad87bc379e576ff5a7f">&#9670;&nbsp;</a></span>getSignedOverflowLimitForStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SCEV * getSignedOverflowLimitForStep </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>Step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate *&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution *&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l01341">1341</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="aff0515f214b4d4e5d5a3197b11d5eacc" name="aff0515f214b4d4e5d5a3197b11d5eacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0515f214b4d4e5d5a3197b11d5eacc">&#9670;&nbsp;</a></span>getUnsignedOverflowLimitForStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SCEV * getUnsignedOverflowLimitForStep </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>Step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate *&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution *&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l01361">1361</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a4d43163acfcdefe57d402dab3640d8be" name="a4d43163acfcdefe57d402dab3640d8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d43163acfcdefe57d402dab3640d8be">&#9670;&nbsp;</a></span>GroupByComplexity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void GroupByComplexity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; const SCEV * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopInfo *&#160;</td>
          <td class="paramname"><em>LI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DominatorTree &amp;&#160;</td>
          <td class="paramname"><em>DT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of SCEV objects, order them by their complexity, and group objects of the same complexity together by value. </p>
<p >When this routine is finished, we know that any duplicates in the vector are consecutive and that complexity is monotonically increasing.</p>
<p >Note that we go take special precautions to ensure that we get deterministic results from this routine. In other words, we don't want the results of this to depend on where the addresses of various SCEV objects happened to land in memory. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l00798">798</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l00647">CompareSCEVComplexity()</a>.</p>

</div>
</div>
<a id="a81a7153270eb1fafa4502adc85f49adf" name="a81a7153270eb1fafa4502adc85f49adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a7153270eb1fafa4502adc85f49adf">&#9670;&nbsp;</a></span>hasHugeExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasHugeExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const SCEV * &gt;&#160;</td>
          <td class="paramname"><em>Ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true of <code>Ops</code> contains a huge SCEV (see definition above). </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l00871">871</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l00866">isHugeExpression()</a>.</p>

</div>
</div>
<a id="aea8979aa7e40386835642f9f5f9f36d2" name="aea8979aa7e40386835642f9f5f9f36d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8979aa7e40386835642f9f5f9f36d2">&#9670;&nbsp;</a></span>HasSameValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool HasSameValue </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SCEV structural equivalence is usually sufficient for testing whether two expressions are equal, however for the purposes of looking for a condition guarding a loop, it can be useful to be a little more general, since a front-end may have replicated the controlling expression. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l08833">8833</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a9d7254e838e5ffd28362ae8157e53674" name="a9d7254e838e5ffd28362ae8157e53674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7254e838e5ffd28362ae8157e53674">&#9670;&nbsp;</a></span>HugeExprThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; HugeExprThreshold </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-huge-expr-threshold&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Size of the expression which is considered huge&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(4096)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l00866">isHugeExpression()</a>.</p>

</div>
</div>
<a id="a3e24c91db8604ae3ee873162c89749d3" name="a3e24c91db8604ae3ee873162c89749d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e24c91db8604ae3ee873162c89749d3">&#9670;&nbsp;</a></span>INITIALIZE_PASS_BEGIN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INITIALIZE_PASS_BEGIN </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolutionWrapperPass&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;scalar-evolution&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Scalar Evolution Analysis&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">false&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac99b948bcde1ca2925452cc91317656b" name="ac99b948bcde1ca2925452cc91317656b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99b948bcde1ca2925452cc91317656b">&#9670;&nbsp;</a></span>IsAvailableOnEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsAvailableOnEntry </td>
          <td>(</td>
          <td class="paramtype">const Loop *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DominatorTree &amp;&#160;</td>
          <td class="paramname"><em>DT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BasicBlock *&#160;</td>
          <td class="paramname"><em>BB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l05158">5158</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="abaeb2b6b40e731d47df632839fa3deca" name="abaeb2b6b40e731d47df632839fa3deca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaeb2b6b40e731d47df632839fa3deca">&#9670;&nbsp;</a></span>isHugeExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isHugeExpression </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the subtree of <code>S</code> contains at least HugeExprThreshold nodes. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l00866">866</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp.html#a9d7254e838e5ffd28362ae8157e53674">HugeExprThreshold()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l00871">hasHugeExpression()</a>.</p>

</div>
</div>
<a id="a08188d419e040050ef28ea516afebf98" name="a08188d419e040050ef28ea516afebf98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08188d419e040050ef28ea516afebf98">&#9670;&nbsp;</a></span>isIntegerLoopHeaderPHI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const Loop * isIntegerLoopHeaderPHI </td>
          <td>(</td>
          <td class="paramtype">const PHINode *&#160;</td>
          <td class="paramname"><em>PN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopInfo &amp;&#160;</td>
          <td class="paramname"><em>LI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l04617">4617</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="aa9da73da463d6ed62b1d24df36fac961" name="aa9da73da463d6ed62b1d24df36fac961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9da73da463d6ed62b1d24df36fac961">&#9670;&nbsp;</a></span>IsKnownPredicateViaAddRecStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsKnownPredicateViaAddRecStart </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l10102">10102</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a23a7c6b9fe0d5ef6694bf8a5183d8a69" name="a23a7c6b9fe0d5ef6694bf8a5183d8a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a7c6b9fe0d5ef6694bf8a5183d8a69">&#9670;&nbsp;</a></span>IsKnownPredicateViaMinOrMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsKnownPredicateViaMinOrMax </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is LHS <code>Pred</code> RHS true on the virtue of LHS or RHS being a Min or Max expression? </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l10136">10136</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a59fcf5b90a1e31b126ee5d8a80275654" name="a59fcf5b90a1e31b126ee5d8a80275654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fcf5b90a1e31b126ee5d8a80275654">&#9670;&nbsp;</a></span>IsMinMaxConsistingOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MinMaxExprType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsMinMaxConsistingOf </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>MaybeMinMaxExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>Candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is MaybeMinMaxExpr an (U|S)(Min|Max) of Candidate and some other values? </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l10093">10093</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="ad5a0854a75b9e8d760fd95387759569c" name="ad5a0854a75b9e8d760fd95387759569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a0854a75b9e8d760fd95387759569c">&#9670;&nbsp;</a></span>isSimpleCastedPHI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Type * isSimpleCastedPHI </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>Op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEVUnknown *&#160;</td>
          <td class="paramname"><em>SymbolicPHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>Signed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to createAddRecFromPHIWithCasts. </p>
<p >We have a phi node whose symbolic (unknown) SCEV is <code>SymbolicPHI</code>, which is updated via the loop backedge by a SCEVAddExpr, possibly also with a few casts on the way. This function checks if <code>Op</code>, an operand of this SCEVAddExpr, follows one of the following patterns: Op == (SExt ix (Trunc iy (SymbolicPHI) to ix) to iy) Op == (ZExt ix (Trunc iy (SymbolicPHI) to ix) to iy) If the SCEV expression of <code>Op</code> conforms with one of the expected patterns we return the type of the truncation operation, and indicate whether the truncated type should be treated as signed/unsigned by setting <code>Signed</code> to true/false, respectively. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l04581">4581</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>.</p>

</div>
</div>
<a id="abd00c5af76d76d690df3147ac7c6aa3e" name="abd00c5af76d76d690df3147ac7c6aa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd00c5af76d76d690df3147ac7c6aa3e">&#9670;&nbsp;</a></span>loopDispositionToStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef loopDispositionToStr </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolution::LoopDisposition&#160;</td>
          <td class="paramname"><em>LD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l11469">11469</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="ad468036d72843ee38e6c61dc62673865" name="ad468036d72843ee38e6c61dc62673865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad468036d72843ee38e6c61dc62673865">&#9670;&nbsp;</a></span>MatchBinaryOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; BinaryOp &gt; MatchBinaryOp </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DominatorTree &amp;&#160;</td>
          <td class="paramname"><em>DT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to map <code>V</code> into a BinaryOp, and return <code>None</code> on failure. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l04494">4494</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>, and <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>.</p>

</div>
</div>
<a id="adaa8fd1f2af30380d7080ef96b976209" name="adaa8fd1f2af30380d7080ef96b976209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa8fd1f2af30380d7080ef96b976209">&#9670;&nbsp;</a></span>MatchNotExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SCEV * MatchNotExpr </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>Expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If Expr computes ~A, return A else return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l03955">3955</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a1744890ecac75bc8d67772462fad7115" name="a1744890ecac75bc8d67772462fad7115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1744890ecac75bc8d67772462fad7115">&#9670;&nbsp;</a></span>MaxAddRecSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MaxAddRecSize </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-<a class="el" href="FileCheck_8cpp.html#a1e23cc505a17287914489e2d7f7093ba">add</a>-rec-size&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Max coefficients in AddRec during evolving&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(8)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe4e035e66d591e105444d5861d772c5" name="afe4e035e66d591e105444d5861d772c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4e035e66d591e105444d5861d772c5">&#9670;&nbsp;</a></span>MaxArithDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MaxArithDepth </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-arith-depth&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Maximum depth of recursive arithmetics&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(32)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3f137765452a0490e5b8e07b718ef95" name="ab3f137765452a0490e5b8e07b718ef95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f137765452a0490e5b8e07b718ef95">&#9670;&nbsp;</a></span>MaxBruteForceIterations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MaxBruteForceIterations </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-iterations&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::ReallyHidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Maximum number of iterations SCEV will &quot; &quot;symbolically execute a constant &quot; &quot;derived loop&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(100)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73e002462df1247cb9c4374d39dda895" name="a73e002462df1247cb9c4374d39dda895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e002462df1247cb9c4374d39dda895">&#9670;&nbsp;</a></span>MaxCastDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MaxCastDepth </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-cast-depth&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Maximum depth of recursive SExt/ZExt/Trunc&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(8)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75fa405974f8587085c789435a5b6129" name="a75fa405974f8587085c789435a5b6129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fa405974f8587085c789435a5b6129">&#9670;&nbsp;</a></span>MaxConstantEvolvingDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MaxConstantEvolvingDepth </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-constant-evolving-depth&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Maximum depth of recursive constant evolving&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(32)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l07706">getConstantEvolvingPHIOperands()</a>.</p>

</div>
</div>
<a id="aa9e72a43694f4179f607493b1f7d2c59" name="aa9e72a43694f4179f607493b1f7d2c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e72a43694f4179f607493b1f7d2c59">&#9670;&nbsp;</a></span>MaxSCEVCompareDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MaxSCEVCompareDepth </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-scev-compare-depth&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Maximum depth of recursive SCEV complexity comparisons&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(32)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l00647">CompareSCEVComplexity()</a>.</p>

</div>
</div>
<a id="a632ff5198de03696a428d04d0a3751f1" name="a632ff5198de03696a428d04d0a3751f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632ff5198de03696a428d04d0a3751f1">&#9670;&nbsp;</a></span>MaxSCEVOperationsImplicationDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MaxSCEVOperationsImplicationDepth </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-scev-<a class="el" href="Scalarizer_8cpp.html#a16225fc97f8d45afdbb29637c6750d89">operations</a>-implication-depth&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Maximum depth of recursive SCEV <a class="el" href="Scalarizer_8cpp.html#a16225fc97f8d45afdbb29637c6750d89">operations</a> implication analysis&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(2)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd04c7d9c924e7c3685e82ca1fadfef4" name="afd04c7d9c924e7c3685e82ca1fadfef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd04c7d9c924e7c3685e82ca1fadfef4">&#9670;&nbsp;</a></span>MaxValueCompareDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MaxValueCompareDepth </td>
          <td>(</td>
          <td class="paramtype">&quot;scalar-<a class="el" href="ScalarEvolution_8cpp.html#afa04c31b8a224e9f4e66ba448f05e9d0">evolution</a>-max-value-compare-depth&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Maximum depth of recursive value complexity comparisons&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(2)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l00570">CompareValueComplexity()</a>.</p>

</div>
</div>
<a id="afb949d24a9865adbdc717af178e35d8f" name="afb949d24a9865adbdc717af178e35d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb949d24a9865adbdc717af178e35d8f">&#9670;&nbsp;</a></span>MinOptional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; APInt &gt; MinOptional </td>
          <td>(</td>
          <td class="paramtype">Optional&lt; APInt &gt;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional&lt; APInt &gt;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to compare optional APInts: (a) if X and Y both exist, return min(X, Y), (b) if neither X nor Y exist, return None, (c) if exactly one of X and Y exists, return that value. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l08458">8458</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>, <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>, and <a class="el" href="Hello_8cpp.html#ac3d32b43305241160f8c774e4ce25824">Y()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l08537">SolveQuadraticAddRecRange()</a>.</p>

</div>
</div>
<a id="ac1e7f9ca744365f5223b0cf104d47c2c" name="ac1e7f9ca744365f5223b0cf104d47c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e7f9ca744365f5223b0cf104d47c2c">&#9670;&nbsp;</a></span>MulOpsInlineThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; unsigned &gt; MulOpsInlineThreshold </td>
          <td>(</td>
          <td class="paramtype">&quot;scev-mulops-<a class="el" href="AlwaysInliner_8cpp.html#a46ccdc20c42bb5ae5b9d313e12a68421">inline</a>-threshold&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Threshold for inlining multiplication operands into a SCEV&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(32)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adca18fd87fe200f89b539ad52ee46421" name="adca18fd87fe200f89b539ad52ee46421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca18fd87fe200f89b539ad52ee46421">&#9670;&nbsp;</a></span>numberOfTerms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int numberOfTerms </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l11034">11034</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a7170e1b99a9c472642f756b8cf098afa" name="a7170e1b99a9c472642f756b8cf098afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7170e1b99a9c472642f756b8cf098afa">&#9670;&nbsp;</a></span>PrintLoopInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PrintLoopInfo </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>OS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution *&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Loop *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l11407">11407</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l11407">PrintLoopInfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l11407">PrintLoopInfo()</a>.</p>

</div>
</div>
<a id="af50d189708d19a31f6c189c947c45dcc" name="af50d189708d19a31f6c189c947c45dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50d189708d19a31f6c189c947c45dcc">&#9670;&nbsp;</a></span>PushDefUseChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PushDefUseChildren </td>
          <td>(</td>
          <td class="paramtype">Instruction *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Instruction * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Worklist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push users of the given Instruction onto the given Worklist. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l04180">4180</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a649011f27bb212ab1bdd0ec7e041da79" name="a649011f27bb212ab1bdd0ec7e041da79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649011f27bb212ab1bdd0ec7e041da79">&#9670;&nbsp;</a></span>PushLoopPHIs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PushLoopPHIs </td>
          <td>(</td>
          <td class="paramtype">const Loop *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; Instruction * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Worklist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push PHI nodes in the header of the given loop onto the given Worklist. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l06612">6612</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a161de17b2db4a6bdb9b4ce1ea13da113" name="a161de17b2db4a6bdb9b4ce1ea13da113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161de17b2db4a6bdb9b4ce1ea13da113">&#9670;&nbsp;</a></span>removeConstantFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SCEV * removeConstantFactors </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l11040">11040</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="a09483c84fbbf3fb99c11f787a41d4282" name="a09483c84fbbf3fb99c11f787a41d4282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09483c84fbbf3fb99c11f787a41d4282">&#9670;&nbsp;</a></span>SCEVLostPoisonFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SCEVLostPoisonFlags </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value *&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether value has nuw/nsw/exact set but SCEV does not. </p>
<p >TODO: In reality it is better to check the poison recursively but this is better than nothing. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l03878">3878</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a02f034bf5597953817366d130081d65e" name="a02f034bf5597953817366d130081d65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f034bf5597953817366d130081d65e">&#9670;&nbsp;</a></span>sizeOfSCEV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int sizeOfSCEV </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l00841">841</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>.</p>

</div>
</div>
<a id="abecc30e106f1f2c10a9f338d96849ead" name="abecc30e106f1f2c10a9f338d96849ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecc30e106f1f2c10a9f338d96849ead">&#9670;&nbsp;</a></span>SolveLinEquationWithOverflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const SCEV * SolveLinEquationWithOverflow </td>
          <td>(</td>
          <td class="paramtype">const APInt &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the minimum unsigned root of the following equation: </p>
<pre class="fragment">A * X = B (mod N)
</pre><p> where N = 2^BW and BW is the common bit width of A and B. The signedness of A and B isn't important.</p>
<p >If the equation does not have a solution, SCEVCouldNotCompute is returned. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l08356">8356</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a60573ada7a8a58e0806db0a02c54034c" name="a60573ada7a8a58e0806db0a02c54034c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60573ada7a8a58e0806db0a02c54034c">&#9670;&nbsp;</a></span>SolveQuadraticAddRecExact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; APInt &gt; SolveQuadraticAddRecExact </td>
          <td>(</td>
          <td class="paramtype">const SCEVAddRecExpr *&#160;</td>
          <td class="paramname"><em>AddRec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let c(n) be the value of the quadratic chrec {L,+,M,+,N} after n iterations. </p>
<p >The values L, M, N are assumed to be signed, and they should all have the same bit widths. Find the least n &gt;= 0 such that c(n) = 0 in the arithmetic modulo 2^BW, where BW is the bit width of the addrec's coefficients. If the calculated value is a BW-bit integer (for BW &gt; 1), it will be returned as such, otherwise the bit width of the returned value may be greater than BW.</p>
<p >This function returns None if (a) the addrec coefficients are not constant, or (b) SolveQuadraticEquationWrap was unable to find a solution. For cases like x^2 = 5, no integer solutions exist, in other cases an integer solution may exist, but SolveQuadraticEquationWrap may fail to find it. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l08505">8505</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="ScalarEvolution_8cpp_source.html#l07442">EvaluateConstantChrecAtConstant()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08405">GetQuadraticEquation()</a>, <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08481">TruncIfPossible()</a>, and <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>.</p>

</div>
</div>
<a id="a46f6706b3d1f2cecb7bc63c575730c3a" name="a46f6706b3d1f2cecb7bc63c575730c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f6706b3d1f2cecb7bc63c575730c3a">&#9670;&nbsp;</a></span>SolveQuadraticAddRecRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; APInt &gt; SolveQuadraticAddRecRange </td>
          <td>(</td>
          <td class="paramtype">const SCEVAddRecExpr *&#160;</td>
          <td class="paramname"><em>AddRec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstantRange &amp;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarEvolution &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let c(n) be the value of the quadratic chrec {0,+,M,+,N} after n iterations. </p>
<p >The values M, N are assumed to be signed, and they should all have the same bit widths. Find the least n such that c(n) does not belong to the given range, while c(n-1) does.</p>
<p >This function returns None if (a) the addrec coefficients are not constant, or (b) SolveQuadraticEquationWrap was unable to find a solution for the bounds of the range. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l08537">8537</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l07442">EvaluateConstantChrecAtConstant()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08405">GetQuadraticEquation()</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08458">MinOptional()</a>, <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>, <a class="el" href="ScalarEvolution_8cpp_source.html#l08481">TruncIfPossible()</a>, and <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>.</p>

</div>
</div>
<a id="a58cdae21b048b79d4bf76840307e5ec1" name="a58cdae21b048b79d4bf76840307e5ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cdae21b048b79d4bf76840307e5ec1">&#9670;&nbsp;</a></span>splitAddExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt; const SCEV *, ConstantInt * &gt; splitAddExpr </td>
          <td>(</td>
          <td class="paramtype">const SCEV *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to split a SCEVAddExpr into a pair of {SCEV, ConstantInt}. </p>
<p >If <code>S</code> is a SCEVAddExpr and is composed of a sub SCEV S' and an offset I, then return {S', I}, else return {<code>S</code>, nullptr}. </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l03820">3820</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="af8a5a920ebf3ac959a50b6616062ff81" name="af8a5a920ebf3ac959a50b6616062ff81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a5a920ebf3ac959a50b6616062ff81">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumArrayLenItCounts&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of trip counts computed with array length&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8f52513f38d05cfd467fc8836aee852" name="ac8f52513f38d05cfd467fc8836aee852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f52513f38d05cfd467fc8836aee852">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumBruteForceTripCountsComputed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of <a class="el" href="LoopInfo_8cpp.html#a49ae40a9c91d665793aaed656c26ca30">loops</a> with trip counts computed by force&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a649b6bfcbe6c4e440b148e1acb606df5" name="a649b6bfcbe6c4e440b148e1acb606df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649b6bfcbe6c4e440b148e1acb606df5">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumTripCountsComputed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of <a class="el" href="LoopInfo_8cpp.html#a49ae40a9c91d665793aaed656c26ca30">loops</a> with predictable loop counts&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75749936481a8d4a33b815468d0914ce" name="a75749936481a8d4a33b815468d0914ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75749936481a8d4a33b815468d0914ce">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumTripCountsNotComputed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of <a class="el" href="LoopInfo_8cpp.html#a49ae40a9c91d665793aaed656c26ca30">loops</a> without predictable loop counts&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae99f51fb7f4e120a8ebeb76e3c53cf2b" name="ae99f51fb7f4e120a8ebeb76e3c53cf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99f51fb7f4e120a8ebeb76e3c53cf2b">&#9670;&nbsp;</a></span>StrengthenNoWrapFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SCEV::NoWrapFlags StrengthenNoWrapFlags </td>
          <td>(</td>
          <td class="paramtype">ScalarEvolution *&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCEVTypes&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const SCEV * &gt;&#160;</td>
          <td class="paramname"><em>Ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCEV::NoWrapFlags&#160;</td>
          <td class="paramname"><em>Flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l02333">2333</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeadArgumentElimination_8cpp.html#aa5bfc84fa71b9e3477e24efecb60fae5">assert()</a>.</p>

</div>
</div>
<a id="a80784b9f8579f525377a26d5f9e5cd63" name="a80784b9f8579f525377a26d5f9e5cd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80784b9f8579f525377a26d5f9e5cd63">&#9670;&nbsp;</a></span>TruncIfPossible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Optional&lt; APInt &gt; TruncIfPossible </td>
          <td>(</td>
          <td class="paramtype">Optional&lt; APInt &gt;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>BitWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to truncate an optional APInt to a given BitWidth. </p>
<p >When solving addrec-related equations, it is preferable to return a value that has the same bit width as the original addrec's coefficients. If the solution fits in the original bit width, truncate it (except for i1). Returning a value of a different bit width may inhibit some optimizations.</p>
<p >In general, a solution to a quadratic equation generated from an addrec may require BW+1 bits, where BW is the bit width of the addrec's coefficients. The reason is that the coefficients of the quadratic equation are BW+1 bits wide (to avoid truncation when converting from the addrec to the equation). </p>

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l08481">8481</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerBuilder_8cpp.html#a4521240b09299fd4d5bbf6954459c9d7a6adf97f83acf6453d4a6a4b1070f3754">None</a>, and <a class="el" href="Hello_8cpp.html#a5e1a2e7ef3f32b337808eafe48a5b6ac">X()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l08505">SolveQuadraticAddRecExact()</a>, and <a class="el" href="ScalarEvolution_8cpp_source.html#l08537">SolveQuadraticAddRecRange()</a>.</p>

</div>
</div>
<a id="a6c073d72f1aa69d68ffb88bf12a9c1b0" name="a6c073d72f1aa69d68ffb88bf12a9c1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c073d72f1aa69d68ffb88bf12a9c1b0">&#9670;&nbsp;</a></span>umul_ov()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t umul_ov </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>Overflow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l02848">2848</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolution_8cpp_source.html#l02857">Choose()</a>.</p>

</div>
</div>
<a id="ae1ce4b18b9a3b338f4bc0755a4a8ce09" name="ae1ce4b18b9a3b338f4bc0755a4a8ce09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ce4b18b9a3b338f4bc0755a4a8ce09">&#9670;&nbsp;</a></span>VerifyIR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt; VerifyIR </td>
          <td>(</td>
          <td class="paramtype">&quot;scev-verify-ir&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Verify <a class="el" href="Lint_8cpp.html#a7fb3c9caadeb0f7fe4828d380158d0f9">IR</a> correctness when making sensitive SCEV queries (slow)&quot;)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(false)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f51ce4c960db9eea00624233ccd2f70" name="a9f51ce4c960db9eea00624233ccd2f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f51ce4c960db9eea00624233ccd2f70">&#9670;&nbsp;</a></span>VerifySCEV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt; VerifySCEV </td>
          <td>(</td>
          <td class="paramtype">&quot;verify-scev&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Verify ScalarEvolution's backedge taken counts (slow)&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8df932adc2cfcb32157885ffa5077eb6" name="a8df932adc2cfcb32157885ffa5077eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df932adc2cfcb32157885ffa5077eb6">&#9670;&nbsp;</a></span>VerifySCEVMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="PGOMemOPSizeOpt_8cpp.html#a9d9e3af0f29b78d5b6eae235741fbcbb">cl::opt</a>&lt; bool &gt; VerifySCEVMap </td>
          <td>(</td>
          <td class="paramtype">&quot;verify-scev-maps&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::desc(&quot;Verify no dangling value in ScalarEvolution's &quot; &quot;ExprValueMap (slow)&quot;)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a503499d4ac1af5de3ac8a7e4805e14aa" name="a503499d4ac1af5de3ac8a7e4805e14aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503499d4ac1af5de3ac8a7e4805e14aa">&#9670;&nbsp;</a></span>Analysis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scalar Scalar Evolution Analysis</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l11952">11952</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="afa04c31b8a224e9f4e66ba448f05e9d0" name="afa04c31b8a224e9f4e66ba448f05e9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa04c31b8a224e9f4e66ba448f05e9d0">&#9670;&nbsp;</a></span>evolution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scalar evolution</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l11951">11951</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
<a id="ab98634f319efc49e653ccb25caaf4090" name="ab98634f319efc49e653ccb25caaf4090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98634f319efc49e653ccb25caaf4090">&#9670;&nbsp;</a></span>false</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scalar Scalar Evolution false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ScalarEvolution_8cpp_source.html#l11952">11952</a> of file <a class="el" href="ScalarEvolution_8cpp_source.html">ScalarEvolution.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 12:44:44 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
