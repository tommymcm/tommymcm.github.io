<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: include/llvm/ADT/STLExtras.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dcde91663b8816e1e2311938ccd8f690.html">llvm</a></li><li class="navelem"><a class="el" href="dir_32453792af2ba70c54e3ccae3a790d1b.html">ADT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">STLExtras.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Optional_8h_source.html">llvm/ADT/Optional.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallVector_8h_source.html">llvm/ADT/SmallVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator_8h_source.html">llvm/ADT/iterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator__range_8h_source.html">llvm/ADT/iterator_range.h</a>&quot;</code><br />
<code>#include &quot;llvm/Config/abi-breaking.h&quot;</code><br />
<code>#include &quot;<a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html">llvm/Support/ErrorHandling.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;initializer_list&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for STLExtras.h:</div>
<div class="dyncontent">
<div class="center"><img src="STLExtras_8h__incl.png" border="0" usemap="#ainclude_2llvm_2ADT_2STLExtras_8h" alt=""/></div>
</div>
</div>
<p><a href="STLExtras_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1negation.html">llvm::negation&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1conjunction.html">llvm::conjunction&lt;... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1conjunction_3_01B1_01_4.html">llvm::conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1conjunction_3_01B1_00_01Bn_8_8_8_01_4.html">llvm::conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1make__const__ptr.html">llvm::make_const_ptr&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1make__const__ref.html">llvm::make_const_ref&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1identity.html">llvm::identity&lt; Ty &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1less__ptr.html">llvm::less_ptr&lt; Ty &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1greater__ptr.html">llvm::greater_ptr&lt; Ty &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1function__ref_3_01Ret_07Params_8_8_8_08_4.html">llvm::function_ref&lt; Ret(Params...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1mapped__iterator.html">llvm::mapped_iterator&lt; ItTy, FuncTy, FuncReturnTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1has__rbegin__impl.html">llvm::has_rbegin_impl&lt; Ty &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine if type T has a member called rbegin().  <a href="classllvm_1_1has__rbegin__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1has__rbegin.html">llvm::has_rbegin&lt; Ty &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to determine if T&amp; or T has a member called rbegin().  <a href="structllvm_1_1has__rbegin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__base.html">llvm::filter_iterator_base&lt; WrappedIteratorT, PredicateT, IterTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator adaptor that filters the elements of given inner iterators.  <a href="classllvm_1_1filter__iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__impl.html">llvm::filter_iterator_impl&lt; WrappedIteratorT, PredicateT, IterTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classllvm_1_1filter__iterator__base.html" title="An iterator adaptor that filters the elements of given inner iterators.">filter_iterator_base</a> for forward iteration only.  <a href="classllvm_1_1filter__iterator__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__impl_3_01WrappedIteratorT_00_01PredicateT_00_01std_1_1bidirectional__iterator__tag_01_4.html">llvm::filter_iterator_impl&lt; WrappedIteratorT, PredicateT, std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classllvm_1_1filter__iterator__base.html" title="An iterator adaptor that filters the elements of given inner iterators.">filter_iterator_base</a> for bidirectional iteration.  <a href="classllvm_1_1filter__iterator__impl_3_01WrappedIteratorT_00_01PredicateT_00_01std_1_1bidirectional__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag__impl.html">llvm::detail::fwd_or_bidi_tag_impl&lt; is_bidirectional &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag__impl_3_01true_01_4.html">llvm::detail::fwd_or_bidi_tag_impl&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag.html">llvm::detail::fwd_or_bidi_tag&lt; IterT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper which sets its type member to forward_iterator_tag if the category of <code>IterT</code> does not derive from bidirectional_iterator_tag, and to bidirectional_iterator_tag otherwise.  <a href="structllvm_1_1detail_1_1fwd__or__bidi__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1early__inc__iterator__impl.html">llvm::early_inc_iterator_impl&lt; WrappedIteratorT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudo-iterator adaptor that is designed to implement "early increment" style loops.  <a href="classllvm_1_1early__inc__iterator__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipTupleType.html">llvm::detail::ZipTupleType&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1zip__common.html">llvm::detail::zip_common&lt; ZipType, Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1zip__first.html">llvm::detail::zip_first&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__shortest.html">llvm::detail::zip_shortest&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zippy.html">llvm::detail::zippy&lt; ItType, Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipLongestItemType.html">llvm::detail::ZipLongestItemType&lt; Iter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipLongestTupleType.html">llvm::detail::ZipLongestTupleType&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__longest__iterator.html">llvm::detail::zip_longest_iterator&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__longest__range.html">llvm::detail::zip_longest_range&lt; Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1concat__iterator.html">llvm::concat_iterator&lt; ValueT, IterTs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator wrapper that concatenates sequences together.  <a href="classllvm_1_1concat__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1concat__range.html">llvm::detail::concat_range&lt; ValueT, RangeTs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to store a sequence of ranges being concatenated and access them.  <a href="classllvm_1_1detail_1_1concat__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1less__first.html">llvm::less_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to check whether the first component of a std::pair compares less than the first component of another std::pair.  <a href="structllvm_1_1less__first.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1less__second.html">llvm::less_second</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to check whether the second component of a std::pair compares less than the second component of another std::pair.  <a href="structllvm_1_1less__second.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1on__first.html">llvm::on_first&lt; FuncTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to apply a binary function to the first component of a std::pair.  <a href="structllvm_1_1on__first.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1integer__sequence.html">llvm::integer_sequence&lt; T, I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a compile-time sequence of integers.  <a href="structllvm_1_1integer__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1index__sequence.html">llvm::index_sequence&lt; I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the common case of a sequence of size_ts.  <a href="structllvm_1_1index__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1build__index__impl.html">llvm::build_index_impl&lt; N, I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1build__index__impl_3_010_00_01I_8_8_8_01_4.html">llvm::build_index_impl&lt; 0, I... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1index__sequence__for.html">llvm::index_sequence_for&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a compile-time integer sequence for a parameter pack.  <a href="structllvm_1_1index__sequence__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1rank.html">llvm::rank&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type to build an inheritance chain that makes it easy to rank overload candidates.  <a href="structllvm_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1rank_3_010_01_4.html">llvm::rank&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1is__one__of.html">llvm::is_one_of&lt; T, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits class for checking whether type T is one of any of the given types in the variadic list.  <a href="structllvm_1_1is__one__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1is__one__of_3_01T_00_01U_00_01Ts_8_8_8_01_4.html">llvm::is_one_of&lt; T, U, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1are__base__of.html">llvm::are_base_of&lt; T, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits class for checking whether type T is a base class for all the given types in the variadic list.  <a href="structllvm_1_1are__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1are__base__of_3_01T_00_01U_00_01Ts_8_8_8_01_4.html">llvm::are_base_of&lt; T, U, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1FreeDeleter.html">llvm::FreeDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1pair__hash.html">llvm::pair_hash&lt; First, Second &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1less.html">llvm::less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor like C++14's std::less&lt;void&gt; in its absence.  <a href="structllvm_1_1less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1equal.html">llvm::equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor like C++14's std::equal&lt;void&gt; in its absence.  <a href="structllvm_1_1equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1deref.html">llvm::deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary functor that adapts to any other binary functor after dereferencing operands.  <a href="structllvm_1_1deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1result__pair.html">llvm::detail::result_pair&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1enumerator__iter.html">llvm::detail::enumerator_iter&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1enumerator.html">llvm::detail::enumerator&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellvm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents lattice values for constants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html">llvm::detail</a></td></tr>
<tr class="memdesc:namespacellvm_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details of the pass manager interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm_1_1adl__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html">llvm::adl_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab3b502d4bf94f1adf7cfe50e0a2a0283"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:ab3b502d4bf94f1adf7cfe50e0a2a0283"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#ab3b502d4bf94f1adf7cfe50e0a2a0283">llvm::detail::IterOfRange</a> = decltype(std::begin(std::declval&lt; RangeT &amp; &gt;()))</td></tr>
<tr class="separator:ab3b502d4bf94f1adf7cfe50e0a2a0283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d80cc8da3078d256c78a84fda7abaff"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a1d80cc8da3078d256c78a84fda7abaff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a1d80cc8da3078d256c78a84fda7abaff">llvm::detail::ValueOfRange</a> = typename std::remove_reference&lt; decltype(*std::begin(std::declval&lt; RangeT &amp; &gt;()))&gt;::type</td></tr>
<tr class="separator:a1d80cc8da3078d256c78a84fda7abaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f911b322bfcce64d7060236901adbb"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classWrappedIteratorT.html">WrappedIteratorT</a> , typename <a class="el" href="classPredicateT.html">PredicateT</a> &gt; </td></tr>
<tr class="memitem:a96f911b322bfcce64d7060236901adbb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a96f911b322bfcce64d7060236901adbb">llvm::filter_iterator</a> = filter_iterator_impl&lt; <a class="el" href="classWrappedIteratorT.html">WrappedIteratorT</a>, <a class="el" href="classPredicateT.html">PredicateT</a>, typename detail::fwd_or_bidi_tag&lt; <a class="el" href="classWrappedIteratorT.html">WrappedIteratorT</a> &gt;::type &gt;</td></tr>
<tr class="memdesc:a96f911b322bfcce64d7060236901adbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines filter_iterator to a suitable specialization of <a class="el" href="classllvm_1_1filter__iterator__impl.html" title="Specialization of filter_iterator_base for forward iteration only.">filter_iterator_impl</a>, based on the underlying iterator's category.  <a href="namespacellvm.html#a96f911b322bfcce64d7060236901adbb">More...</a><br /></td></tr>
<tr class="separator:a96f911b322bfcce64d7060236901adbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f45f6a833ef7c3f00f4c830c6ae5dd9"><td class="memTemplParams" colspan="2">template&lt;typename ZipType , typename... Iters&gt; </td></tr>
<tr class="memitem:a0f45f6a833ef7c3f00f4c830c6ae5dd9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a0f45f6a833ef7c3f00f4c830c6ae5dd9">llvm::detail::zip_traits</a> = iterator_facade_base&lt; ZipType, typename std::common_type&lt; std::bidirectional_iterator_tag, typename std::iterator_traits&lt; Iters &gt;::iterator_category... &gt;::type, typename ZipTupleType&lt; Iters... &gt;::type, typename std::iterator_traits&lt; typename std::tuple_element&lt; 0, std::tuple&lt; Iters... &gt; &gt;::type &gt;::difference_type, typename ZipTupleType&lt; Iters... &gt;::type *, typename ZipTupleType&lt; Iters... &gt;::type &gt;</td></tr>
<tr class="separator:a0f45f6a833ef7c3f00f4c830c6ae5dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abec1254b449f7339ae316600c8918fe9"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:abec1254b449f7339ae316600c8918fe9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abec1254b449f7339ae316600c8918fe9">llvm::deleter</a> (<a class="el" href="classT.html">T</a> *Ptr)</td></tr>
<tr class="separator:abec1254b449f7339ae316600c8918fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3ccfa559d34145a2b8c114ed924590"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a2b3ccfa559d34145a2b8c114ed924590"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#a2b3ccfa559d34145a2b8c114ed924590">llvm::adl_detail::adl_begin</a> (ContainerTy &amp;&amp;container) -&gt; decltype(begin(std::forward&lt; ContainerTy &gt;(container)))</td></tr>
<tr class="separator:a2b3ccfa559d34145a2b8c114ed924590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ce6854221a27a33d64bdb4de22b19d"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:af4ce6854221a27a33d64bdb4de22b19d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#af4ce6854221a27a33d64bdb4de22b19d">llvm::adl_detail::adl_end</a> (ContainerTy &amp;&amp;container) -&gt; decltype(end(std::forward&lt; ContainerTy &gt;(container)))</td></tr>
<tr class="separator:af4ce6854221a27a33d64bdb4de22b19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36acc760326b76ec4fd78ea77c0d73aa"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a36acc760326b76ec4fd78ea77c0d73aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#a36acc760326b76ec4fd78ea77c0d73aa">llvm::adl_detail::adl_swap</a> (<a class="el" href="classT.html">T</a> &amp;&amp;lhs, <a class="el" href="classT.html">T</a> &amp;&amp;rhs) noexcept(noexcept(swap(std::declval&lt; <a class="el" href="classT.html">T</a> &gt;(), std::declval&lt; <a class="el" href="classT.html">T</a> &gt;())))</td></tr>
<tr class="separator:a36acc760326b76ec4fd78ea77c0d73aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9440bfe7c86e003e3ea40cd5fff6fc"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a3f9440bfe7c86e003e3ea40cd5fff6fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3f9440bfe7c86e003e3ea40cd5fff6fc">llvm::adl_begin</a> (ContainerTy &amp;&amp;container) -&gt; decltype(adl_detail::adl_begin(std::forward&lt; ContainerTy &gt;(container)))</td></tr>
<tr class="separator:a3f9440bfe7c86e003e3ea40cd5fff6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dff56e985dccff3a02585ba6455c90"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a84dff56e985dccff3a02585ba6455c90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a84dff56e985dccff3a02585ba6455c90">llvm::adl_end</a> (ContainerTy &amp;&amp;container) -&gt; decltype(adl_detail::adl_end(std::forward&lt; ContainerTy &gt;(container)))</td></tr>
<tr class="separator:a84dff56e985dccff3a02585ba6455c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87387cf1d55dabf01ef630a5a90c6859"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a87387cf1d55dabf01ef630a5a90c6859"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a87387cf1d55dabf01ef630a5a90c6859">llvm::adl_swap</a> (<a class="el" href="classT.html">T</a> &amp;&amp;lhs, <a class="el" href="classT.html">T</a> &amp;&amp;rhs) noexcept(noexcept(adl_detail::adl_swap(std::declval&lt; <a class="el" href="classT.html">T</a> &gt;(), std::declval&lt; <a class="el" href="classT.html">T</a> &gt;())))</td></tr>
<tr class="separator:a87387cf1d55dabf01ef630a5a90c6859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f3e0d9eb261d9345fcc96b36852f5"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a824f3e0d9eb261d9345fcc96b36852f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a824f3e0d9eb261d9345fcc96b36852f5">llvm::empty</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;RangeOrContainer)</td></tr>
<tr class="memdesc:a824f3e0d9eb261d9345fcc96b36852f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether <code>RangeOrContainer</code> is empty. Similar to C++17 std::empty.  <a href="namespacellvm.html#a824f3e0d9eb261d9345fcc96b36852f5">More...</a><br /></td></tr>
<tr class="separator:a824f3e0d9eb261d9345fcc96b36852f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f31bfe9e8b65522b0be4bdcec96e83"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classItTy.html">ItTy</a> , class FuncTy &gt; </td></tr>
<tr class="memitem:a36f31bfe9e8b65522b0be4bdcec96e83"><td class="memTemplItemLeft" align="right" valign="top">mapped_iterator&lt; <a class="el" href="classItTy.html">ItTy</a>, FuncTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a36f31bfe9e8b65522b0be4bdcec96e83">llvm::map_iterator</a> (<a class="el" href="classItTy.html">ItTy</a> <a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, FuncTy <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="separator:a36f31bfe9e8b65522b0be4bdcec96e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2707c67f87b3689d211a9ec941047d8d"><td class="memTemplParams" colspan="2">template&lt;class ContainerTy , class FuncTy &gt; </td></tr>
<tr class="memitem:a2707c67f87b3689d211a9ec941047d8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2707c67f87b3689d211a9ec941047d8d">llvm::map_range</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, FuncTy <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>) -&gt; decltype(make_range(map_iterator(C.begin(), <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>), map_iterator(C.end(), <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)))</td></tr>
<tr class="separator:a2707c67f87b3689d211a9ec941047d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe8dd7f3dec647e609a356c59dd7e81"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a3fe8dd7f3dec647e609a356c59dd7e81"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3fe8dd7f3dec647e609a356c59dd7e81">llvm::reverse</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, typename std::enable_if&lt; has_rbegin&lt; ContainerTy &gt;::value &gt;::type *=nullptr) -&gt; decltype(make_range(C.rbegin(), C.rend()))</td></tr>
<tr class="separator:a3fe8dd7f3dec647e609a356c59dd7e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85eb4332c3a6c2343040656a4f32df05"><td class="memTemplParams" colspan="2">template&lt;typename IteratorTy &gt; </td></tr>
<tr class="memitem:a85eb4332c3a6c2343040656a4f32df05"><td class="memTemplItemLeft" align="right" valign="top">std::reverse_iterator&lt; IteratorTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a85eb4332c3a6c2343040656a4f32df05">llvm::make_reverse_iterator</a> (IteratorTy It)</td></tr>
<tr class="separator:a85eb4332c3a6c2343040656a4f32df05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ebad1f8a904c8b753c49ba06613426"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a93ebad1f8a904c8b753c49ba06613426"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a93ebad1f8a904c8b753c49ba06613426">llvm::reverse</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, typename std::enable_if&lt;!has_rbegin&lt; ContainerTy &gt;::value &gt;::type *=nullptr) -&gt; decltype(make_range(<a class="el" href="namespacellvm.html#a85eb4332c3a6c2343040656a4f32df05">llvm::make_reverse_iterator</a>(std::end(<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)), <a class="el" href="namespacellvm.html#a85eb4332c3a6c2343040656a4f32df05">llvm::make_reverse_iterator</a>(std::begin(<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>))))</td></tr>
<tr class="separator:a93ebad1f8a904c8b753c49ba06613426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898e9304cf2baf908f4e9b8e32a5f6c3"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename <a class="el" href="classPredicateT.html">PredicateT</a> &gt; </td></tr>
<tr class="memitem:a898e9304cf2baf908f4e9b8e32a5f6c3"><td class="memTemplItemLeft" align="right" valign="top">iterator_range&lt; filter_iterator&lt; detail::IterOfRange&lt; RangeT &gt;, <a class="el" href="classPredicateT.html">PredicateT</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a898e9304cf2baf908f4e9b8e32a5f6c3">llvm::make_filter_range</a> (RangeT &amp;&amp;Range, <a class="el" href="classPredicateT.html">PredicateT</a> Pred)</td></tr>
<tr class="memdesc:a898e9304cf2baf908f4e9b8e32a5f6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that takes a range of elements and a predicate, and return a new filter_iterator range.  <a href="namespacellvm.html#a898e9304cf2baf908f4e9b8e32a5f6c3">More...</a><br /></td></tr>
<tr class="separator:a898e9304cf2baf908f4e9b8e32a5f6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2cdc4a0db233678e7141c9d6ea3419"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a3d2cdc4a0db233678e7141c9d6ea3419"><td class="memTemplItemLeft" align="right" valign="top">iterator_range&lt; early_inc_iterator_impl&lt; detail::IterOfRange&lt; RangeT &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3d2cdc4a0db233678e7141c9d6ea3419">llvm::make_early_inc_range</a> (RangeT &amp;&amp;Range)</td></tr>
<tr class="memdesc:a3d2cdc4a0db233678e7141c9d6ea3419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a range that does early increment to allow mutation of the underlying range without disrupting iteration.  <a href="namespacellvm.html#a3d2cdc4a0db233678e7141c9d6ea3419">More...</a><br /></td></tr>
<tr class="separator:a3d2cdc4a0db233678e7141c9d6ea3419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10fe510ced2849a8074fe81e5d04ce"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a0d10fe510ced2849a8074fe81e5d04ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0d10fe510ced2849a8074fe81e5d04ce">llvm::all_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a0d10fe510ced2849a8074fe81e5d04ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::all_of which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a0d10fe510ced2849a8074fe81e5d04ce">More...</a><br /></td></tr>
<tr class="separator:a0d10fe510ced2849a8074fe81e5d04ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d13d6824ec46c31260a4fd0997eda0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a61d13d6824ec46c31260a4fd0997eda0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a61d13d6824ec46c31260a4fd0997eda0">llvm::any_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a61d13d6824ec46c31260a4fd0997eda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::any_of which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a61d13d6824ec46c31260a4fd0997eda0">More...</a><br /></td></tr>
<tr class="separator:a61d13d6824ec46c31260a4fd0997eda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34f572d891c9b45fbe921e5782c5e30"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classT.html">T</a> , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:aa34f572d891c9b45fbe921e5782c5e30"><td class="memTemplItemLeft" align="right" valign="top">detail::zippy&lt; detail::zip_shortest, <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa34f572d891c9b45fbe921e5782c5e30">llvm::zip</a> (<a class="el" href="classT.html">T</a> &amp;&amp;t, U &amp;&amp;u, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa34f572d891c9b45fbe921e5782c5e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip iterator for two or more iteratable types.  <a href="namespacellvm.html#aa34f572d891c9b45fbe921e5782c5e30">More...</a><br /></td></tr>
<tr class="separator:aa34f572d891c9b45fbe921e5782c5e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b2b4d5c501508bb5b5d4766f0f779e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classT.html">T</a> , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:ae6b2b4d5c501508bb5b5d4766f0f779e"><td class="memTemplItemLeft" align="right" valign="top">detail::zippy&lt; detail::zip_first, <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae6b2b4d5c501508bb5b5d4766f0f779e">llvm::zip_first</a> (<a class="el" href="classT.html">T</a> &amp;&amp;t, U &amp;&amp;u, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae6b2b4d5c501508bb5b5d4766f0f779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip iterator that, for the sake of efficiency, assumes the first iteratee to be the shortest.  <a href="namespacellvm.html#ae6b2b4d5c501508bb5b5d4766f0f779e">More...</a><br /></td></tr>
<tr class="separator:ae6b2b4d5c501508bb5b5d4766f0f779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207b5faa1a77102b536653b9bdc9c91c"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a207b5faa1a77102b536653b9bdc9c91c"><td class="memTemplItemLeft" align="right" valign="top">static Iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a207b5faa1a77102b536653b9bdc9c91c">llvm::detail::next_or_end</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;End)</td></tr>
<tr class="separator:a207b5faa1a77102b536653b9bdc9c91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6439294223e988a19ce7a08eb91e4065"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a6439294223e988a19ce7a08eb91e4065"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a6439294223e988a19ce7a08eb91e4065">llvm::detail::deref_or_none</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;End) -&gt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; typename std::remove_const&lt; typename std::remove_reference&lt; decltype(*<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)&gt;::type &gt;::type &gt;</td></tr>
<tr class="separator:a6439294223e988a19ce7a08eb91e4065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eac485ec0d931c1a0974664b7ca99b0"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classT.html">T</a> , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a0eac485ec0d931c1a0974664b7ca99b0"><td class="memTemplItemLeft" align="right" valign="top">detail::zip_longest_range&lt; <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0eac485ec0d931c1a0974664b7ca99b0">llvm::zip_longest</a> (<a class="el" href="classT.html">T</a> &amp;&amp;t, U &amp;&amp;u, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0eac485ec0d931c1a0974664b7ca99b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over two or more iterators at the same time.  <a href="namespacellvm.html#a0eac485ec0d931c1a0974664b7ca99b0">More...</a><br /></td></tr>
<tr class="separator:a0eac485ec0d931c1a0974664b7ca99b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ece7220c7a97c24dfa6adb4d527225"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classValueT.html">ValueT</a> , typename... RangeTs&gt; </td></tr>
<tr class="memitem:a84ece7220c7a97c24dfa6adb4d527225"><td class="memTemplItemLeft" align="right" valign="top">detail::concat_range&lt; <a class="el" href="classValueT.html">ValueT</a>, RangeTs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a84ece7220c7a97c24dfa6adb4d527225">llvm::concat</a> (RangeTs &amp;&amp;... Ranges)</td></tr>
<tr class="memdesc:a84ece7220c7a97c24dfa6adb4d527225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenated range across two or more ranges.  <a href="namespacellvm.html#a84ece7220c7a97c24dfa6adb4d527225">More...</a><br /></td></tr>
<tr class="separator:a84ece7220c7a97c24dfa6adb4d527225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7510cdb641954d5eca96ba44129a0737"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classT.html">T</a> , std::size_t N&gt; </td></tr>
<tr class="memitem:a7510cdb641954d5eca96ba44129a0737"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsize__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7510cdb641954d5eca96ba44129a0737">llvm::array_lengthof</a> (<a class="el" href="classT.html">T</a>(&amp;)[<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>])</td></tr>
<tr class="memdesc:a7510cdb641954d5eca96ba44129a0737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of an array.  <a href="namespacellvm.html#a7510cdb641954d5eca96ba44129a0737">More...</a><br /></td></tr>
<tr class="separator:a7510cdb641954d5eca96ba44129a0737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a33ebcf9fb4ed8e3831a2cf44500c8894">llvm::array_pod_sort_comparator</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> void *P1, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> void *P2)</td></tr>
<tr class="memdesc:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt std::less&lt;T&gt; for array_pod_sort.  <a href="namespacellvm.html#a33ebcf9fb4ed8e3831a2cf44500c8894">More...</a><br /></td></tr>
<tr class="separator:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1eb5637dd671428b6f138ed3db6428"><td class="memTemplParams" colspan="2">template&lt;class IteratorTy &gt; </td></tr>
<tr class="memitem:add1eb5637dd671428b6f138ed3db6428"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#add1eb5637dd671428b6f138ed3db6428">llvm::array_pod_sort</a> (IteratorTy Start, IteratorTy End)</td></tr>
<tr class="memdesc:add1eb5637dd671428b6f138ed3db6428"><td class="mdescLeft">&#160;</td><td class="mdescRight">array_pod_sort - This sorts an array with the specified start and end extent.  <a href="namespacellvm.html#add1eb5637dd671428b6f138ed3db6428">More...</a><br /></td></tr>
<tr class="separator:add1eb5637dd671428b6f138ed3db6428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5788f17f70ece4dcb34154325ce7126"><td class="memTemplParams" colspan="2">template&lt;class IteratorTy &gt; </td></tr>
<tr class="memitem:ae5788f17f70ece4dcb34154325ce7126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae5788f17f70ece4dcb34154325ce7126">llvm::array_pod_sort</a> (IteratorTy Start, IteratorTy End, int(*Compare)(<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> typename std::iterator_traits&lt; IteratorTy &gt;::value_type *, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> typename std::iterator_traits&lt; IteratorTy &gt;::value_type *))</td></tr>
<tr class="separator:ae5788f17f70ece4dcb34154325ce7126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cdbd1e4f731e7d7cd83461b8b1de0b"><td class="memTemplParams" colspan="2">template&lt;typename IteratorTy &gt; </td></tr>
<tr class="memitem:a74cdbd1e4f731e7d7cd83461b8b1de0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a74cdbd1e4f731e7d7cd83461b8b1de0b">llvm::sort</a> (IteratorTy Start, IteratorTy End)</td></tr>
<tr class="separator:a74cdbd1e4f731e7d7cd83461b8b1de0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af591c14ddf8fa76705d1243a47a3bc57"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:af591c14ddf8fa76705d1243a47a3bc57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af591c14ddf8fa76705d1243a47a3bc57">llvm::sort</a> (Container &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="separator:af591c14ddf8fa76705d1243a47a3bc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memTemplParams" colspan="2">template&lt;typename IteratorTy , typename Compare &gt; </td></tr>
<tr class="memitem:a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a84aac64c34ffe3da7c08eb061d9feb7a">llvm::sort</a> (IteratorTy Start, IteratorTy End, Compare Comp)</td></tr>
<tr class="separator:a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a200e8e1b1e54f27f91fbf8b32d526cda">llvm::sort</a> (Container &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, Compare Comp)</td></tr>
<tr class="separator:a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557372a0f9217d7171352952ce9d75bc"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a557372a0f9217d7171352952ce9d75bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a557372a0f9217d7171352952ce9d75bc">llvm::DeleteContainerPointers</a> (Container &amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="memdesc:a557372a0f9217d7171352952ce9d75bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a container of pointers, deletes the pointers and then clears the container.  <a href="namespacellvm.html#a557372a0f9217d7171352952ce9d75bc">More...</a><br /></td></tr>
<tr class="separator:a557372a0f9217d7171352952ce9d75bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a5dc88796db7b459ff5b8d43fd9c82"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a96a5dc88796db7b459ff5b8d43fd9c82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a96a5dc88796db7b459ff5b8d43fd9c82">llvm::DeleteContainerSeconds</a> (Container &amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="memdesc:a96a5dc88796db7b459ff5b8d43fd9c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">In a container of pairs (usually a map) whose second element is a pointer, deletes the second elements and then clears the container.  <a href="namespacellvm.html#a96a5dc88796db7b459ff5b8d43fd9c82">More...</a><br /></td></tr>
<tr class="separator:a96a5dc88796db7b459ff5b8d43fd9c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66b3b214d7927e7eeeadd6f50e81030"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ab66b3b214d7927e7eeeadd6f50e81030"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ab66b3b214d7927e7eeeadd6f50e81030">llvm::size</a> (R &amp;&amp;Range, typename std::enable_if&lt; std::is_same&lt; typename std::iterator_traits&lt; decltype(Range.begin())&gt;::iterator_category, std::random_access_iterator_tag &gt;::value, void &gt;::type *=nullptr) -&gt; decltype(std::distance(Range.begin(), Range.end()))</td></tr>
<tr class="memdesc:ab66b3b214d7927e7eeeadd6f50e81030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a range.  <a href="namespacellvm.html#ab66b3b214d7927e7eeeadd6f50e81030">More...</a><br /></td></tr>
<tr class="separator:ab66b3b214d7927e7eeeadd6f50e81030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0216d2a2bdaeb9aca5ba5d7bfb6ac40"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ad0216d2a2bdaeb9aca5ba5d7bfb6ac40"><td class="memTemplItemLeft" align="right" valign="top">UnaryPredicate&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad0216d2a2bdaeb9aca5ba5d7bfb6ac40">llvm::for_each</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:ad0216d2a2bdaeb9aca5ba5d7bfb6ac40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::for_each which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#ad0216d2a2bdaeb9aca5ba5d7bfb6ac40">More...</a><br /></td></tr>
<tr class="separator:ad0216d2a2bdaeb9aca5ba5d7bfb6ac40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7dc3069afa2ce5ea62ac2eb183e51c00">llvm::none_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::none_of which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a7dc3069afa2ce5ea62ac2eb183e51c00">More...</a><br /></td></tr>
<tr class="separator:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a55633d4f1b169d533a3a67122d96ff"><td class="memTemplParams" colspan="2">template&lt;typename R , typename <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a4a55633d4f1b169d533a3a67122d96ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4a55633d4f1b169d533a3a67122d96ff">llvm::find</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;Val) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="memdesc:a4a55633d4f1b169d533a3a67122d96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::find which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a4a55633d4f1b169d533a3a67122d96ff">More...</a><br /></td></tr>
<tr class="separator:a4a55633d4f1b169d533a3a67122d96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5bba09e6cf0a670994bdfdfe6ccee6"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a6e5bba09e6cf0a670994bdfdfe6ccee6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a6e5bba09e6cf0a670994bdfdfe6ccee6">llvm::find_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="memdesc:a6e5bba09e6cf0a670994bdfdfe6ccee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::find_if which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a6e5bba09e6cf0a670994bdfdfe6ccee6">More...</a><br /></td></tr>
<tr class="separator:a6e5bba09e6cf0a670994bdfdfe6ccee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3536a97f2cec3662eee8aeaec8992d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:afb3536a97f2cec3662eee8aeaec8992d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#afb3536a97f2cec3662eee8aeaec8992d">llvm::find_if_not</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="separator:afb3536a97f2cec3662eee8aeaec8992d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eced173a909993b89cc0a22e579aeb"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a99eced173a909993b89cc0a22e579aeb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a99eced173a909993b89cc0a22e579aeb">llvm::remove_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="memdesc:a99eced173a909993b89cc0a22e579aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::remove_if which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a99eced173a909993b89cc0a22e579aeb">More...</a><br /></td></tr>
<tr class="separator:a99eced173a909993b89cc0a22e579aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4d13fd05401d8eb0c97b9864a0eb6028">llvm::copy_if</a> (R &amp;&amp;Range, OutputIt Out, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::copy_if which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a4d13fd05401d8eb0c97b9864a0eb6028">More...</a><br /></td></tr>
<tr class="separator:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb650e853db0ddbb60411b885c499737"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt &gt; </td></tr>
<tr class="memitem:abb650e853db0ddbb60411b885c499737"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abb650e853db0ddbb60411b885c499737">llvm::copy</a> (R &amp;&amp;Range, OutputIt Out)</td></tr>
<tr class="separator:abb650e853db0ddbb60411b885c499737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1cd968cb420c82d70926920fcdc7d7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a> &gt; </td></tr>
<tr class="memitem:acd1cd968cb420c82d70926920fcdc7d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#acd1cd968cb420c82d70926920fcdc7d7">llvm::is_contained</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a> &amp;Element)</td></tr>
<tr class="memdesc:acd1cd968cb420c82d70926920fcdc7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::find to detect if an element exists in a container.  <a href="namespacellvm.html#acd1cd968cb420c82d70926920fcdc7d7">More...</a><br /></td></tr>
<tr class="separator:acd1cd968cb420c82d70926920fcdc7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692f657838fbbdedffdcfdac452f1c44"><td class="memTemplParams" colspan="2">template&lt;typename R , typename <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a> &gt; </td></tr>
<tr class="memitem:a692f657838fbbdedffdcfdac452f1c44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a692f657838fbbdedffdcfdac452f1c44">llvm::count</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a> &amp;Element) -&gt; typename std::iterator_traits&lt; decltype(adl_begin(Range))&gt;::difference_type</td></tr>
<tr class="memdesc:a692f657838fbbdedffdcfdac452f1c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::count to count the number of times an element <code>Element</code> occurs in the given range <code>Range</code>.  <a href="namespacellvm.html#a692f657838fbbdedffdcfdac452f1c44">More...</a><br /></td></tr>
<tr class="separator:a692f657838fbbdedffdcfdac452f1c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab604ff0242a7180e0eedcdcf79cecbd9"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ab604ff0242a7180e0eedcdcf79cecbd9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ab604ff0242a7180e0eedcdcf79cecbd9">llvm::count_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>) -&gt; typename std::iterator_traits&lt; decltype(adl_begin(Range))&gt;::difference_type</td></tr>
<tr class="memdesc:ab604ff0242a7180e0eedcdcf79cecbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::count_if to count the number of times an element satisfying a given predicate occurs in a range.  <a href="namespacellvm.html#ab604ff0242a7180e0eedcdcf79cecbd9">More...</a><br /></td></tr>
<tr class="separator:ab604ff0242a7180e0eedcdcf79cecbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9313480c51aa626d0ce527b45471e3"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a0d9313480c51aa626d0ce527b45471e3"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0d9313480c51aa626d0ce527b45471e3">llvm::transform</a> (R &amp;&amp;Range, OutputIt d_first, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a0d9313480c51aa626d0ce527b45471e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::transform to apply a function to a range and store the result elsewhere.  <a href="namespacellvm.html#a0d9313480c51aa626d0ce527b45471e3">More...</a><br /></td></tr>
<tr class="separator:a0d9313480c51aa626d0ce527b45471e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858b7db8e6ca59e6232ec78092bb9d77"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a858b7db8e6ca59e6232ec78092bb9d77"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a858b7db8e6ca59e6232ec78092bb9d77">llvm::partition</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="memdesc:a858b7db8e6ca59e6232ec78092bb9d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::partition which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a858b7db8e6ca59e6232ec78092bb9d77">More...</a><br /></td></tr>
<tr class="separator:a858b7db8e6ca59e6232ec78092bb9d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129b2a239482c3627a10701876672165"><td class="memTemplParams" colspan="2">template&lt;typename R , typename <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a129b2a239482c3627a10701876672165"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a129b2a239482c3627a10701876672165">llvm::lower_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;Value) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="memdesc:a129b2a239482c3627a10701876672165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::lower_bound which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a129b2a239482c3627a10701876672165">More...</a><br /></td></tr>
<tr class="separator:a129b2a239482c3627a10701876672165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d730baa4b06f445aeed9db9b8f24659"><td class="memTemplParams" colspan="2">template&lt;typename R , typename <a class="el" href="classT.html">T</a> , typename Compare &gt; </td></tr>
<tr class="memitem:a4d730baa4b06f445aeed9db9b8f24659"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4d730baa4b06f445aeed9db9b8f24659">llvm::lower_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;Value, Compare <a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="separator:a4d730baa4b06f445aeed9db9b8f24659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67d2e3db9783dbdd426486c8495592"><td class="memTemplParams" colspan="2">template&lt;typename R , typename <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:add67d2e3db9783dbdd426486c8495592"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#add67d2e3db9783dbdd426486c8495592">llvm::upper_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;Value) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="memdesc:add67d2e3db9783dbdd426486c8495592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::upper_bound which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#add67d2e3db9783dbdd426486c8495592">More...</a><br /></td></tr>
<tr class="separator:add67d2e3db9783dbdd426486c8495592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bb9b2a5ffded78c4259ba5a43befef"><td class="memTemplParams" colspan="2">template&lt;typename R , typename <a class="el" href="classT.html">T</a> , typename Compare &gt; </td></tr>
<tr class="memitem:a89bb9b2a5ffded78c4259ba5a43befef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a89bb9b2a5ffded78c4259ba5a43befef">llvm::upper_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;Value, Compare <a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="separator:a89bb9b2a5ffded78c4259ba5a43befef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a076f93c387f454f0db13d4bc7d4e7f9c">llvm::stable_sort</a> (R &amp;&amp;Range)</td></tr>
<tr class="separator:a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe585614b67e0237c8fdbefd475572e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename Compare &gt; </td></tr>
<tr class="memitem:a0fe585614b67e0237c8fdbefd475572e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0fe585614b67e0237c8fdbefd475572e">llvm::stable_sort</a> (R &amp;&amp;Range, Compare <a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="separator:a0fe585614b67e0237c8fdbefd475572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9570253ff331538543b11fef4aba9c0f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename Predicate , typename Val  = decltype(*adl_begin(std::declval&lt;R&gt;()))&gt; </td></tr>
<tr class="memitem:a9570253ff331538543b11fef4aba9c0f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9570253ff331538543b11fef4aba9c0f">llvm::partition_point</a> (R &amp;&amp;Range, Predicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>) -&gt; decltype(adl_begin(Range))</td></tr>
<tr class="memdesc:a9570253ff331538543b11fef4aba9c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search for the first iterator in a range where a predicate is false.  <a href="namespacellvm.html#a9570253ff331538543b11fef4aba9c0f">More...</a><br /></td></tr>
<tr class="separator:a9570253ff331538543b11fef4aba9c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7451464a1e408bf83808f303eae5da4"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aa7451464a1e408bf83808f303eae5da4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa7451464a1e408bf83808f303eae5da4">llvm::is_splat</a> (R &amp;&amp;Range)</td></tr>
<tr class="memdesc:aa7451464a1e408bf83808f303eae5da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::equal to detect if all elements in a container are same.  <a href="namespacellvm.html#aa7451464a1e408bf83808f303eae5da4">More...</a><br /></td></tr>
<tr class="separator:aa7451464a1e408bf83808f303eae5da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f911732e18d72870daa108c6f310f0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classunsigned.html">unsigned</a> Size, typename R &gt; </td></tr>
<tr class="memitem:a66f911732e18d72870daa108c6f310f0"><td class="memTemplItemLeft" align="right" valign="top">SmallVector&lt; typename std::remove_const&lt; detail::ValueOfRange&lt; R &gt; &gt;::type, <a class="el" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a66f911732e18d72870daa108c6f310f0">llvm::to_vector</a> (R &amp;&amp;Range)</td></tr>
<tr class="memdesc:a66f911732e18d72870daa108c6f310f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a range of type R, iterate the entire range and return a <a class="el" href="classllvm_1_1SmallVector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> with elements of the vector.  <a href="namespacellvm.html#a66f911732e18d72870daa108c6f310f0">More...</a><br /></td></tr>
<tr class="separator:a66f911732e18d72870daa108c6f310f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a7de5a04920954ac964059cfc428ad"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac9a7de5a04920954ac964059cfc428ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac9a7de5a04920954ac964059cfc428ad">llvm::erase_if</a> (Container &amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:ac9a7de5a04920954ac964059cfc428ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a container algorithm similar to C++ Library Fundamentals v2's <code>erase_if</code> which is equivalent to:  <a href="namespacellvm.html#ac9a7de5a04920954ac964059cfc428ad">More...</a><br /></td></tr>
<tr class="separator:ac9a7de5a04920954ac964059cfc428ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca964c0c0aee877ecf5c5af8a47982f6"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:aca964c0c0aee877ecf5c5af8a47982f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aca964c0c0aee877ecf5c5af8a47982f6">llvm::replace</a> (Container &amp;Cont, typename Container::iterator ContIt, typename Container::iterator ContEnd, RandomAccessIterator ValIt, RandomAccessIterator ValEnd)</td></tr>
<tr class="memdesc:aca964c0c0aee877ecf5c5af8a47982f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sequence container Cont, replace the range [ContIt, ContEnd) with the range [ValIt, ValEnd) (which is not from the same container).  <a href="namespacellvm.html#aca964c0c0aee877ecf5c5af8a47982f6">More...</a><br /></td></tr>
<tr class="separator:aca964c0c0aee877ecf5c5af8a47982f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Range  = std::initializer_list&lt;                                 typename Container::value_type&gt;&gt; </td></tr>
<tr class="memitem:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#acfc8234929f8be8a1fe8048eaa87a7b9">llvm::replace</a> (Container &amp;Cont, typename Container::iterator ContIt, typename Container::iterator ContEnd, Range R)</td></tr>
<tr class="memdesc:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sequence container Cont, replace the range [ContIt, ContEnd) with the range R.  <a href="namespacellvm.html#acfc8234929f8be8a1fe8048eaa87a7b9">More...</a><br /></td></tr>
<tr class="separator:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc3c8786412caeaa481dc46cae4d23d"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classT.html">T</a> , class... Args&gt; </td></tr>
<tr class="memitem:a1bc3c8786412caeaa481dc46cae4d23d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_array&lt; <a class="el" href="classT.html">T</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="classT.html">T</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a1bc3c8786412caeaa481dc46cae4d23d">llvm::make_unique</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1bc3c8786412caeaa481dc46cae4d23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>new <a class="el" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T()</a></code> with the given args and returns a <code>unique_ptr&lt;T&gt;</code> which owns the object.  <a href="namespacellvm.html#a1bc3c8786412caeaa481dc46cae4d23d">More...</a><br /></td></tr>
<tr class="separator:a1bc3c8786412caeaa481dc46cae4d23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc42e1d86fa0fddc0538a374b4d22c5a"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:abc42e1d86fa0fddc0538a374b4d22c5a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; <a class="el" href="classT.html">T</a> &gt;::value &amp;&amp;std::extent&lt; <a class="el" href="classT.html">T</a> &gt;::value==0, std::unique_ptr&lt; <a class="el" href="classT.html">T</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abc42e1d86fa0fddc0538a374b4d22c5a">llvm::make_unique</a> (<a class="el" href="classsize__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:abc42e1d86fa0fddc0538a374b4d22c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>new T[n]</code> with the given args and returns a <code>unique_ptr&lt;T[]&gt;</code> which owns the object.  <a href="namespacellvm.html#abc42e1d86fa0fddc0538a374b4d22c5a">More...</a><br /></td></tr>
<tr class="separator:abc42e1d86fa0fddc0538a374b4d22c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2796a4596f8bbe7e8a6eb4626063285b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classT.html">T</a> , class... Args&gt; </td></tr>
<tr class="memitem:a2796a4596f8bbe7e8a6eb4626063285b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::extent&lt; <a class="el" href="classT.html">T</a> &gt;::value!=0 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2796a4596f8bbe7e8a6eb4626063285b">llvm::make_unique</a> (Args &amp;&amp;...)=delete</td></tr>
<tr class="memdesc:a2796a4596f8bbe7e8a6eb4626063285b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function isn't used and is only here to provide better compile errors.  <a href="namespacellvm.html#a2796a4596f8bbe7e8a6eb4626063285b">More...</a><br /></td></tr>
<tr class="separator:a2796a4596f8bbe7e8a6eb4626063285b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51a79063c6d9b906682e27ced445f7e"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aa51a79063c6d9b906682e27ced445f7e"><td class="memTemplItemLeft" align="right" valign="top">detail::enumerator&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa51a79063c6d9b906682e27ced445f7e">llvm::enumerate</a> (R &amp;&amp;TheRange)</td></tr>
<tr class="memdesc:aa51a79063c6d9b906682e27ced445f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input range, returns a new range whose values are are pair (A,B) such that A is the 0-based index of the item in the sequence, and B is the value from the original sequence.  <a href="namespacellvm.html#aa51a79063c6d9b906682e27ced445f7e">More...</a><br /></td></tr>
<tr class="separator:aa51a79063c6d9b906682e27ced445f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae70e49212e851eac3917c53ffaa7ee"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> , typename Tuple , std::size_t... I&gt; </td></tr>
<tr class="memitem:a9ae70e49212e851eac3917c53ffaa7ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a9ae70e49212e851eac3917c53ffaa7ee">llvm::detail::apply_tuple_impl</a> (<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> &amp;&amp;f, Tuple &amp;&amp;t, index_sequence&lt; I... &gt;) -&gt; decltype(std::forward&lt; <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> &gt;(f)(std::get&lt; <a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> &gt;(std::forward&lt; Tuple &gt;(t))...))</td></tr>
<tr class="separator:a9ae70e49212e851eac3917c53ffaa7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a69479fbdfc5202adcb17d3f73e402"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> , typename Tuple &gt; </td></tr>
<tr class="memitem:a48a69479fbdfc5202adcb17d3f73e402"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a48a69479fbdfc5202adcb17d3f73e402">llvm::apply_tuple</a> (<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> &amp;&amp;f, Tuple &amp;&amp;t) -&gt; decltype(detail::apply_tuple_impl(std::forward&lt; <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> &gt;(f), std::forward&lt; Tuple &gt;(t), build_index_impl&lt; std::tuple_size&lt; typename std::decay&lt; Tuple &gt;::type &gt;::value &gt;{}))</td></tr>
<tr class="memdesc:a48a69479fbdfc5202adcb17d3f73e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input tuple (a1, a2, ..., an), pass the arguments of the tuple variadically to f as if by calling f(a1, a2, ..., an) and return the result.  <a href="namespacellvm.html#a48a69479fbdfc5202adcb17d3f73e402">More...</a><br /></td></tr>
<tr class="separator:a48a69479fbdfc5202adcb17d3f73e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7952dfeabac21f2e94dd989063f2a865"><td class="memTemplParams" colspan="2">template&lt;typename IterTy &gt; </td></tr>
<tr class="memitem:a7952dfeabac21f2e94dd989063f2a865"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7952dfeabac21f2e94dd989063f2a865">llvm::hasNItems</a> (IterTy &amp;&amp;Begin, IterTy &amp;&amp;End, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, typename std::enable_if&lt; !std::is_same&lt; typename std::iterator_traits&lt; typename std::remove_reference&lt; decltype(Begin)&gt;::type &gt;::iterator_category, std::random_access_iterator_tag &gt;::value, void &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a7952dfeabac21f2e94dd989063f2a865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the sequence [Begin, End) has exactly N items.  <a href="namespacellvm.html#a7952dfeabac21f2e94dd989063f2a865">More...</a><br /></td></tr>
<tr class="separator:a7952dfeabac21f2e94dd989063f2a865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410aa1a734b9ba038e99f7bcfcd77c9f"><td class="memTemplParams" colspan="2">template&lt;typename IterTy &gt; </td></tr>
<tr class="memitem:a410aa1a734b9ba038e99f7bcfcd77c9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a410aa1a734b9ba038e99f7bcfcd77c9f">llvm::hasNItemsOrMore</a> (IterTy &amp;&amp;Begin, IterTy &amp;&amp;End, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, typename std::enable_if&lt; !std::is_same&lt; typename std::iterator_traits&lt; typename std::remove_reference&lt; decltype(Begin)&gt;::type &gt;::iterator_category, std::random_access_iterator_tag &gt;::value, void &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a410aa1a734b9ba038e99f7bcfcd77c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the sequence [Begin, End) has N or more items.  <a href="namespacellvm.html#a410aa1a734b9ba038e99f7bcfcd77c9f">More...</a><br /></td></tr>
<tr class="separator:a410aa1a734b9ba038e99f7bcfcd77c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406679440d7333a283e217bdd1d09833"><td class="memTemplParams" colspan="2">template&lt;class Ptr &gt; </td></tr>
<tr class="memitem:a406679440d7333a283e217bdd1d09833"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a406679440d7333a283e217bdd1d09833">llvm::to_address</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Ptr &amp;<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>) -&gt; decltype(P.operator-&gt;())</td></tr>
<tr class="memdesc:a406679440d7333a283e217bdd1d09833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer that represents the same address as the argument.  <a href="namespacellvm.html#a406679440d7333a283e217bdd1d09833">More...</a><br /></td></tr>
<tr class="separator:a406679440d7333a283e217bdd1d09833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628cf8baacb86dac2bf705c25800f661"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a628cf8baacb86dac2bf705c25800f661"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classT.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a628cf8baacb86dac2bf705c25800f661">llvm::to_address</a> (<a class="el" href="classT.html">T</a> *<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="separator:a628cf8baacb86dac2bf705c25800f661"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a141d266dab226e9a4b9212ec2958419b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a141d266dab226e9a4b9212ec2958419b"><td class="memTemplItemLeft" align="right" valign="top">int(*)(<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> void *, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> void *)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a141d266dab226e9a4b9212ec2958419b">llvm::get_array_pod_sort_comparator</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;)</td></tr>
<tr class="memdesc:a141d266dab226e9a4b9212ec2958419b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_array_pod_sort_comparator - This is an internal helper function used to get type deduction of T right.  <a href="namespacellvm.html#a141d266dab226e9a4b9212ec2958419b">More...</a><br /></td></tr>
<tr class="separator:a141d266dab226e9a4b9212ec2958419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 11:25:05 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
