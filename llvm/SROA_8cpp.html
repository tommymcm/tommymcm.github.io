<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/Scalar/SROA.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_e6e1f1f37d351595fa984b942927b205.html">Scalar</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">SROA.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This transformation implements the well known scalar replacement of aggregates transformation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="SROA_8h_source.html">llvm/Transforms/Scalar/SROA.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="APInt_8h_source.html">llvm/ADT/APInt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ArrayRef_8h_source.html">llvm/ADT/ArrayRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DenseMap_8h_source.html">llvm/ADT/DenseMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PointerIntPair_8h_source.html">llvm/ADT/PointerIntPair.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="STLExtras_8h_source.html">llvm/ADT/STLExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SetVector_8h_source.html">llvm/ADT/SetVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallBitVector_8h_source.html">llvm/ADT/SmallBitVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallPtrSet_8h_source.html">llvm/ADT/SmallPtrSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallVector_8h_source.html">llvm/ADT/SmallVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Statistic_8h_source.html">llvm/ADT/Statistic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StringRef_8h_source.html">llvm/ADT/StringRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Twine_8h_source.html">llvm/ADT/Twine.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator_8h_source.html">llvm/ADT/iterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator__range_8h_source.html">llvm/ADT/iterator_range.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AssumptionCache_8h_source.html">llvm/Analysis/AssumptionCache.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GlobalsModRef_8h_source.html">llvm/Analysis/GlobalsModRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Loads_8h_source.html">llvm/Analysis/Loads.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PtrUseVisitor_8h_source.html">llvm/Analysis/PtrUseVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Transforms_2Utils_2Local_8h_source.html">llvm/Transforms/Utils/Local.h</a>&quot;</code><br />
<code>#include &quot;llvm/Config/llvm-config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="BasicBlock_8h_source.html">llvm/IR/BasicBlock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Constant_8h_source.html">llvm/IR/Constant.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ConstantFolder_8h_source.html">llvm/IR/ConstantFolder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Constants_8h_source.html">llvm/IR/Constants.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DIBuilder_8h_source.html">llvm/IR/DIBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DataLayout_8h_source.html">llvm/IR/DataLayout.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DebugInfoMetadata_8h_source.html">llvm/IR/DebugInfoMetadata.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DerivedTypes_8h_source.html">llvm/IR/DerivedTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominators_8h_source.html">llvm/IR/Dominators.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Function_8h_source.html">llvm/IR/Function.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GetElementPtrTypeIterator_8h_source.html">llvm/IR/GetElementPtrTypeIterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GlobalAlias_8h_source.html">llvm/IR/GlobalAlias.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRBuilder_8h_source.html">llvm/IR/IRBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstVisitor_8h_source.html">llvm/IR/InstVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstrTypes_8h_source.html">llvm/IR/InstrTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2Instruction_8h_source.html">llvm/IR/Instruction.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Instructions_8h_source.html">llvm/IR/Instructions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IntrinsicInst_8h_source.html">llvm/IR/IntrinsicInst.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Intrinsics_8h_source.html">llvm/IR/Intrinsics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVMContext_8h_source.html">llvm/IR/LLVMContext.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Metadata_8h_source.html">llvm/IR/Metadata.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Module_8h_source.html">llvm/IR/Module.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Operator_8h_source.html">llvm/IR/Operator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PassManager_8h_source.html">llvm/IR/PassManager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Type_8h_source.html">llvm/IR/Type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Use_8h_source.html">llvm/IR/Use.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="User_8h_source.html">llvm/IR/User.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Value_8h_source.html">llvm/IR/Value.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Pass_8h_source.html">llvm/Pass.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Casting_8h_source.html">llvm/Support/Casting.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="CommandLine_8h_source.html">llvm/Support/CommandLine.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Compiler_8h_source.html">llvm/Support/Compiler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Debug_8h_source.html">llvm/Support/Debug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html">llvm/Support/ErrorHandling.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MathExtras_8h_source.html">llvm/Support/MathExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="raw__ostream_8h_source.html">llvm/Support/raw_ostream.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="llvm_2Transforms_2Scalar_8h_source.html">llvm/Transforms/Scalar.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PromoteMemToReg_8h_source.html">llvm/Transforms/Utils/PromoteMemToReg.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
</div>
<p><a href="SROA_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1sroa_1_1AllocaSlices.html">llvm::sroa::AllocaSlices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of the alloca slices.  <a href="classllvm_1_1sroa_1_1AllocaSlices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1sroa_1_1Partition.html">llvm::sroa::Partition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partition of the slices.  <a href="classllvm_1_1sroa_1_1Partition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAllocaSlices_1_1partition__iterator.html">AllocaSlices::partition_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over partitions of the alloca's slices.  <a href="classAllocaSlices_1_1partition__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAllocaSlices_1_1SliceBuilder.html">AllocaSlices::SliceBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder for the alloca slices.  <a href="classAllocaSlices_1_1SliceBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1sroa_1_1AllocaSliceRewriter.html">llvm::sroa::AllocaSliceRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to rewrite instructions using p particular slice of an alloca to use a new alloca.  <a href="classllvm_1_1sroa_1_1AllocaSliceRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1sroa_1_1SROALegacyPass.html">llvm::sroa::SROALegacyPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A legacy pass for the legacy pass manager that wraps the <code><a class="el" href="classllvm_1_1SROA.html" title="An optimization pass providing Scalar Replacement of Aggregates.">SROA</a></code> pass.  <a href="classllvm_1_1sroa_1_1SROALegacyPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;sroa&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a618041bb2c6e95361ead0e45493039ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a618041bb2c6e95361ead0e45493039ef">STATISTIC</a> (NumAllocasAnalyzed, &quot;Number of allocas analyzed <a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#ab425c63346dc1b312c1f40f408d098c3">for</a> replacement&quot;)</td></tr>
<tr class="separator:a618041bb2c6e95361ead0e45493039ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e323f27ddb83247b75a5b2d375d9216"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a4e323f27ddb83247b75a5b2d375d9216">STATISTIC</a> (NumAllocaPartitions, &quot;Number of alloca partitions formed&quot;)</td></tr>
<tr class="separator:a4e323f27ddb83247b75a5b2d375d9216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0cc1a6f5d1eb652844d9752b238390"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ace0cc1a6f5d1eb652844d9752b238390">STATISTIC</a> (MaxPartitionsPerAlloca, &quot;Maximum number of partitions per alloca&quot;)</td></tr>
<tr class="separator:ace0cc1a6f5d1eb652844d9752b238390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8043ffc0bf25bc77b88596ec2555d25f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a8043ffc0bf25bc77b88596ec2555d25f">STATISTIC</a> (NumAllocaPartitionUses, &quot;Number of alloca partition <a class="el" href="DeadArgumentElimination_8cpp.html#aba008984447815eaf051160d45db9d18">uses</a> rewritten&quot;)</td></tr>
<tr class="separator:a8043ffc0bf25bc77b88596ec2555d25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96dad8afe38ad77a313ecac3d1f151a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ab96dad8afe38ad77a313ecac3d1f151a">STATISTIC</a> (MaxUsesPerAllocaPartition, &quot;Maximum number of <a class="el" href="DeadArgumentElimination_8cpp.html#aba008984447815eaf051160d45db9d18">uses</a> of a partition&quot;)</td></tr>
<tr class="separator:ab96dad8afe38ad77a313ecac3d1f151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd84289002379062d3d99430eb946df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#adcd84289002379062d3d99430eb946df">STATISTIC</a> (NumNewAllocas, &quot;Number of new, smaller allocas introduced&quot;)</td></tr>
<tr class="separator:adcd84289002379062d3d99430eb946df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53eb32a458943eee0e59c868868419"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#afd53eb32a458943eee0e59c868868419">STATISTIC</a> (NumPromoted, &quot;Number of allocas promoted to <a class="el" href="MemorySSA_8cpp.html#a20a60bdac22b099d87d8cb0c1d554120">SSA</a> values&quot;)</td></tr>
<tr class="separator:afd53eb32a458943eee0e59c868868419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f1e2ef32da6004704b9dfd4d80482e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ae1f1e2ef32da6004704b9dfd4d80482e">STATISTIC</a> (NumLoadsSpeculated, &quot;Number of loads speculated to allow promotion&quot;)</td></tr>
<tr class="separator:ae1f1e2ef32da6004704b9dfd4d80482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af559aec98fbf691ccd4c3233556cc618"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#af559aec98fbf691ccd4c3233556cc618">STATISTIC</a> (NumDeleted, &quot;Number of <a class="el" href="InstructionSelect_8cpp.html#a474a9c43838a295e112a1f8864e03813">instructions</a> deleted&quot;)</td></tr>
<tr class="separator:af559aec98fbf691ccd4c3233556cc618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f794c154e83c0c1f7953596198faa8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a3f794c154e83c0c1f7953596198faa8f">STATISTIC</a> (NumVectorized, &quot;Number of vectorized aggregates&quot;)</td></tr>
<tr class="separator:a3f794c154e83c0c1f7953596198faa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc7e359a229f391d15a7a84a31e096a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a6fc7e359a229f391d15a7a84a31e096a">foldSelectInst</a> (<a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;<a class="el" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a>)</td></tr>
<tr class="separator:a6fc7e359a229f391d15a7a84a31e096a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ada829b4d3487b24df63322b26bfca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a62ada829b4d3487b24df63322b26bfca">foldPHINodeOrSelectInst</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:a62ada829b4d3487b24df63322b26bfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper that folds a PHI node or a select.  <a href="SROA_8cpp.html#a62ada829b4d3487b24df63322b26bfca">More...</a><br /></td></tr>
<tr class="separator:a62ada829b4d3487b24df63322b26bfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5461178ba8c51f9688cf7d7ede55f97c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a5461178ba8c51f9688cf7d7ede55f97c">findCommonType</a> (AllocaSlices::const_iterator <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, AllocaSlices::const_iterator <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, uint64_t EndOffset)</td></tr>
<tr class="memdesc:a5461178ba8c51f9688cf7d7ede55f97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the range of a partitioning looking for a common type to cover this sequence of slices.  <a href="SROA_8cpp.html#a5461178ba8c51f9688cf7d7ede55f97c">More...</a><br /></td></tr>
<tr class="separator:a5461178ba8c51f9688cf7d7ede55f97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab37469c4748a495736ad163ac54e776"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#aab37469c4748a495736ad163ac54e776">isSafePHIToSpeculate</a> (<a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN)</td></tr>
<tr class="memdesc:aab37469c4748a495736ad163ac54e776"><td class="mdescLeft">&#160;</td><td class="mdescRight">PHI instructions that use an alloca and are subsequently loaded can be rewritten to load both input pointers in the pred blocks and then PHI the results, allowing the load of the alloca to be promoted.  <a href="SROA_8cpp.html#aab37469c4748a495736ad163ac54e776">More...</a><br /></td></tr>
<tr class="separator:aab37469c4748a495736ad163ac54e776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab38ec9ebc3b5d96a4b7ddcb11cfcd58"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#aab38ec9ebc3b5d96a4b7ddcb11cfcd58">speculatePHINodeLoads</a> (<a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN)</td></tr>
<tr class="separator:aab38ec9ebc3b5d96a4b7ddcb11cfcd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e373cfa6ef51df8f9c43dc8b8539c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a93e373cfa6ef51df8f9c43dc8b8539c0">isSafeSelectToSpeculate</a> (<a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;<a class="el" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a>)</td></tr>
<tr class="memdesc:a93e373cfa6ef51df8f9c43dc8b8539c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select instructions that use an alloca and are subsequently loaded can be rewritten to load both input pointers and then select between the result, allowing the load of the alloca to be promoted.  <a href="SROA_8cpp.html#a93e373cfa6ef51df8f9c43dc8b8539c0">More...</a><br /></td></tr>
<tr class="separator:a93e373cfa6ef51df8f9c43dc8b8539c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493b7d3b84612687869f2c3afed924b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a7493b7d3b84612687869f2c3afed924b">speculateSelectInstLoads</a> (<a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;<a class="el" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a>)</td></tr>
<tr class="separator:a7493b7d3b84612687869f2c3afed924b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8d1be188ac612882f052986419c826"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a2a8d1be188ac612882f052986419c826">buildGEP</a> (IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *BasePtr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Indices, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:a2a8d1be188ac612882f052986419c826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a GEP out of a base pointer and indices.  <a href="SROA_8cpp.html#a2a8d1be188ac612882f052986419c826">More...</a><br /></td></tr>
<tr class="separator:a2a8d1be188ac612882f052986419c826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4766fb3ad3333845a711a4762ac1dd46"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a4766fb3ad3333845a711a4762ac1dd46">getNaturalGEPWithType</a> (IRBuilderTy &amp;IRB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Value.html">Value</a> *BasePtr, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1Type.html">Type</a> *TargetTy, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Indices, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:a4766fb3ad3333845a711a4762ac1dd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a natural GEP off of the BasePtr walking through Ty toward TargetTy without changing the offset of the pointer.  <a href="SROA_8cpp.html#a4766fb3ad3333845a711a4762ac1dd46">More...</a><br /></td></tr>
<tr class="separator:a4766fb3ad3333845a711a4762ac1dd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f7a8fb8ddcb36874da289ce7c7e5f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ac2f7a8fb8ddcb36874da289ce7c7e5f4">getNaturalGEPRecursively</a> (IRBuilderTy &amp;IRB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Offset, <a class="el" href="classllvm_1_1Type.html">Type</a> *TargetTy, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Indices, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:ac2f7a8fb8ddcb36874da289ce7c7e5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively compute indices for a natural GEP.  <a href="SROA_8cpp.html#ac2f7a8fb8ddcb36874da289ce7c7e5f4">More...</a><br /></td></tr>
<tr class="separator:ac2f7a8fb8ddcb36874da289ce7c7e5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8875f65a602c5d80e21caa41db6364"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a4f8875f65a602c5d80e21caa41db6364">getNaturalGEPWithOffset</a> (IRBuilderTy &amp;IRB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classllvm_1_1APInt.html">APInt</a> Offset, <a class="el" href="classllvm_1_1Type.html">Type</a> *TargetTy, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Indices, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:a4f8875f65a602c5d80e21caa41db6364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a natural GEP from a base pointer to a particular offset and resulting in a particular type.  <a href="SROA_8cpp.html#a4f8875f65a602c5d80e21caa41db6364">More...</a><br /></td></tr>
<tr class="separator:a4f8875f65a602c5d80e21caa41db6364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22530ae9883898c5e328ef6fd62412f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ae22530ae9883898c5e328ef6fd62412f">getAdjustedPtr</a> (IRBuilderTy &amp;IRB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classllvm_1_1APInt.html">APInt</a> Offset, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="namespacellvm.html#a2d5a7634b0ed15979c2cd15c62d6d4b5">PointerTy</a>, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:ae22530ae9883898c5e328ef6fd62412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an adjusted pointer from Ptr by Offset bytes where the resulting pointer has PointerTy.  <a href="SROA_8cpp.html#ae22530ae9883898c5e328ef6fd62412f">More...</a><br /></td></tr>
<tr class="separator:ae22530ae9883898c5e328ef6fd62412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b165b20a6c5576515615c1b05e6917"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a73b165b20a6c5576515615c1b05e6917">getAdjustedAlignment</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, uint64_t Offset, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:a73b165b20a6c5576515615c1b05e6917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the adjusted alignment for a load or store from an offset.  <a href="SROA_8cpp.html#a73b165b20a6c5576515615c1b05e6917">More...</a><br /></td></tr>
<tr class="separator:a73b165b20a6c5576515615c1b05e6917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb1c078833c17e4c9529b0cf924385c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Type.html">Type</a> *OldTy, <a class="el" href="classllvm_1_1Type.html">Type</a> *NewTy)</td></tr>
<tr class="memdesc:a2fb1c078833c17e4c9529b0cf924385c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether we can convert a value from the old to the new type.  <a href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">More...</a><br /></td></tr>
<tr class="separator:a2fb1c078833c17e4c9529b0cf924385c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af169f594f2c9e8cd49a59b29373eb4de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#af169f594f2c9e8cd49a59b29373eb4de">convertValue</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1Type.html">Type</a> *NewTy)</td></tr>
<tr class="memdesc:af169f594f2c9e8cd49a59b29373eb4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic routine to convert an SSA value to a value of a different type.  <a href="SROA_8cpp.html#af169f594f2c9e8cd49a59b29373eb4de">More...</a><br /></td></tr>
<tr class="separator:af169f594f2c9e8cd49a59b29373eb4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c31035e44c7bda618eb2eb81dcf314"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ab4c31035e44c7bda618eb2eb81dcf314">isVectorPromotionViableForSlice</a> (<a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Slice &amp;S, <a class="el" href="classVectorType.html">VectorType</a> *Ty, uint64_t ElementSize, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:ab4c31035e44c7bda618eb2eb81dcf314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given slice use can be promoted to a vector.  <a href="SROA_8cpp.html#ab4c31035e44c7bda618eb2eb81dcf314">More...</a><br /></td></tr>
<tr class="separator:ab4c31035e44c7bda618eb2eb81dcf314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6735614e085435a0f3bb90aab527213"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVectorType.html">VectorType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#af6735614e085435a0f3bb90aab527213">isVectorPromotionViable</a> (<a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:af6735614e085435a0f3bb90aab527213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given alloca partitioning and range of slices can be promoted to a vector.  <a href="SROA_8cpp.html#af6735614e085435a0f3bb90aab527213">More...</a><br /></td></tr>
<tr class="separator:af6735614e085435a0f3bb90aab527213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593afa69fb7cfbb4506f605bd785f923"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a593afa69fb7cfbb4506f605bd785f923">isIntegerWideningViableForSlice</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Slice &amp;S, uint64_t AllocBeginOffset, <a class="el" href="classllvm_1_1Type.html">Type</a> *AllocaTy, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classbool.html">bool</a> &amp;WholeAllocaOp)</td></tr>
<tr class="memdesc:a593afa69fb7cfbb4506f605bd785f923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a slice of an alloca is valid for integer widening.  <a href="SROA_8cpp.html#a593afa69fb7cfbb4506f605bd785f923">More...</a><br /></td></tr>
<tr class="separator:a593afa69fb7cfbb4506f605bd785f923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9ee96f281dd94ed4119c2e45836bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a7fd9ee96f281dd94ed4119c2e45836bf">isIntegerWideningViable</a> (<a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *AllocaTy, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:a7fd9ee96f281dd94ed4119c2e45836bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given alloca partition's integer operations can be widened to promotable ones.  <a href="SROA_8cpp.html#a7fd9ee96f281dd94ed4119c2e45836bf">More...</a><br /></td></tr>
<tr class="separator:a7fd9ee96f281dd94ed4119c2e45836bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f67bb5d465e282bbb175c9c278f251"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ab2f67bb5d465e282bbb175c9c278f251">extractInteger</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1IntegerType.html">IntegerType</a> *Ty, uint64_t Offset, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#ac19c5d82adec186ac56e94115530daa8">Name</a>)</td></tr>
<tr class="separator:ab2f67bb5d465e282bbb175c9c278f251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cad1dcbccfcc610dc8d47100b4871ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a4cad1dcbccfcc610dc8d47100b4871ef">insertInteger</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *Old, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, uint64_t Offset, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#ac19c5d82adec186ac56e94115530daa8">Name</a>)</td></tr>
<tr class="separator:a4cad1dcbccfcc610dc8d47100b4871ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604f6e897606d25237935a3374fe7a3e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a604f6e897606d25237935a3374fe7a3e">extractVector</a> (IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> BeginIndex, <a class="el" href="classunsigned.html">unsigned</a> EndIndex, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#ac19c5d82adec186ac56e94115530daa8">Name</a>)</td></tr>
<tr class="separator:a604f6e897606d25237935a3374fe7a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf62ffe10261611bab4d74598ab0e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a75cf62ffe10261611bab4d74598ab0e4">insertVector</a> (IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *Old, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> BeginIndex, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#ac19c5d82adec186ac56e94115530daa8">Name</a>)</td></tr>
<tr class="separator:a75cf62ffe10261611bab4d74598ab0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29482246d1f1d9699e0a4786aafad1de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a29482246d1f1d9699e0a4786aafad1de">stripAggregateTypeWrapping</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty)</td></tr>
<tr class="memdesc:a29482246d1f1d9699e0a4786aafad1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip aggregate type wrapping.  <a href="SROA_8cpp.html#a29482246d1f1d9699e0a4786aafad1de">More...</a><br /></td></tr>
<tr class="separator:a29482246d1f1d9699e0a4786aafad1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad866ad1da941867a398da262103469b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ad866ad1da941867a398da262103469b1">getTypePartition</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, uint64_t Offset, uint64_t <a class="el" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a>)</td></tr>
<tr class="memdesc:ad866ad1da941867a398da262103469b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a partition of the aggregate type passed in for a given offset and size.  <a href="SROA_8cpp.html#ad866ad1da941867a398da262103469b1">More...</a><br /></td></tr>
<tr class="separator:ad866ad1da941867a398da262103469b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786d5a99befacdb30b3d3b5c3b07bd30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a786d5a99befacdb30b3d3b5c3b07bd30">INITIALIZE_PASS_BEGIN</a> (<a class="el" href="classllvm_1_1sroa_1_1SROALegacyPass.html">SROALegacyPass</a>, &quot;sroa&quot;, &quot;Scalar Replacement Of Aggregates&quot;, false, false) <a class="el" href="PassSupport_8h.html#a74ce8276b89067e806f67c45a6d92575">INITIALIZE_PASS_END</a>(<a class="el" href="classllvm_1_1sroa_1_1SROALegacyPass.html">SROALegacyPass</a></td></tr>
<tr class="separator:a786d5a99befacdb30b3d3b5c3b07bd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7d421e9e5928497126c6ba95660ca17a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a7d421e9e5928497126c6ba95660ca17a">SROARandomShuffleSlices</a> (&quot;sroa-random-shuffle-slices&quot;, cl::init(false), cl::Hidden)</td></tr>
<tr class="memdesc:a7d421e9e5928497126c6ba95660ca17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hidden option to enable randomly shuffling the slices to help uncover instability in their order.  <a href="SROA_8cpp.html#a7d421e9e5928497126c6ba95660ca17a">More...</a><br /></td></tr>
<tr class="separator:a7d421e9e5928497126c6ba95660ca17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a5e59fb7c2bf5faa2870aa694d3b41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ad4a5e59fb7c2bf5faa2870aa694d3b41">SROAStrictInbounds</a> (&quot;sroa-strict-inbounds&quot;, cl::init(false), cl::Hidden)</td></tr>
<tr class="memdesc:ad4a5e59fb7c2bf5faa2870aa694d3b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hidden option to experiment with completely strict handling of inbounds GEPs.  <a href="SROA_8cpp.html#ad4a5e59fb7c2bf5faa2870aa694d3b41">More...</a><br /></td></tr>
<tr class="separator:ad4a5e59fb7c2bf5faa2870aa694d3b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6990f15b9f29df6e8497b3e53875ccab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a6990f15b9f29df6e8497b3e53875ccab">sroa</a></td></tr>
<tr class="separator:a6990f15b9f29df6e8497b3e53875ccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3f8e5f6c512fe6a5059dd0c51aec95"><td class="memItemLeft" align="right" valign="top">Scalar Replacement Of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a5b3f8e5f6c512fe6a5059dd0c51aec95">Aggregates</a></td></tr>
<tr class="separator:a5b3f8e5f6c512fe6a5059dd0c51aec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7a95cb9fb444faf77cd626f1b8128b"><td class="memItemLeft" align="right" valign="top">Scalar Replacement Of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#acc7a95cb9fb444faf77cd626f1b8128b">false</a></td></tr>
<tr class="separator:acc7a95cb9fb444faf77cd626f1b8128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This transformation implements the well known scalar replacement of aggregates transformation. </p>
<p >It tries to identify promotable elements of an aggregate alloca, and promote them to registers. It will also try to convert uses of an element (or set of elements) of an alloca into a vector or bitfield-style integer scalar if appropriate.</p>
<p >It works to do this with minimal slicing of the alloca so that regions which are merely transferred in and out of external memory remain unchanged and are not decomposed to scalar code.</p>
<p >Because this also performs alloca promotion, it can be thought of as also serving the purpose of SSA formation. The algorithm iterates on the function until all opportunities for promotion have been realized. </p>

<p class="definition">Definition in file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;sroa&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l00104">104</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2a8d1be188ac612882f052986419c826" name="a2a8d1be188ac612882f052986419c826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8d1be188ac612882f052986419c826">&#9670;&nbsp;</a></span>buildGEP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * buildGEP </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>BasePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a GEP out of a base pointer and indices. </p>
<p >This will return the BasePtr if that is valid, or build a new GEP instruction using the IRBuilder if GEP-ing is needed. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01395">1395</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00166">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::back()</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, and <a class="el" href="SmallVector_8h_source.html#l00052">llvm::SmallVectorBase::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Operations_8cpp_source.html#l00170">llvm::fuzzerop::gepDescriptor()</a>, and <a class="el" href="SROA_8cpp_source.html#l01418">getNaturalGEPWithType()</a>.</p>

</div>
</div>
<a id="a2fb1c078833c17e4c9529b0cf924385c" name="a2fb1c078833c17e4c9529b0cf924385c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb1c078833c17e4c9529b0cf924385c">&#9670;&nbsp;</a></span>canConvertValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> canConvertValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>OldTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>NewTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether we can convert a value from the old to the new type. </p>
<p >This predicate should be used to guard calls to convertValue in order to ensure that we only try to convert viable values. The strategy is that we will peel off single element struct and array wrappings to get to an underlying value, and convert that value. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01707">1707</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l00087">getBitWidth()</a>, <a class="el" href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">llvm::Type::getPointerAddressSpace()</a>, <a class="el" href="Type_8h_source.html#l00303">llvm::Type::getScalarType()</a>, <a class="el" href="DataLayout_8h_source.html#l00601">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="Type_8h_source.html#l00196">llvm::Type::isIntegerTy()</a>, <a class="el" href="DataLayout_8h_source.html#l00376">llvm::DataLayout::isNonIntegralPointerType()</a>, <a class="el" href="Type_8h_source.html#l00223">llvm::Type::isPointerTy()</a>, and <a class="el" href="Type_8h_source.html#l00249">llvm::Type::isSingleValueType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01758">convertValue()</a>, <a class="el" href="SROA_8cpp_source.html#l02086">isIntegerWideningViable()</a>, <a class="el" href="SROA_8cpp_source.html#l01999">isIntegerWideningViableForSlice()</a>, and <a class="el" href="SROA_8cpp_source.html#l01808">isVectorPromotionViableForSlice()</a>.</p>

</div>
</div>
<a id="af169f594f2c9e8cd49a59b29373eb4de" name="af169f594f2c9e8cd49a59b29373eb4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af169f594f2c9e8cd49a59b29373eb4de">&#9670;&nbsp;</a></span>convertValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * convertValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>NewTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic routine to convert an SSA value to a value of a different type. </p>
<p >This will try various different casting techniques, such as bitcasts, inttoptr, and ptrtoint casts. Use the <code>canConvertValue</code> predicate to test two types for viability with this routine. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01758">1758</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SROA_8cpp_source.html#l01707">canConvertValue()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00766">llvm::DataLayout::getIntPtrType()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="Type_8h_source.html#l00202">llvm::Type::isIntOrIntVectorTy()</a>, <a class="el" href="Type_8h_source.html#l00226">llvm::Type::isPtrOrPtrVectorTy()</a>, and <a class="el" href="Type_8h_source.html#l00229">llvm::Type::isVectorTy()</a>.</p>

</div>
</div>
<a id="ab2f67bb5d465e282bbb175c9c278f251" name="ab2f67bb5d465e282bbb175c9c278f251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f67bb5d465e282bbb175c9c278f251">&#9670;&nbsp;</a></span>extractInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * extractInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntegerType.html">IntegerType</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02128">2128</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00066">llvm::IntegerType::getBitWidth()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00444">llvm::DataLayout::getTypeStoreSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00233">llvm::DataLayout::isBigEndian()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, and <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00231">Name</a>.</p>

</div>
</div>
<a id="a604f6e897606d25237935a3374fe7a3e" name="a604f6e897606d25237935a3374fe7a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604f6e897606d25237935a3374fe7a3e">&#9670;&nbsp;</a></span>extractVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * extractVector </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>BeginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>EndIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02182">2182</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="IntervalMap_8h_source.html#l00526">llvm::IntervalMapImpl::NodeRef::get()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, and <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00231">Name</a>.</p>

</div>
</div>
<a id="a5461178ba8c51f9688cf7d7ede55f97c" name="a5461178ba8c51f9688cf7d7ede55f97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5461178ba8c51f9688cf7d7ede55f97c">&#9670;&nbsp;</a></span>findCommonType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Type.html">Type</a> * findCommonType </td>
          <td>(</td>
          <td class="paramtype">AllocaSlices::const_iterator&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocaSlices::const_iterator&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>EndOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk the range of a partitioning looking for a common type to cover this sequence of slices. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01125">1125</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="DerivedTypes_8h_source.html#l00066">llvm::IntegerType::getBitWidth()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="SIInstrInfo_8cpp_source.html#l06142">SI</a>.</p>

</div>
</div>
<a id="a62ada829b4d3487b24df63322b26bfca" name="a62ada829b4d3487b24df63322b26bfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ada829b4d3487b24df63322b26bfca">&#9670;&nbsp;</a></span>foldPHINodeOrSelectInst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldPHINodeOrSelectInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper that folds a PHI node or a select. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l00635">635</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l00622">foldSelectInst()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="a6fc7e359a229f391d15a7a84a31e096a" name="a6fc7e359a229f391d15a7a84a31e096a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc7e359a229f391d15a7a84a31e096a">&#9670;&nbsp;</a></span>foldSelectInst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldSelectInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;&#160;</td>
          <td class="paramname"><em>SI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l00622">622</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SIInstrInfo_8cpp_source.html#l06142">SI</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00635">foldPHINodeOrSelectInst()</a>.</p>

</div>
</div>
<a id="a73b165b20a6c5576515615c1b05e6917" name="a73b165b20a6c5576515615c1b05e6917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b165b20a6c5576515615c1b05e6917">&#9670;&nbsp;</a></span>getAdjustedAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> getAdjustedAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the adjusted alignment for a load or store from an offset. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01681">1681</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayout_8cpp_source.html#l00746">llvm::DataLayout::getABITypeAlignment()</a>, <a class="el" href="Instructions_8h_source.html#l00240">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00135">llvm_unreachable</a>, <a class="el" href="MathExtras_8h_source.html#l00614">llvm::MinAlign()</a>, and <a class="el" href="SIInstrInfo_8cpp_source.html#l06142">SI</a>.</p>

</div>
</div>
<a id="ae22530ae9883898c5e328ef6fd62412f" name="ae22530ae9883898c5e328ef6fd62412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22530ae9883898c5e328ef6fd62412f">&#9670;&nbsp;</a></span>getAdjustedPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * getAdjustedPtr </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a>&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>PointerTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an adjusted pointer from Ptr by Offset bytes where the resulting pointer has PointerTy. </p>
<p >This tries very hard to compute a "natural" GEP which arrives at the offset and produces the pointer type desired. Where it cannot, it will try to use the natural GEP to arrive at the offset and bitcast to the type. Where that fails, it will try to use an existing i8* and GEP to the byte offset and bitcast to the type.</p>
<p >The strategy for finding the more natural GEPs is to peel off layers of the pointer, walking back through bit casts and GEPs, searching for a base pointer from which we can compute a natural GEP with the desired properties. The algorithm tries to fold as many constant indices into a single GEP as possible, thus making each GEP more independent of the surrounding code. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01576">1576</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00339">llvm::SmallVectorImpl&lt; T &gt;::clear()</a>, <a class="el" href="HexagonCommonGEP_8cpp_source.html#l00170">GEP</a>, <a class="el" href="SROA_8cpp_source.html#l01536">getNaturalGEPWithOffset()</a>, <a class="el" href="Operator_8h_source.html#l00040">llvm::Operator::getOpcode()</a>, <a class="el" href="classllvm_1_1Type.html#a2821cb7434bee7b1ab850758f9a57bb4">llvm::Type::getPointerTo()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="SmallPtrSet_8h_source.html#l00370">llvm::SmallPtrSetImpl&lt; PtrType &gt;::insert()</a>, <a class="el" href="Type_8h_source.html#l00196">llvm::Type::isIntegerTy()</a>, <a class="el" href="Type_8h_source.html#l00223">llvm::Type::isPointerTy()</a>, and <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

</div>
</div>
<a id="ac2f7a8fb8ddcb36874da289ce7c7e5f4" name="ac2f7a8fb8ddcb36874da289ce7c7e5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f7a8fb8ddcb36874da289ce7c7e5f4">&#9670;&nbsp;</a></span>getNaturalGEPRecursively()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * getNaturalGEPRecursively </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>TargetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively compute indices for a natural GEP. </p>
<p >This is the recursive step for getNaturalGEPWithOffset that walks down the element types adding appropriate indices for the GEP. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01462">1462</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayout_8cpp_source.html#l00083">llvm::StructLayout::getElementContainingOffset()</a>, <a class="el" href="DataLayout_8h_source.html#l00584">llvm::StructLayout::getElementOffset()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00346">llvm::StructType::getElementType()</a>, <a class="el" href="SROA_8cpp_source.html#l01462">getNaturalGEPRecursively()</a>, <a class="el" href="SROA_8cpp_source.html#l01418">getNaturalGEPWithType()</a>, <a class="el" href="DataLayout_8h_source.html#l00570">llvm::StructLayout::getSizeInBytes()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00604">llvm::DataLayout::getStructLayout()</a>, <a class="el" href="DataLayout_8h_source.html#l00469">llvm::DataLayout::getTypeAllocSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00601">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="Type_8h_source.html#l00223">llvm::Type::isPointerTy()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, and <a class="el" href="APInt_8h_source.html#l01254">llvm::APInt::ugt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01462">getNaturalGEPRecursively()</a>, and <a class="el" href="SROA_8cpp_source.html#l01536">getNaturalGEPWithOffset()</a>.</p>

</div>
</div>
<a id="a4f8875f65a602c5d80e21caa41db6364" name="a4f8875f65a602c5d80e21caa41db6364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8875f65a602c5d80e21caa41db6364">&#9670;&nbsp;</a></span>getNaturalGEPWithOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * getNaturalGEPWithOffset </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a>&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>TargetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a natural GEP from a base pointer to a particular offset and resulting in a particular type. </p>
<p >The goal is to produce a "natural" looking GEP that works with the existing composite types to arrive at the appropriate offset and element type for a pointer. TargetTy is the element type the returned GEP should point-to if possible. We recurse by decreasing Offset, adding the appropriate index to Indices, and setting Ty to the result subtype.</p>
<p >If no natural GEP can be constructed, this function returns null. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01536">1536</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l01462">getNaturalGEPRecursively()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00469">llvm::DataLayout::getTypeAllocSize()</a>, <a class="el" href="Type_8h_source.html#l00196">llvm::Type::isIntegerTy()</a>, <a class="el" href="Type_8h_source.html#l00264">llvm::Type::isSized()</a>, and <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01576">getAdjustedPtr()</a>.</p>

</div>
</div>
<a id="a4766fb3ad3333845a711a4762ac1dd46" name="a4766fb3ad3333845a711a4762ac1dd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4766fb3ad3333845a711a4762ac1dd46">&#9670;&nbsp;</a></span>getNaturalGEPWithType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * getNaturalGEPWithType </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>BasePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>TargetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a natural GEP off of the BasePtr walking through Ty toward TargetTy without changing the offset of the pointer. </p>
<p >This routine assumes we've already established a properly offset GEP with Indices, and arrived at the Ty type. The goal is to continue to GEP with zero-indices down through type layers until we find one the same as TargetTy. If we can't find one with the same type, we at least try to use one with the same size. If none of that works, we just produce the GEP as indicated by Indices to have the correct offset. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01418">1418</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l01395">buildGEP()</a>, <a class="el" href="SmallVector_8h_source.html#l00129">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::end()</a>, <a class="el" href="SmallVector_8h_source.html#l00434">llvm::SmallVectorImpl&lt; T &gt;::erase()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00678">llvm::DataLayout::getIndexTypeSizeInBits()</a>, <a class="el" href="Type_8h_source.html#l00223">llvm::Type::isPointerTy()</a>, and <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01462">getNaturalGEPRecursively()</a>.</p>

</div>
</div>
<a id="ad866ad1da941867a398da262103469b1" name="ad866ad1da941867a398da262103469b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad866ad1da941867a398da262103469b1">&#9670;&nbsp;</a></span>getTypePartition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Type.html">Type</a> * getTypePartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find a partition of the aggregate type passed in for a given offset and size. </p>
<p >This recurses through the aggregate type and tries to compute a subtype based on the offset and size. When the offset and size span a sub-section of an array, it will even compute a new array type for that sub-section, and the same for structs.</p>
<p >Note that this routine is very strict and tries to find a partition of the type which produces the <em>exact</em> right offset and size. It is not forgiving when the size or offset cause either end of type-based partition to be off. Also, this is a best-effort routine. It is reasonable to give up and not return a type if necessary. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l03503">3503</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00335">llvm::StructType::element_begin()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00336">llvm::StructType::element_end()</a>, <a class="el" href="IntervalMap_8h_source.html#l00526">llvm::IntervalMapImpl::NodeRef::get()</a>, <a class="el" href="Type_8h_source.html#l00129">llvm::Type::getContext()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00083">llvm::StructLayout::getElementContainingOffset()</a>, <a class="el" href="DataLayout_8h_source.html#l00584">llvm::StructLayout::getElementOffset()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00346">llvm::StructType::getElementType()</a>, <a class="el" href="DataLayout_8h_source.html#l00570">llvm::StructLayout::getSizeInBytes()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00604">llvm::DataLayout::getStructLayout()</a>, <a class="el" href="DataLayout_8h_source.html#l00469">llvm::DataLayout::getTypeAllocSize()</a>, <a class="el" href="SROA_8cpp_source.html#l03503">getTypePartition()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00293">llvm::StructType::isPacked()</a>, <a class="el" href="ArrayRef_8h_source.html#l00450">llvm::makeArrayRef()</a>, <a class="el" href="Profile_8cpp_source.html#l00046">Size</a>, and <a class="el" href="SROA_8cpp_source.html#l03465">stripAggregateTypeWrapping()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03503">getTypePartition()</a>.</p>

</div>
</div>
<a id="a786d5a99befacdb30b3d3b5c3b07bd30" name="a786d5a99befacdb30b3d3b5c3b07bd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786d5a99befacdb30b3d3b5c3b07bd30">&#9670;&nbsp;</a></span>INITIALIZE_PASS_BEGIN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INITIALIZE_PASS_BEGIN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1sroa_1_1SROALegacyPass.html">SROALegacyPass</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;sroa&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Scalar Replacement Of Aggregates&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">false&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">false&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cad1dcbccfcc610dc8d47100b4871ef" name="a4cad1dcbccfcc610dc8d47100b4871ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cad1dcbccfcc610dc8d47100b4871ef">&#9670;&nbsp;</a></span>insertInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * insertInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02151">2151</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00066">llvm::IntegerType::getBitWidth()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00444">llvm::DataLayout::getTypeStoreSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00233">llvm::DataLayout::isBigEndian()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, and <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00231">Name</a>.</p>

</div>
</div>
<a id="a75cf62ffe10261611bab4d74598ab0e4" name="a75cf62ffe10261611bab4d74598ab0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf62ffe10261611bab4d74598ab0e4">&#9670;&nbsp;</a></span>insertVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * insertVector </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>BeginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02208">2208</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="IntervalMap_8h_source.html#l00526">llvm::IntervalMapImpl::NodeRef::get()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, and <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00231">Name</a>.</p>

</div>
</div>
<a id="a7fd9ee96f281dd94ed4119c2e45836bf" name="a7fd9ee96f281dd94ed4119c2e45836bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd9ee96f281dd94ed4119c2e45836bf">&#9670;&nbsp;</a></span>isIntegerWideningViable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isIntegerWideningViable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>AllocaTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the given alloca partition's integer operations can be widened to promotable ones. </p>
<p >This is a quick test to check whether we can rewrite the integer loads and stores to a particular alloca into wider loads and stores and be able to promote the resulting alloca. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02086">2086</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l01707">canConvertValue()</a>, <a class="el" href="Type_8h_source.html#l00129">llvm::Type::getContext()</a>, <a class="el" href="classllvm_1_1Type.html#a6a25ffe2ebf3154241881202468dca03">llvm::Type::getIntNTy()</a>, <a class="el" href="DataLayout_8h_source.html#l00601">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="DataLayout_8h_source.html#l00452">llvm::DataLayout::getTypeStoreSizeInBits()</a>, <a class="el" href="SROA_8cpp_source.html#l01999">isIntegerWideningViableForSlice()</a>, <a class="el" href="DataLayout_8h_source.html#l00254">llvm::DataLayout::isLegalInteger()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00052">llvm::IntegerType::MAX_INT_BITS</a>, and <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

</div>
</div>
<a id="a593afa69fb7cfbb4506f605bd785f923" name="a593afa69fb7cfbb4506f605bd785f923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593afa69fb7cfbb4506f605bd785f923">&#9670;&nbsp;</a></span>isIntegerWideningViableForSlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isIntegerWideningViableForSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Slice &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>AllocBeginOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>AllocaTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>WholeAllocaOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether a slice of an alloca is valid for integer widening. </p>
<p >This implements the necessary checking for the <code>isIntegerWideningViable</code> test below on a single slice of the alloca. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01999">1999</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l01707">canConvertValue()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00444">llvm::DataLayout::getTypeStoreSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00452">llvm::DataLayout::getTypeStoreSizeInBits()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00607">llvm::Instruction::isLifetimeStartOrEnd()</a>, <a class="el" href="Instructions_8h_source.html#l00231">llvm::LoadInst::isVolatile()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00091">MI</a>, <a class="el" href="SIInstrInfo_8cpp_source.html#l06142">SI</a>, and <a class="el" href="Profile_8cpp_source.html#l00046">Size</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l02086">isIntegerWideningViable()</a>.</p>

</div>
</div>
<a id="aab37469c4748a495736ad163ac54e776" name="aab37469c4748a495736ad163ac54e776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab37469c4748a495736ad163ac54e776">&#9670;&nbsp;</a></span>isSafePHIToSpeculate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isSafePHIToSpeculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;&#160;</td>
          <td class="paramname"><em>PN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PHI instructions that use an alloca and are subsequently loaded can be rewritten to load both input pointers in the pred blocks and then PHI the results, allowing the load of the alloca to be promoted. </p>
<p >From this: P2 = phi [i32* Alloca, i32* Other] V = load i32* P2 to: V1 = load i32* Alloca -&gt; will be mem2reg'd ... V2 = load i32* Other ... V = phi [i32 V1, i32 V2]</p>
<p >We can do this to a select if its only uses are loads and if the operands to the select can be loaded unconditionally.</p>
<p >FIXME: This should be hoisted into a generic utility, likely in Transforms/Util/Local.h </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01192">1192</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8h_source.html#l00240">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Module_8cpp_source.html#l00369">llvm::Module::getDataLayout()</a>, <a class="el" href="Instructions_8h_source.html#l02654">llvm::PHINode::getIncomingBlock()</a>, <a class="el" href="Instructions_8h_source.html#l02634">llvm::PHINode::getIncomingValue()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00678">llvm::DataLayout::getIndexTypeSizeInBits()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00055">llvm::Instruction::getModule()</a>, <a class="el" href="Instructions_8h_source.html#l02630">llvm::PHINode::getNumIncomingValues()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00644">llvm::Instruction::getNumSuccessors()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00066">llvm::Instruction::getParent()</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00137">llvm::BasicBlock::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00452">llvm::DataLayout::getTypeStoreSizeInBits()</a>, <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00342">Idx</a>, <a class="el" href="Loads_8cpp_source.html#l00201">llvm::isSafeToLoadUnconditionally()</a>, <a class="el" href="Instructions_8h_source.html#l00276">llvm::LoadInst::isSimple()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00572">llvm::Instruction::mayHaveSideEffects()</a>, <a class="el" href="Profile_8cpp_source.html#l00046">Size</a>, <a class="el" href="APInt_8h_source.html#l01184">llvm::APInt::ult()</a>, and <a class="el" href="Value_8h_source.html#l00399">llvm::Value::users()</a>.</p>

</div>
</div>
<a id="a93e373cfa6ef51df8f9c43dc8b8539c0" name="a93e373cfa6ef51df8f9c43dc8b8539c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e373cfa6ef51df8f9c43dc8b8539c0">&#9670;&nbsp;</a></span>isSafeSelectToSpeculate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isSafeSelectToSpeculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;&#160;</td>
          <td class="paramname"><em>SI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select instructions that use an alloca and are subsequently loaded can be rewritten to load both input pointers and then select between the result, allowing the load of the alloca to be promoted. </p>
<p >From this: P2 = select i1 cond, i32* Alloca, i32* Other V = load i32* P2 to: V1 = load i32* Alloca -&gt; will be mem2reg'd V2 = load i32* Other V = select i1 cond, i32 V1, i32 V2</p>
<p >We can do this to a select if its only uses are loads and if the operand to the select can be loaded unconditionally. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01328">1328</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8h_source.html#l00240">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="Loads_8cpp_source.html#l00201">llvm::isSafeToLoadUnconditionally()</a>, <a class="el" href="Instructions_8h_source.html#l00276">llvm::LoadInst::isSimple()</a>, and <a class="el" href="SIInstrInfo_8cpp_source.html#l06142">SI</a>.</p>

</div>
</div>
<a id="af6735614e085435a0f3bb90aab527213" name="af6735614e085435a0f3bb90aab527213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6735614e085435a0f3bb90aab527213">&#9670;&nbsp;</a></span>isVectorPromotionViable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classVectorType.html">VectorType</a> * isVectorPromotionViable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the given alloca partitioning and range of slices can be promoted to a vector. </p>
<p >This is a quick test to check whether we can rewrite a particular alloca partition (and its newly formed alloca) into a vector alloca with only whole-vector loads and stores such that it could be promoted to a vector SSA value. We only can ensure this for a limited set of operations, and we don't want to do the rewrites unless we are confident that the result will be promotable, so we have an early test here. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01883">1883</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00127">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::begin()</a>, <a class="el" href="SmallVector_8h_source.html#l00339">llvm::SmallVectorImpl&lt; T &gt;::clear()</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="SmallVector_8h_source.html#l00129">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::end()</a>, <a class="el" href="SmallVector_8h_source.html#l00434">llvm::SmallVectorImpl&lt; T &gt;::erase()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00601">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="SROA_8cpp_source.html#l01808">isVectorPromotionViableForSlice()</a>, <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, <a class="el" href="STLExtras_8h_source.html#l01232">llvm::remove_if()</a>, <a class="el" href="SIInstrInfo_8cpp_source.html#l06142">SI</a>, and <a class="el" href="STLExtras_8h_source.html#l01122">llvm::sort()</a>.</p>

</div>
</div>
<a id="ab4c31035e44c7bda618eb2eb81dcf314" name="ab4c31035e44c7bda618eb2eb81dcf314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c31035e44c7bda618eb2eb81dcf314">&#9670;&nbsp;</a></span>isVectorPromotionViableForSlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isVectorPromotionViableForSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Slice &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ElementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the given slice use can be promoted to a vector. </p>
<p >This function is called to test each entry in a partition which is slated for a single slice. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01808">1808</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SROA_8cpp_source.html#l01707">canConvertValue()</a>, <a class="el" href="IntervalMap_8h_source.html#l00526">llvm::IntervalMapImpl::NodeRef::get()</a>, <a class="el" href="classllvm_1_1Type.html#a6a25ffe2ebf3154241881202468dca03">llvm::Type::getIntNTy()</a>, <a class="el" href="Type_8h_source.html#l00376">llvm::Type::getPointerElementType()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="Type_8h_source.html#l00196">llvm::Type::isIntegerTy()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00607">llvm::Instruction::isLifetimeStartOrEnd()</a>, <a class="el" href="Type_8h_source.html#l00217">llvm::Type::isStructTy()</a>, <a class="el" href="Instructions_8h_source.html#l00231">llvm::LoadInst::isVolatile()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00091">MI</a>, <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, and <a class="el" href="SIInstrInfo_8cpp_source.html#l06142">SI</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01883">isVectorPromotionViable()</a>.</p>

</div>
</div>
<a id="aab38ec9ebc3b5d96a4b7ddcb11cfcd58" name="aab38ec9ebc3b5d96a4b7ddcb11cfcd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab38ec9ebc3b5d96a4b7ddcb11cfcd58">&#9670;&nbsp;</a></span>speculatePHINodeLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void speculatePHINodeLoads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;&#160;</td>
          <td class="paramname"><em>PN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01260">1260</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8h_source.html#l02688">llvm::PHINode::addIncoming()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00067">llvm::Instruction::eraseFromParent()</a>, <a class="el" href="TypeBasedAliasAnalysis_8cpp_source.html#l00522">llvm::Instruction::getAAMetadata()</a>, <a class="el" href="Instructions_8h_source.html#l00240">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Instructions_8h_source.html#l02654">llvm::PHINode::getIncomingBlock()</a>, <a class="el" href="Instructions_8h_source.html#l02634">llvm::PHINode::getIncomingValue()</a>, <a class="el" href="Value_8cpp_source.html#l00214">llvm::Value::getName()</a>, <a class="el" href="Instructions_8h_source.html#l02630">llvm::PHINode::getNumIncomingValues()</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00137">llvm::BasicBlock::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00342">Idx</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="DenseMap_8h_source.html#l00211">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::lookup()</a>, <a class="el" href="Value_8cpp_source.html#l00429">llvm::Value::replaceAllUsesWith()</a>, <a class="el" href="Value_8h_source.html#l00322">llvm::Value::use_empty()</a>, and <a class="el" href="IR_2Instruction_8h_source.html#l00063">llvm::Instruction::user_back()</a>.</p>

</div>
</div>
<a id="a7493b7d3b84612687869f2c3afed924b" name="a7493b7d3b84612687869f2c3afed924b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493b7d3b84612687869f2c3afed924b">&#9670;&nbsp;</a></span>speculateSelectInstLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void speculateSelectInstLoads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;&#160;</td>
          <td class="paramname"><em>SI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01352">1352</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00067">llvm::Instruction::eraseFromParent()</a>, <a class="el" href="TypeBasedAliasAnalysis_8cpp_source.html#l00522">llvm::Instruction::getAAMetadata()</a>, <a class="el" href="Instructions_8h_source.html#l00240">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Value_8cpp_source.html#l00214">llvm::Value::getName()</a>, <a class="el" href="Value_8h_source.html#l00244">llvm::Value::getType()</a>, <a class="el" href="Instructions_8h_source.html#l00276">llvm::LoadInst::isSimple()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="Value_8cpp_source.html#l00429">llvm::Value::replaceAllUsesWith()</a>, <a class="el" href="Metadata_8cpp_source.html#l01261">llvm::Instruction::setAAMetadata()</a>, <a class="el" href="Instructions_8cpp_source.html#l01341">llvm::LoadInst::setAlignment()</a>, and <a class="el" href="SIInstrInfo_8cpp_source.html#l06142">SI</a>.</p>

</div>
</div>
<a id="ace0cc1a6f5d1eb652844d9752b238390" name="ace0cc1a6f5d1eb652844d9752b238390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0cc1a6f5d1eb652844d9752b238390">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">MaxPartitionsPerAlloca&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Maximum number of partitions per alloca&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab96dad8afe38ad77a313ecac3d1f151a" name="ab96dad8afe38ad77a313ecac3d1f151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96dad8afe38ad77a313ecac3d1f151a">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">MaxUsesPerAllocaPartition&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Maximum number of <a class="el" href="DeadArgumentElimination_8cpp.html#aba008984447815eaf051160d45db9d18">uses</a> of a partition&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e323f27ddb83247b75a5b2d375d9216" name="a4e323f27ddb83247b75a5b2d375d9216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e323f27ddb83247b75a5b2d375d9216">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumAllocaPartitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of alloca partitions formed&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8043ffc0bf25bc77b88596ec2555d25f" name="a8043ffc0bf25bc77b88596ec2555d25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8043ffc0bf25bc77b88596ec2555d25f">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumAllocaPartitionUses&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of alloca partition <a class="el" href="DeadArgumentElimination_8cpp.html#aba008984447815eaf051160d45db9d18">uses</a> rewritten&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a618041bb2c6e95361ead0e45493039ef" name="a618041bb2c6e95361ead0e45493039ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618041bb2c6e95361ead0e45493039ef">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumAllocasAnalyzed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of allocas analyzed <a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#ab425c63346dc1b312c1f40f408d098c3">for</a> replacement&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af559aec98fbf691ccd4c3233556cc618" name="af559aec98fbf691ccd4c3233556cc618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af559aec98fbf691ccd4c3233556cc618">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumDeleted&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of <a class="el" href="InstructionSelect_8cpp.html#a474a9c43838a295e112a1f8864e03813">instructions</a> deleted&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1f1e2ef32da6004704b9dfd4d80482e" name="ae1f1e2ef32da6004704b9dfd4d80482e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f1e2ef32da6004704b9dfd4d80482e">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumLoadsSpeculated&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of loads speculated to allow promotion&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcd84289002379062d3d99430eb946df" name="adcd84289002379062d3d99430eb946df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd84289002379062d3d99430eb946df">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumNewAllocas&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of&#160;</td>
          <td class="paramname"><em>new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smaller allocas introduced&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd53eb32a458943eee0e59c868868419" name="afd53eb32a458943eee0e59c868868419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd53eb32a458943eee0e59c868868419">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumPromoted&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of allocas promoted to <a class="el" href="MemorySSA_8cpp.html#a20a60bdac22b099d87d8cb0c1d554120">SSA</a> values&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f794c154e83c0c1f7953596198faa8f" name="a3f794c154e83c0c1f7953596198faa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f794c154e83c0c1f7953596198faa8f">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumVectorized&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of vectorized aggregates&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29482246d1f1d9699e0a4786aafad1de" name="a29482246d1f1d9699e0a4786aafad1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29482246d1f1d9699e0a4786aafad1de">&#9670;&nbsp;</a></span>stripAggregateTypeWrapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Type.html">Type</a> * stripAggregateTypeWrapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strip aggregate type wrapping. </p>
<p >This removes no-op aggregate types wrapping an underlying type. It will strip as many layers of types as it can without changing either the type size or the allocated size. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l03465">3465</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayout_8cpp_source.html#l00083">llvm::StructLayout::getElementContainingOffset()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00604">llvm::DataLayout::getStructLayout()</a>, <a class="el" href="DataLayout_8h_source.html#l00469">llvm::DataLayout::getTypeAllocSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00601">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="Type_8h_source.html#l00249">llvm::Type::isSingleValueType()</a>, and <a class="el" href="SROA_8cpp_source.html#l03465">stripAggregateTypeWrapping()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03503">getTypePartition()</a>, and <a class="el" href="SROA_8cpp_source.html#l03465">stripAggregateTypeWrapping()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5b3f8e5f6c512fe6a5059dd0c51aec95" name="a5b3f8e5f6c512fe6a5059dd0c51aec95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3f8e5f6c512fe6a5059dd0c51aec95">&#9670;&nbsp;</a></span>Aggregates</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar Replacement Of Aggregates</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l04655">4655</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

</div>
</div>
<a id="acc7a95cb9fb444faf77cd626f1b8128b" name="acc7a95cb9fb444faf77cd626f1b8128b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7a95cb9fb444faf77cd626f1b8128b">&#9670;&nbsp;</a></span>false</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar Replacement Of false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l04656">4656</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

</div>
</div>
<a id="a6990f15b9f29df6e8497b3e53875ccab" name="a6990f15b9f29df6e8497b3e53875ccab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6990f15b9f29df6e8497b3e53875ccab">&#9670;&nbsp;</a></span>sroa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sroa</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l04655">4655</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

</div>
</div>
<a id="a7d421e9e5928497126c6ba95660ca17a" name="a7d421e9e5928497126c6ba95660ca17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d421e9e5928497126c6ba95660ca17a">&#9670;&nbsp;</a></span>SROARandomShuffleSlices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; SROARandomShuffleSlices(&quot;sroa-random-shuffle-slices&quot;, cl::init(false), cl::Hidden) </td>
          <td>(</td>
          <td class="paramtype">&quot;sroa-random-shuffle-slices&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(false)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hidden option to enable randomly shuffling the slices to help uncover instability in their order. </p>

</div>
</div>
<a id="ad4a5e59fb7c2bf5faa2870aa694d3b41" name="ad4a5e59fb7c2bf5faa2870aa694d3b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a5e59fb7c2bf5faa2870aa694d3b41">&#9670;&nbsp;</a></span>SROAStrictInbounds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; SROAStrictInbounds(&quot;sroa-strict-inbounds&quot;, cl::init(false), cl::Hidden) </td>
          <td>(</td>
          <td class="paramtype">&quot;sroa-strict-inbounds&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(false)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hidden option to experiment with completely strict handling of inbounds GEPs. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 13 2022 11:25:23 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
